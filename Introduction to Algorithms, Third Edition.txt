
The Role of Algorithms in Computing

What are algorithms? Why is the study of algorithms worthwhile? What is the role
of algorithms relative to other technologies used in computers? In this chapter, we
will answer these questions.

1.1 Algorithms
Informally, an algorithm is any well-deﬁned computational procedure that takes
some value, or set of values, as input and produces some value, or set of values, as
output. An algorithm is thus a sequence of computational steps that transform the
input into the output.
We can also view an algorithm as a tool for solving a well-speciﬁed computational problem. The statement of the problem speciﬁes in general terms the desired
input/output relationship. The algorithm describes a speciﬁc computational procedure for achieving that input/output relationship.
For example, we might need to sort a sequence of numbers into nondecreasing
order. This problem arises frequently in practice and provides fertile ground for
introducing many standard design techniques and analysis tools. Here is how we
formally deﬁne the sorting problem:
Input: A sequence of n numbers ha1 ; a2 ; : : : ; an i.
Output: A permutation (reordering) ha10 ; a20 ; : : : ; an0 i of the input sequence such
that a10  a20      an0 .
For example, given the input sequence h31; 41; 59; 26; 41; 58i, a sorting algorithm
returns as output the sequence h26; 31; 41; 41; 58; 59i. Such an input sequence is
called an instance of the sorting problem. In general, an instance of a problem
consists of the input (satisfying whatever constraints are imposed in the problem
statement) needed to compute a solution to the problem.

6

Chapter 1 The Role of Algorithms in Computing

Because many programs use it as an intermediate step, sorting is a fundamental
operation in computer science. As a result, we have a large number of good sorting
algorithms at our disposal. Which algorithm is best for a given application depends
on—among other factors—the number of items to be sorted, the extent to which
the items are already somewhat sorted, possible restrictions on the item values,
the architecture of the computer, and the kind of storage devices to be used: main
memory, disks, or even tapes.
An algorithm is said to be correct if, for every input instance, it halts with the
correct output. We say that a correct algorithm solves the given computational
problem. An incorrect algorithm might not halt at all on some input instances, or it
might halt with an incorrect answer. Contrary to what you might expect, incorrect
algorithms can sometimes be useful, if we can control their error rate. We shall see
an example of an algorithm with a controllable error rate in Chapter 31 when we
study algorithms for ﬁnding large prime numbers. Ordinarily, however, we shall
be concerned only with correct algorithms.
An algorithm can be speciﬁed in English, as a computer program, or even as
a hardware design. The only requirement is that the speciﬁcation must provide a
precise description of the computational procedure to be followed.
What kinds of problems are solved by algorithms?
Sorting is by no means the only computational problem for which algorithms have
been developed. (You probably suspected as much when you saw the size of this
book.) Practical applications of algorithms are ubiquitous and include the following examples:


The Human Genome Project has made great progress toward the goals of identifying all the 100,000 genes in human DNA, determining the sequences of the
3 billion chemical base pairs that make up human DNA, storing this information in databases, and developing tools for data analysis. Each of these steps
requires sophisticated algorithms. Although the solutions to the various problems involved are beyond the scope of this book, many methods to solve these
biological problems use ideas from several of the chapters in this book, thereby
enabling scientists to accomplish tasks while using resources efﬁciently. The
savings are in time, both human and machine, and in money, as more information can be extracted from laboratory techniques.



The Internet enables people all around the world to quickly access and retrieve
large amounts of information. With the aid of clever algorithms, sites on the
Internet are able to manage and manipulate this large volume of data. Examples
of problems that make essential use of algorithms include ﬁnding good routes
on which the data will travel (techniques for solving such problems appear in

1.1 Algorithms

7

Chapter 24), and using a search engine to quickly ﬁnd pages on which particular
information resides (related techniques are in Chapters 11 and 32).


Electronic commerce enables goods and services to be negotiated and exchanged electronically, and it depends on the privacy of personal information such as credit card numbers, passwords, and bank statements. The core
technologies used in electronic commerce include public-key cryptography and
digital signatures (covered in Chapter 31), which are based on numerical algorithms and number theory.



Manufacturing and other commercial enterprises often need to allocate scarce
resources in the most beneﬁcial way. An oil company may wish to know where
to place its wells in order to maximize its expected proﬁt. A political candidate
may want to determine where to spend money buying campaign advertising in
order to maximize the chances of winning an election. An airline may wish
to assign crews to ﬂights in the least expensive way possible, making sure that
each ﬂight is covered and that government regulations regarding crew scheduling are met. An Internet service provider may wish to determine where to place
additional resources in order to serve its customers more effectively. All of
these are examples of problems that can be solved using linear programming,
which we shall study in Chapter 29.

Although some of the details of these examples are beyond the scope of this
book, we do give underlying techniques that apply to these problems and problem
areas. We also show how to solve many speciﬁc problems, including the following:


We are given a road map on which the distance between each pair of adjacent
intersections is marked, and we wish to determine the shortest route from one
intersection to another. The number of possible routes can be huge, even if we
disallow routes that cross over themselves. How do we choose which of all
possible routes is the shortest? Here, we model the road map (which is itself
a model of the actual roads) as a graph (which we will meet in Part VI and
Appendix B), and we wish to ﬁnd the shortest path from one vertex to another
in the graph. We shall see how to solve this problem efﬁciently in Chapter 24.



We are given two ordered sequences of symbols, X D hx1 ; x2 ; : : : ; xm i and
Y D hy1 ; y2 ; : : : ; yn i, and we wish to ﬁnd a longest common subsequence of
X and Y . A subsequence of X is just X with some (or possibly all or none) of
its elements removed. For example, one subsequence of hA; B; C; D; E; F; Gi
would be hB; C; E; Gi. The length of a longest common subsequence of X
and Y gives one measure of how similar these two sequences are. For example,
if the two sequences are base pairs in DNA strands, then we might consider
them similar if they have a long common subsequence. If X has m symbols
and Y has n symbols, then X and Y have 2m and 2n possible subsequences,

8

Chapter 1 The Role of Algorithms in Computing

respectively. Selecting all possible subsequences of X and Y and matching
them up could take a prohibitively long time unless m and n are very small.
We shall see in Chapter 15 how to use a general technique known as dynamic
programming to solve this problem much more efﬁciently.


We are given a mechanical design in terms of a library of parts, where each part
may include instances of other parts, and we need to list the parts in order so
that each part appears before any part that uses it. If the design comprises n
parts, then there are nŠ possible orders, where nŠ denotes the factorial function.
Because the factorial function grows faster than even an exponential function,
we cannot feasibly generate each possible order and then verify that, within
that order, each part appears before the parts using it (unless we have only a
few parts). This problem is an instance of topological sorting, and we shall see
in Chapter 22 how to solve this problem efﬁciently.



We are given n points in the plane, and we wish to ﬁnd the convex hull of
these points. The convex hull is the smallest convex polygon containing the
points. Intuitively, we can think of each point as being represented by a nail
sticking out from a board. The convex hull would be represented by a tight
rubber band that surrounds all the nails. Each nail around which the rubber
band makes a turn is a vertex of the convex hull. (See Figure 33.6 on page 1029
for an example.) Any of the 2n subsets of the points might be the vertices
of the convex hull. Knowing which points are vertices of the convex hull is
not quite enough, either, since we also need to know the order in which they
appear. There are many choices, therefore, for the vertices of the convex hull.
Chapter 33 gives two good methods for ﬁnding the convex hull.

These lists are far from exhaustive (as you again have probably surmised from
this book’s heft), but exhibit two characteristics that are common to many interesting algorithmic problems:
1. They have many candidate solutions, the overwhelming majority of which do
not solve the problem at hand. Finding one that does, or one that is “best,” can
present quite a challenge.
2. They have practical applications. Of the problems in the above list, ﬁnding the
shortest path provides the easiest examples. A transportation ﬁrm, such as a
trucking or railroad company, has a ﬁnancial interest in ﬁnding shortest paths
through a road or rail network because taking shorter paths results in lower
labor and fuel costs. Or a routing node on the Internet may need to ﬁnd the
shortest path through the network in order to route a message quickly. Or a
person wishing to drive from New York to Boston may want to ﬁnd driving
directions from an appropriate Web site, or she may use her GPS while driving.

1.1 Algorithms

9

Not every problem solved by algorithms has an easily identiﬁed set of candidate
solutions. For example, suppose we are given a set of numerical values representing samples of a signal, and we want to compute the discrete Fourier transform of
these samples. The discrete Fourier transform converts the time domain to the frequency domain, producing a set of numerical coefﬁcients, so that we can determine
the strength of various frequencies in the sampled signal. In addition to lying at
the heart of signal processing, discrete Fourier transforms have applications in data
compression and multiplying large polynomials and integers. Chapter 30 gives
an efﬁcient algorithm, the fast Fourier transform (commonly called the FFT), for
this problem, and the chapter also sketches out the design of a hardware circuit to
compute the FFT.
Data structures
This book also contains several data structures. A data structure is a way to store
and organize data in order to facilitate access and modiﬁcations. No single data
structure works well for all purposes, and so it is important to know the strengths
and limitations of several of them.
Technique
Although you can use this book as a “cookbook” for algorithms, you may someday
encounter a problem for which you cannot readily ﬁnd a published algorithm (many
of the exercises and problems in this book, for example). This book will teach you
techniques of algorithm design and analysis so that you can develop algorithms on
your own, show that they give the correct answer, and understand their efﬁciency.
Different chapters address different aspects of algorithmic problem solving. Some
chapters address speciﬁc problems, such as ﬁnding medians and order statistics in
Chapter 9, computing minimum spanning trees in Chapter 23, and determining a
maximum ﬂow in a network in Chapter 26. Other chapters address techniques,
such as divide-and-conquer in Chapter 4, dynamic programming in Chapter 15,
and amortized analysis in Chapter 17.
Hard problems
Most of this book is about efﬁcient algorithms. Our usual measure of efﬁciency
is speed, i.e., how long an algorithm takes to produce its result. There are some
problems, however, for which no efﬁcient solution is known. Chapter 34 studies
an interesting subset of these problems, which are known as NP-complete.
Why are NP-complete problems interesting? First, although no efﬁcient algorithm for an NP-complete problem has ever been found, nobody has ever proven

10

Chapter 1 The Role of Algorithms in Computing

that an efﬁcient algorithm for one cannot exist. In other words, no one knows
whether or not efﬁcient algorithms exist for NP-complete problems. Second, the
set of NP-complete problems has the remarkable property that if an efﬁcient algorithm exists for any one of them, then efﬁcient algorithms exist for all of them. This
relationship among the NP-complete problems makes the lack of efﬁcient solutions
all the more tantalizing. Third, several NP-complete problems are similar, but not
identical, to problems for which we do know of efﬁcient algorithms. Computer
scientists are intrigued by how a small change to the problem statement can cause
a big change to the efﬁciency of the best known algorithm.
You should know about NP-complete problems because some of them arise surprisingly often in real applications. If you are called upon to produce an efﬁcient
algorithm for an NP-complete problem, you are likely to spend a lot of time in a
fruitless search. If you can show that the problem is NP-complete, you can instead
spend your time developing an efﬁcient algorithm that gives a good, but not the
best possible, solution.
As a concrete example, consider a delivery company with a central depot. Each
day, it loads up each delivery truck at the depot and sends it around to deliver goods
to several addresses. At the end of the day, each truck must end up back at the depot
so that it is ready to be loaded for the next day. To reduce costs, the company wants
to select an order of delivery stops that yields the lowest overall distance traveled
by each truck. This problem is the well-known “traveling-salesman problem,” and
it is NP-complete. It has no known efﬁcient algorithm. Under certain assumptions,
however, we know of efﬁcient algorithms that give an overall distance which is
not too far above the smallest possible. Chapter 35 discusses such “approximation
algorithms.”
Parallelism
For many years, we could count on processor clock speeds increasing at a steady
rate. Physical limitations present a fundamental roadblock to ever-increasing clock
speeds, however: because power density increases superlinearly with clock speed,
chips run the risk of melting once their clock speeds become high enough. In order
to perform more computations per second, therefore, chips are being designed to
contain not just one but several processing “cores.” We can liken these multicore
computers to several sequential computers on a single chip; in other words, they are
a type of “parallel computer.” In order to elicit the best performance from multicore
computers, we need to design algorithms with parallelism in mind. Chapter 27
presents a model for “multithreaded” algorithms, which take advantage of multiple
cores. This model has advantages from a theoretical standpoint, and it forms the
basis of several successful computer programs, including a championship chess
program.

1.2 Algorithms as a technology

11

Exercises
1.1-1
Give a real-world example that requires sorting or a real-world example that requires computing a convex hull.
1.1-2
Other than speed, what other measures of efﬁciency might one use in a real-world
setting?
1.1-3
Select a data structure that you have seen previously, and discuss its strengths and
limitations.
1.1-4
How are the shortest-path and traveling-salesman problems given above similar?
How are they different?
1.1-5
Come up with a real-world problem in which only the best solution will do. Then
come up with one in which a solution that is “approximately” the best is good
enough.

1.2 Algorithms as a technology
Suppose computers were inﬁnitely fast and computer memory was free. Would
you have any reason to study algorithms? The answer is yes, if for no other reason
than that you would still like to demonstrate that your solution method terminates
and does so with the correct answer.
If computers were inﬁnitely fast, any correct method for solving a problem
would do. You would probably want your implementation to be within the bounds
of good software engineering practice (for example, your implementation should
be well designed and documented), but you would most often use whichever
method was the easiest to implement.
Of course, computers may be fast, but they are not inﬁnitely fast. And memory
may be inexpensive, but it is not free. Computing time is therefore a bounded
resource, and so is space in memory. You should use these resources wisely, and
algorithms that are efﬁcient in terms of time or space will help you do so.

12

Chapter 1 The Role of Algorithms in Computing

Efﬁciency
Different algorithms devised to solve the same problem often differ dramatically in
their efﬁciency. These differences can be much more signiﬁcant than differences
due to hardware and software.
As an example, in Chapter 2, we will see two algorithms for sorting. The ﬁrst,
known as insertion sort, takes time roughly equal to c1 n2 to sort n items, where c1
is a constant that does not depend on n. That is, it takes time roughly proportional
to n2 . The second, merge sort, takes time roughly equal to c2 n lg n, where lg n
stands for log2 n and c2 is another constant that also does not depend on n. Insertion sort typically has a smaller constant factor than merge sort, so that c1 < c2 .
We shall see that the constant factors can have far less of an impact on the running
time than the dependence on the input size n. Let’s write insertion sort’s running
time as c1 n  n and merge sort’s running time as c2 n  lg n. Then we see that where
insertion sort has a factor of n in its running time, merge sort has a factor of lg n,
which is much smaller. (For example, when n D 1000, lg n is approximately 10,
and when n equals one million, lg n is approximately only 20.) Although insertion
sort usually runs faster than merge sort for small input sizes, once the input size n
becomes large enough, merge sort’s advantage of lg n vs. n will more than compensate for the difference in constant factors. No matter how much smaller c1 is
than c2 , there will always be a crossover point beyond which merge sort is faster.
For a concrete example, let us pit a faster computer (computer A) running insertion sort against a slower computer (computer B) running merge sort. They each
must sort an array of 10 million numbers. (Although 10 million numbers might
seem like a lot, if the numbers are eight-byte integers, then the input occupies
about 80 megabytes, which ﬁts in the memory of even an inexpensive laptop computer many times over.) Suppose that computer A executes 10 billion instructions
per second (faster than any single sequential computer at the time of this writing)
and computer B executes only 10 million instructions per second, so that computer A is 1000 times faster than computer B in raw computing power. To make
the difference even more dramatic, suppose that the world’s craftiest programmer
codes insertion sort in machine language for computer A, and the resulting code
requires 2n2 instructions to sort n numbers. Suppose further that just an average
programmer implements merge sort, using a high-level language with an inefﬁcient
compiler, with the resulting code taking 50n lg n instructions. To sort 10 million
numbers, computer A takes
2  .107 /2 instructions
D 20,000 seconds (more than 5.5 hours) ;
1010 instructions/second
while computer B takes

1.2 Algorithms as a technology

13

50  107 lg 107 instructions
 1163 seconds (less than 20 minutes) :
107 instructions/second
By using an algorithm whose running time grows more slowly, even with a poor
compiler, computer B runs more than 17 times faster than computer A! The advantage of merge sort is even more pronounced when we sort 100 million numbers:
where insertion sort takes more than 23 days, merge sort takes under four hours.
In general, as the problem size increases, so does the relative advantage of merge
sort.
Algorithms and other technologies
The example above shows that we should consider algorithms, like computer hardware, as a technology. Total system performance depends on choosing efﬁcient
algorithms as much as on choosing fast hardware. Just as rapid advances are being
made in other computer technologies, they are being made in algorithms as well.
You might wonder whether algorithms are truly that important on contemporary
computers in light of other advanced technologies, such as


advanced computer architectures and fabrication technologies,



easy-to-use, intuitive, graphical user interfaces (GUIs),



object-oriented systems,



integrated Web technologies, and



fast networking, both wired and wireless.

The answer is yes. Although some applications do not explicitly require algorithmic content at the application level (such as some simple, Web-based applications),
many do. For example, consider a Web-based service that determines how to travel
from one location to another. Its implementation would rely on fast hardware, a
graphical user interface, wide-area networking, and also possibly on object orientation. However, it would also require algorithms for certain operations, such
as ﬁnding routes (probably using a shortest-path algorithm), rendering maps, and
interpolating addresses.
Moreover, even an application that does not require algorithmic content at the
application level relies heavily upon algorithms. Does the application rely on fast
hardware? The hardware design used algorithms. Does the application rely on
graphical user interfaces? The design of any GUI relies on algorithms. Does the
application rely on networking? Routing in networks relies heavily on algorithms.
Was the application written in a language other than machine code? Then it was
processed by a compiler, interpreter, or assembler, all of which make extensive use

14

Chapter 1 The Role of Algorithms in Computing

of algorithms. Algorithms are at the core of most technologies used in contemporary computers.
Furthermore, with the ever-increasing capacities of computers, we use them to
solve larger problems than ever before. As we saw in the above comparison between insertion sort and merge sort, it is at larger problem sizes that the differences
in efﬁciency between algorithms become particularly prominent.
Having a solid base of algorithmic knowledge and technique is one characteristic
that separates the truly skilled programmers from the novices. With modern computing technology, you can accomplish some tasks without knowing much about
algorithms, but with a good background in algorithms, you can do much, much
more.
Exercises
1.2-1
Give an example of an application that requires algorithmic content at the application level, and discuss the function of the algorithms involved.
1.2-2
Suppose we are comparing implementations of insertion sort and merge sort on the
same machine. For inputs of size n, insertion sort runs in 8n2 steps, while merge
sort runs in 64n lg n steps. For which values of n does insertion sort beat merge
sort?
1.2-3
What is the smallest value of n such that an algorithm whose running time is 100n2
runs faster than an algorithm whose running time is 2n on the same machine?

Problems
1-1 Comparison of running times
For each function f .n/ and time t in the following table, determine the largest
size n of a problem that can be solved in time t, assuming that the algorithm to
solve the problem takes f .n/ microseconds.

Notes for Chapter 1

1
second

15

1
minute

1
hour

1
day

1
month

1
year

1
century

lg n
p
n
n
n lg n
n2
n3
2n
nŠ

Chapter notes
There are many excellent texts on the general topic of algorithms, including those
by Aho, Hopcroft, and Ullman [5, 6]; Baase and Van Gelder [28]; Brassard and
Bratley [54]; Dasgupta, Papadimitriou, and Vazirani [82]; Goodrich and Tamassia
[148]; Hofri [175]; Horowitz, Sahni, and Rajasekaran [181]; Johnsonbaugh and
Schaefer [193]; Kingston [205]; Kleinberg and Tardos [208]; Knuth [209, 210,
211]; Kozen [220]; Levitin [235]; Manber [242]; Mehlhorn [249, 250, 251]; Purdom and Brown [287]; Reingold, Nievergelt, and Deo [293]; Sedgewick [306];
Sedgewick and Flajolet [307]; Skiena [318]; and Wilf [356]. Some of the more
practical aspects of algorithm design are discussed by Bentley [42, 43] and Gonnet
[145]. Surveys of the ﬁeld of algorithms can also be found in the Handbook of Theoretical Computer Science, Volume A [342] and the CRC Algorithms and Theory of
Computation Handbook [25]. Overviews of the algorithms used in computational
biology can be found in textbooks by Gusﬁeld [156], Pevzner [275], Setubal and
Meidanis [310], and Waterman [350].

2

Getting Started

This chapter will familiarize you with the framework we shall use throughout the
book to think about the design and analysis of algorithms. It is self-contained, but
it does include several references to material that we introduce in Chapters 3 and 4.
(It also contains several summations, which Appendix A shows how to solve.)
We begin by examining the insertion sort algorithm to solve the sorting problem
introduced in Chapter 1. We deﬁne a “pseudocode” that should be familiar to you if
you have done computer programming, and we use it to show how we shall specify
our algorithms. Having speciﬁed the insertion sort algorithm, we then argue that it
correctly sorts, and we analyze its running time. The analysis introduces a notation
that focuses on how that time increases with the number of items to be sorted.
Following our discussion of insertion sort, we introduce the divide-and-conquer
approach to the design of algorithms and use it to develop an algorithm called
merge sort. We end with an analysis of merge sort’s running time.

2.1

Insertion sort
Our ﬁrst algorithm, insertion sort, solves the sorting problem introduced in Chapter 1:
Input: A sequence of n numbers ha1 ; a2 ; : : : ; an i.
Output: A permutation (reordering) ha10 ; a20 ; : : : ; an0 i of the input sequence such
that a10  a20      an0 .
The numbers that we wish to sort are also known as the keys. Although conceptually we are sorting a sequence, the input comes to us in the form of an array with n
elements.
In this book, we shall typically describe algorithms as programs written in a
pseudocode that is similar in many respects to C, C++, Java, Python, or Pascal. If
you have been introduced to any of these languages, you should have little trouble

2.1 Insertion sort

17

♣♣
♣
♣♣
10
5♣ ♣
4 ♣♣
♣♣ ♣
♣
♣
♣
♣♣ ♣
7
♣

0
♣♣
♣
5♣
♣♣
♣
4 2♣
♣
♣
♣ ♣♣ ♣
♣♣

7
♣

2
♣

1

Figure 2.1 Sorting a hand of cards using insertion sort.

reading our algorithms. What separates pseudocode from “real” code is that in
pseudocode, we employ whatever expressive method is most clear and concise to
specify a given algorithm. Sometimes, the clearest method is English, so do not
be surprised if you come across an English phrase or sentence embedded within
a section of “real” code. Another difference between pseudocode and real code
is that pseudocode is not typically concerned with issues of software engineering.
Issues of data abstraction, modularity, and error handling are often ignored in order
to convey the essence of the algorithm more concisely.
We start with insertion sort, which is an efﬁcient algorithm for sorting a small
number of elements. Insertion sort works the way many people sort a hand of
playing cards. We start with an empty left hand and the cards face down on the
table. We then remove one card at a time from the table and insert it into the
correct position in the left hand. To ﬁnd the correct position for a card, we compare
it with each of the cards already in the hand, from right to left, as illustrated in
Figure 2.1. At all times, the cards held in the left hand are sorted, and these cards
were originally the top cards of the pile on the table.
We present our pseudocode for insertion sort as a procedure called I NSERTION S ORT, which takes as a parameter an array AŒ1 : : n containing a sequence of
length n that is to be sorted. (In the code, the number n of elements in A is denoted
by A:length.) The algorithm sorts the input numbers in place: it rearranges the
numbers within the array A, with at most a constant number of them stored outside
the array at any time. The input array A contains the sorted output sequence when
the I NSERTION -S ORT procedure is ﬁnished.

18

Chapter 2 Getting Started

1

2

3

4

5

6

(a)

5

2

4

6

1

3

1

2

3

4

5

6

(d)

2

4

5

6

1

3

1

2

3

4

5

6

(b)

2

5

4

6

1

3

1

2

3

4

5

6

(e)

1

2

4

5

6

3

1

2

3

4

5

6

(c)

2

4

5

6

1

3

1

2

3

4

5

6

(f)

1

2

3

4

5

6

Figure 2.2 The operation of I NSERTION -S ORT on the array A D h5; 2; 4; 6; 1; 3i. Array indices
appear above the rectangles, and values stored in the array positions appear within the rectangles.
(a)–(e) The iterations of the for loop of lines 1–8. In each iteration, the black rectangle holds the
key taken from AŒj , which is compared with the values in shaded rectangles to its left in the test of
line 5. Shaded arrows show array values moved one position to the right in line 6, and black arrows
indicate where the key moves to in line 8. (f) The ﬁnal sorted array.

I NSERTION -S ORT .A/
1 for j D 2 to A:length
2
key D AŒj 
3
// Insert AŒj  into the sorted sequence AŒ1 : : j  1.
4
i D j 1
5
while i > 0 and AŒi > key
6
AŒi C 1 D AŒi
7
i D i 1
8
AŒi C 1 D key
Loop invariants and the correctness of insertion sort
Figure 2.2 shows how this algorithm works for A D h5; 2; 4; 6; 1; 3i. The index j indicates the “current card” being inserted into the hand. At the beginning
of each iteration of the for loop, which is indexed by j , the subarray consisting
of elements AŒ1 : : j  1 constitutes the currently sorted hand, and the remaining
subarray AŒj C 1 : : n corresponds to the pile of cards still on the table. In fact,
elements AŒ1 : : j  1 are the elements originally in positions 1 through j  1, but
now in sorted order. We state these properties of AŒ1 : : j  1 formally as a loop
invariant:
At the start of each iteration of the for loop of lines 1–8, the subarray
AŒ1 : : j  1 consists of the elements originally in AŒ1 : : j  1, but in sorted
order.
We use loop invariants to help us understand why an algorithm is correct. We
must show three things about a loop invariant:

2.1 Insertion sort

19

Initialization: It is true prior to the ﬁrst iteration of the loop.
Maintenance: If it is true before an iteration of the loop, it remains true before the
next iteration.
Termination: When the loop terminates, the invariant gives us a useful property
that helps show that the algorithm is correct.
When the ﬁrst two properties hold, the loop invariant is true prior to every iteration
of the loop. (Of course, we are free to use established facts other than the loop
invariant itself to prove that the loop invariant remains true before each iteration.)
Note the similarity to mathematical induction, where to prove that a property holds,
you prove a base case and an inductive step. Here, showing that the invariant holds
before the ﬁrst iteration corresponds to the base case, and showing that the invariant
holds from iteration to iteration corresponds to the inductive step.
The third property is perhaps the most important one, since we are using the loop
invariant to show correctness. Typically, we use the loop invariant along with the
condition that caused the loop to terminate. The termination property differs from
how we usually use mathematical induction, in which we apply the inductive step
inﬁnitely; here, we stop the “induction” when the loop terminates.
Let us see how these properties hold for insertion sort.
Initialization: We start by showing that the loop invariant holds before the ﬁrst
loop iteration, when j D 2.1 The subarray AŒ1 : : j  1, therefore, consists
of just the single element AŒ1, which is in fact the original element in AŒ1.
Moreover, this subarray is sorted (trivially, of course), which shows that the
loop invariant holds prior to the ﬁrst iteration of the loop.
Maintenance: Next, we tackle the second property: showing that each iteration
maintains the loop invariant. Informally, the body of the for loop works by
moving AŒj  1, AŒj  2, AŒj  3, and so on by one position to the right
until it ﬁnds the proper position for AŒj  (lines 4–7), at which point it inserts
the value of AŒj  (line 8). The subarray AŒ1 : : j  then consists of the elements
originally in AŒ1 : : j , but in sorted order. Incrementing j for the next iteration
of the for loop then preserves the loop invariant.
A more formal treatment of the second property would require us to state and
show a loop invariant for the while loop of lines 5–7. At this point, however,

1 When

the loop is a for loop, the moment at which we check the loop invariant just prior to the ﬁrst
iteration is immediately after the initial assignment to the loop-counter variable and just before the
ﬁrst test in the loop header. In the case of I NSERTION -S ORT , this time is after assigning 2 to the
variable j but before the ﬁrst test of whether j  A: length.

20

Chapter 2 Getting Started

we prefer not to get bogged down in such formalism, and so we rely on our
informal analysis to show that the second property holds for the outer loop.
Termination: Finally, we examine what happens when the loop terminates. The
condition causing the for loop to terminate is that j > A:length D n. Because
each loop iteration increases j by 1, we must have j D n C 1 at that time.
Substituting n C 1 for j in the wording of loop invariant, we have that the
subarray AŒ1 : : n consists of the elements originally in AŒ1 : : n, but in sorted
order. Observing that the subarray AŒ1 : : n is the entire array, we conclude that
the entire array is sorted. Hence, the algorithm is correct.
We shall use this method of loop invariants to show correctness later in this
chapter and in other chapters as well.
Pseudocode conventions
We use the following conventions in our pseudocode.


Indentation indicates block structure. For example, the body of the for loop that
begins on line 1 consists of lines 2–8, and the body of the while loop that begins
on line 5 contains lines 6–7 but not line 8. Our indentation style applies to
if-else statements2 as well. Using indentation instead of conventional indicators
of block structure, such as begin and end statements, greatly reduces clutter
while preserving, or even enhancing, clarity.3



The looping constructs while, for, and repeat-until and the if-else conditional
construct have interpretations similar to those in C, C++, Java, Python, and
Pascal.4 In this book, the loop counter retains its value after exiting the loop,
unlike some situations that arise in C++, Java, and Pascal. Thus, immediately
after a for loop, the loop counter’s value is the value that ﬁrst exceeded the for
loop bound. We used this property in our correctness argument for insertion
sort. The for loop header in line 1 is for j D 2 to A:length, and so when
this loop terminates, j D A:length C 1 (or, equivalently, j D n C 1, since
n D A:length). We use the keyword to when a for loop increments its loop

2 In

an if-else statement, we indent else at the same level as its matching if. Although we omit the
keyword then, we occasionally refer to the portion executed when the test following if is true as a
then clause. For multiway tests, we use elseif for tests after the ﬁrst one.
3 Each

pseudocode procedure in this book appears on one page so that you will not have to discern
levels of indentation in code that is split across pages.
4 Most block-structured languages have equivalent constructs, though the exact syntax may differ.
Python lacks repeat-until loops, and its for loops operate a little differently from the for loops in
this book.

2.1 Insertion sort

21

counter in each iteration, and we use the keyword downto when a for loop
decrements its loop counter. When the loop counter changes by an amount
greater than 1, the amount of change follows the optional keyword by.


The symbol “//” indicates that the remainder of the line is a comment.



A multiple assignment of the form i D j D e assigns to both variables i and j
the value of expression e; it should be treated as equivalent to the assignment
j D e followed by the assignment i D j .



Variables (such as i, j , and key) are local to the given procedure. We shall not
use global variables without explicit indication.



We access array elements by specifying the array name followed by the index in square brackets. For example, AŒi indicates the ith element of the
array A. The notation “: :” is used to indicate a range of values within an array. Thus, AŒ1 : : j  indicates the subarray of A consisting of the j elements
AŒ1; AŒ2; : : : ; AŒj .



We typically organize compound data into objects, which are composed of
attributes. We access a particular attribute using the syntax found in many
object-oriented programming languages: the object name, followed by a dot,
followed by the attribute name. For example, we treat an array as an object
with the attribute length indicating how many elements it contains. To specify
the number of elements in an array A, we write A:length.
We treat a variable representing an array or object as a pointer to the data representing the array or object. For all attributes f of an object x, setting y D x
causes y:f to equal x:f . Moreover, if we now set x:f D 3, then afterward not
only does x:f equal 3, but y:f equals 3 as well. In other words, x and y point
to the same object after the assignment y D x.
Our attribute notation can “cascade.” For example, suppose that the attribute f
is itself a pointer to some type of object that has an attribute g. Then the notation
x:f :g is implicitly parenthesized as .x:f /:g. In other words, if we had assigned
y D x:f , then x:f :g is the same as y:g.
Sometimes, a pointer will refer to no object at all. In this case, we give it the
special value NIL.



We pass parameters to a procedure by value: the called procedure receives its
own copy of the parameters, and if it assigns a value to a parameter, the change
is not seen by the calling procedure. When objects are passed, the pointer to
the data representing the object is copied, but the object’s attributes are not. For
example, if x is a parameter of a called procedure, the assignment x D y within
the called procedure is not visible to the calling procedure. The assignment
x:f D 3, however, is visible. Similarly, arrays are passed by pointer, so that

22

Chapter 2 Getting Started

a pointer to the array is passed, rather than the entire array, and changes to
individual array elements are visible to the calling procedure.


A return statement immediately transfers control back to the point of call in
the calling procedure. Most return statements also take a value to pass back to
the caller. Our pseudocode differs from many programming languages in that
we allow multiple values to be returned in a single return statement.



The boolean operators “and” and “or” are short circuiting. That is, when we
evaluate the expression “x and y” we ﬁrst evaluate x. If x evaluates to FALSE,
then the entire expression cannot evaluate to TRUE, and so we do not evaluate y.
If, on the other hand, x evaluates to TRUE, we must evaluate y to determine the
value of the entire expression. Similarly, in the expression “x or y” we evaluate the expression y only if x evaluates to FALSE. Short-circuiting operators
allow us to write boolean expressions such as “x ¤ NIL and x:f D y” without
worrying about what happens when we try to evaluate x:f when x is NIL.



The keyword error indicates that an error occurred because conditions were
wrong for the procedure to have been called. The calling procedure is responsible for handling the error, and so we do not specify what action to take.

Exercises
2.1-1
Using Figure 2.2 as a model, illustrate the operation of I NSERTION -S ORT on the
array A D h31; 41; 59; 26; 41; 58i.
2.1-2
Rewrite the I NSERTION -S ORT procedure to sort into nonincreasing instead of nondecreasing order.
2.1-3
Consider the searching problem:
Input: A sequence of n numbers A D ha1 ; a2 ; : : : ; an i and a value .
Output: An index i such that  D AŒi or the special value NIL if  does not
appear in A.
Write pseudocode for linear search, which scans through the sequence, looking
for . Using a loop invariant, prove that your algorithm is correct. Make sure that
your loop invariant fulﬁlls the three necessary properties.
2.1-4
Consider the problem of adding two n-bit binary integers, stored in two n-element
arrays A and B. The sum of the two integers should be stored in binary form in

2.2 Analyzing algorithms

23

an .n C 1/-element array C . State the problem formally and write pseudocode for
adding the two integers.

2.2 Analyzing algorithms
Analyzing an algorithm has come to mean predicting the resources that the algorithm requires. Occasionally, resources such as memory, communication bandwidth, or computer hardware are of primary concern, but most often it is computational time that we want to measure. Generally, by analyzing several candidate
algorithms for a problem, we can identify a most efﬁcient one. Such analysis may
indicate more than one viable candidate, but we can often discard several inferior
algorithms in the process.
Before we can analyze an algorithm, we must have a model of the implementation technology that we will use, including a model for the resources of that
technology and their costs. For most of this book, we shall assume a generic oneprocessor, random-access machine (RAM) model of computation as our implementation technology and understand that our algorithms will be implemented as
computer programs. In the RAM model, instructions are executed one after another, with no concurrent operations.
Strictly speaking, we should precisely deﬁne the instructions of the RAM model
and their costs. To do so, however, would be tedious and would yield little insight
into algorithm design and analysis. Yet we must be careful not to abuse the RAM
model. For example, what if a RAM had an instruction that sorts? Then we could
sort in just one instruction. Such a RAM would be unrealistic, since real computers
do not have such instructions. Our guide, therefore, is how real computers are designed. The RAM model contains instructions commonly found in real computers:
arithmetic (such as add, subtract, multiply, divide, remainder, ﬂoor, ceiling), data
movement (load, store, copy), and control (conditional and unconditional branch,
subroutine call and return). Each such instruction takes a constant amount of time.
The data types in the RAM model are integer and ﬂoating point (for storing real
numbers). Although we typically do not concern ourselves with precision in this
book, in some applications precision is crucial. We also assume a limit on the size
of each word of data. For example, when working with inputs of size n, we typically assume that integers are represented by c lg n bits for some constant c  1.
We require c  1 so that each word can hold the value of n, enabling us to index the
individual input elements, and we restrict c to be a constant so that the word size
does not grow arbitrarily. (If the word size could grow arbitrarily, we could store
huge amounts of data in one word and operate on it all in constant time—clearly
an unrealistic scenario.)

24

Chapter 2 Getting Started

Real computers contain instructions not listed above, and such instructions represent a gray area in the RAM model. For example, is exponentiation a constanttime instruction? In the general case, no; it takes several instructions to compute x y
when x and y are real numbers. In restricted situations, however, exponentiation is
a constant-time operation. Many computers have a “shift left” instruction, which
in constant time shifts the bits of an integer by k positions to the left. In most
computers, shifting the bits of an integer by one position to the left is equivalent
to multiplication by 2, so that shifting the bits by k positions to the left is equivalent to multiplication by 2k . Therefore, such computers can compute 2k in one
constant-time instruction by shifting the integer 1 by k positions to the left, as long
as k is no more than the number of bits in a computer word. We will endeavor to
avoid such gray areas in the RAM model, but we will treat computation of 2k as a
constant-time operation when k is a small enough positive integer.
In the RAM model, we do not attempt to model the memory hierarchy that is
common in contemporary computers. That is, we do not model caches or virtual
memory. Several computational models attempt to account for memory-hierarchy
effects, which are sometimes signiﬁcant in real programs on real machines. A
handful of problems in this book examine memory-hierarchy effects, but for the
most part, the analyses in this book will not consider them. Models that include
the memory hierarchy are quite a bit more complex than the RAM model, and so
they can be difﬁcult to work with. Moreover, RAM-model analyses are usually
excellent predictors of performance on actual machines.
Analyzing even a simple algorithm in the RAM model can be a challenge. The
mathematical tools required may include combinatorics, probability theory, algebraic dexterity, and the ability to identify the most signiﬁcant terms in a formula.
Because the behavior of an algorithm may be different for each possible input, we
need a means for summarizing that behavior in simple, easily understood formulas.
Even though we typically select only one machine model to analyze a given algorithm, we still face many choices in deciding how to express our analysis. We
would like a way that is simple to write and manipulate, shows the important characteristics of an algorithm’s resource requirements, and suppresses tedious details.
Analysis of insertion sort
The time taken by the I NSERTION -S ORT procedure depends on the input: sorting a
thousand numbers takes longer than sorting three numbers. Moreover, I NSERTION S ORT can take different amounts of time to sort two input sequences of the same
size depending on how nearly sorted they already are. In general, the time taken
by an algorithm grows with the size of the input, so it is traditional to describe the
running time of a program as a function of the size of its input. To do so, we need
to deﬁne the terms “running time” and “size of input” more carefully.

2.2 Analyzing algorithms

25

The best notion for input size depends on the problem being studied. For many
problems, such as sorting or computing discrete Fourier transforms, the most natural measure is the number of items in the input—for example, the array size n
for sorting. For many other problems, such as multiplying two integers, the best
measure of input size is the total number of bits needed to represent the input in
ordinary binary notation. Sometimes, it is more appropriate to describe the size of
the input with two numbers rather than one. For instance, if the input to an algorithm is a graph, the input size can be described by the numbers of vertices and
edges in the graph. We shall indicate which input size measure is being used with
each problem we study.
The running time of an algorithm on a particular input is the number of primitive
operations or “steps” executed. It is convenient to deﬁne the notion of step so
that it is as machine-independent as possible. For the moment, let us adopt the
following view. A constant amount of time is required to execute each line of our
pseudocode. One line may take a different amount of time than another line, but
we shall assume that each execution of the ith line takes time ci , where ci is a
constant. This viewpoint is in keeping with the RAM model, and it also reﬂects
how the pseudocode would be implemented on most actual computers.5
In the following discussion, our expression for the running time of I NSERTION S ORT will evolve from a messy formula that uses all the statement costs ci to a
much simpler notation that is more concise and more easily manipulated. This
simpler notation will also make it easy to determine whether one algorithm is more
efﬁcient than another.
We start by presenting the I NSERTION -S ORT procedure with the time “cost”
of each statement and the number of times each statement is executed. For each
j D 2; 3; : : : ; n, where n D A:length, we let tj denote the number of times the
while loop test in line 5 is executed for that value of j . When a for or while loop
exits in the usual way (i.e., due to the test in the loop header), the test is executed
one time more than the loop body. We assume that comments are not executable
statements, and so they take no time.

5 There are some subtleties here. Computational steps that we specify in English are often variants
of a procedure that requires more than just a constant amount of time. For example, later in this
book we might say “sort the points by x-coordinate,” which, as we shall see, takes more than a
constant amount of time. Also, note that a statement that calls a subroutine takes constant time,
though the subroutine, once invoked, may take more. That is, we separate the process of calling the
subroutine—passing parameters to it, etc.—from the process of executing the subroutine.

26

Chapter 2 Getting Started

I NSERTION -S ORT .A/
1 for j D 2 to A:length
2
key D AŒj 
3
// Insert AŒj  into the sorted
sequence AŒ1 : : j  1.
4
i D j 1
5
while i > 0 and AŒi > key
6
AŒi C 1 D AŒi
7
i D i 1
8
AŒi C 1 D key

cost
c1
c2

times
n
n1

0
c4
c5
c6
c7
c8

n1
n
P 1
n

t
PjnD2 j
.t  1/
PjnD2 j
.t
j D2 j  1/
n1

The running time of the algorithm is the sum of running times for each statement executed; a statement that takes ci steps to execute and executes n times will
contribute ci n to the total running time.6 To compute T .n/, the running time of
I NSERTION -S ORT on an input of n values, we sum the products of the cost and
times columns, obtaining
T .n/ D c1 n C c2 .n  1/ C c4 .n  1/ C c5

n
X
j D2

C c7

n
X

tj C c6

n
X
.tj  1/
j D2

.tj  1/ C c8 .n  1/ :

j D2

Even for inputs of a given size, an algorithm’s running time may depend on
which input of that size is given. For example, in I NSERTION -S ORT, the best
case occurs if the array is already sorted. For each j D 2; 3; : : : ; n, we then ﬁnd
that AŒi  key in line 5 when i has its initial value of j  1. Thus tj D 1 for
j D 2; 3; : : : ; n, and the best-case running time is
T .n/ D c1 n C c2 .n  1/ C c4 .n  1/ C c5 .n  1/ C c8 .n  1/
D .c1 C c2 C c4 C c5 C c8 /n  .c2 C c4 C c5 C c8 / :
We can express this running time as an C b for constants a and b that depend on
the statement costs ci ; it is thus a linear function of n.
If the array is in reverse sorted order—that is, in decreasing order—the worst
case results. We must compare each element AŒj  with each element in the entire
sorted subarray AŒ1 : : j  1, and so tj D j for j D 2; 3; : : : ; n. Noting that

6 This characteristic does not necessarily hold for a resource such as memory. A statement that
references m words of memory and is executed n times does not necessarily reference mn distinct
words of memory.

2.2 Analyzing algorithms
n
X
j D2

j D

27

n.n C 1/
1
2

and
n
X
n.n  1/
.j  1/ D
2
j D2

(see Appendix A for a review of how to solve these summations), we ﬁnd that in
the worst case, the running time of I NSERTION -S ORT is


n.n C 1/
1
T .n/ D c1 n C c2 .n  1/ C c4 .n  1/ C c5
2




n.n  1/
n.n  1/
C c7
C c8 .n  1/
C c6
2
2

c
c6
c7  2 
c5 c6 c7
5
C
C
n C c1 C c2 C c4 C


C c8 n
D
2
2
2
2
2
2
 .c2 C c4 C c5 C c8 / :
We can express this worst-case running time as an2 C bn C c for constants a, b,
and c that again depend on the statement costs ci ; it is thus a quadratic function
of n.
Typically, as in insertion sort, the running time of an algorithm is ﬁxed for a
given input, although in later chapters we shall see some interesting “randomized”
algorithms whose behavior can vary even for a ﬁxed input.
Worst-case and average-case analysis
In our analysis of insertion sort, we looked at both the best case, in which the input
array was already sorted, and the worst case, in which the input array was reverse
sorted. For the remainder of this book, though, we shall usually concentrate on
ﬁnding only the worst-case running time, that is, the longest running time for any
input of size n. We give three reasons for this orientation.


The worst-case running time of an algorithm gives us an upper bound on the
running time for any input. Knowing it provides a guarantee that the algorithm
will never take any longer. We need not make some educated guess about the
running time and hope that it never gets much worse.



For some algorithms, the worst case occurs fairly often. For example, in searching a database for a particular piece of information, the searching algorithm’s
worst case will often occur when the information is not present in the database.
In some applications, searches for absent information may be frequent.

28

Chapter 2 Getting Started



The “average case” is often roughly as bad as the worst case. Suppose that we
randomly choose n numbers and apply insertion sort. How long does it take to
determine where in subarray AŒ1 : : j  1 to insert element AŒj ? On average,
half the elements in AŒ1 : : j  1 are less than AŒj , and half the elements are
greater. On average, therefore, we check half of the subarray AŒ1 : : j  1, and
so tj is about j=2. The resulting average-case running time turns out to be a
quadratic function of the input size, just like the worst-case running time.

In some particular cases, we shall be interested in the average-case running time
of an algorithm; we shall see the technique of probabilistic analysis applied to
various algorithms throughout this book. The scope of average-case analysis is
limited, because it may not be apparent what constitutes an “average” input for
a particular problem. Often, we shall assume that all inputs of a given size are
equally likely. In practice, this assumption may be violated, but we can sometimes
use a randomized algorithm, which makes random choices, to allow a probabilistic
analysis and yield an expected running time. We explore randomized algorithms
more in Chapter 5 and in several other subsequent chapters.
Order of growth
We used some simplifying abstractions to ease our analysis of the I NSERTION S ORT procedure. First, we ignored the actual cost of each statement, using the
constants ci to represent these costs. Then, we observed that even these constants
give us more detail than we really need: we expressed the worst-case running time
as an2 C bn C c for some constants a, b, and c that depend on the statement
costs ci . We thus ignored not only the actual statement costs, but also the abstract
costs ci .
We shall now make one more simplifying abstraction: it is the rate of growth,
or order of growth, of the running time that really interests us. We therefore consider only the leading term of a formula (e.g., an2 ), since the lower-order terms are
relatively insigniﬁcant for large values of n. We also ignore the leading term’s constant coefﬁcient, since constant factors are less signiﬁcant than the rate of growth
in determining computational efﬁciency for large inputs. For insertion sort, when
we ignore the lower-order terms and the leading term’s constant coefﬁcient, we are
left with the factor of n2 from the leading term. We write that insertion sort has a
worst-case running time of ‚.n2 / (pronounced “theta of n-squared”). We shall use
‚-notation informally in this chapter, and we will deﬁne it precisely in Chapter 3.
We usually consider one algorithm to be more efﬁcient than another if its worstcase running time has a lower order of growth. Due to constant factors and lowerorder terms, an algorithm whose running time has a higher order of growth might
take less time for small inputs than an algorithm whose running time has a lower

2.3 Designing algorithms

29

order of growth. But for large enough inputs, a ‚.n2 / algorithm, for example, will
run more quickly in the worst case than a ‚.n3 / algorithm.
Exercises
2.2-1
Express the function n3 =1000  100n2  100n C 3 in terms of ‚-notation.
2.2-2
Consider sorting n numbers stored in array A by ﬁrst ﬁnding the smallest element
of A and exchanging it with the element in AŒ1. Then ﬁnd the second smallest
element of A, and exchange it with AŒ2. Continue in this manner for the ﬁrst n  1
elements of A. Write pseudocode for this algorithm, which is known as selection
sort. What loop invariant does this algorithm maintain? Why does it need to run
for only the ﬁrst n  1 elements, rather than for all n elements? Give the best-case
and worst-case running times of selection sort in ‚-notation.
2.2-3
Consider linear search again (see Exercise 2.1-3). How many elements of the input sequence need to be checked on the average, assuming that the element being
searched for is equally likely to be any element in the array? How about in the
worst case? What are the average-case and worst-case running times of linear
search in ‚-notation? Justify your answers.
2.2-4
How can we modify almost any algorithm to have a good best-case running time?

2.3 Designing algorithms
We can choose from a wide range of algorithm design techniques. For insertion
sort, we used an incremental approach: having sorted the subarray AŒ1 : : j  1,
we inserted the single element AŒj  into its proper place, yielding the sorted
subarray AŒ1 : : j .
In this section, we examine an alternative design approach, known as “divideand-conquer,” which we shall explore in more detail in Chapter 4. We’ll use divideand-conquer to design a sorting algorithm whose worst-case running time is much
less than that of insertion sort. One advantage of divide-and-conquer algorithms is
that their running times are often easily determined using techniques that we will
see in Chapter 4.

30

Chapter 2 Getting Started

2.3.1

The divide-and-conquer approach

Many useful algorithms are recursive in structure: to solve a given problem, they
call themselves recursively one or more times to deal with closely related subproblems. These algorithms typically follow a divide-and-conquer approach: they
break the problem into several subproblems that are similar to the original problem but smaller in size, solve the subproblems recursively, and then combine these
solutions to create a solution to the original problem.
The divide-and-conquer paradigm involves three steps at each level of the recursion:
Divide the problem into a number of subproblems that are smaller instances of the
same problem.
Conquer the subproblems by solving them recursively. If the subproblem sizes are
small enough, however, just solve the subproblems in a straightforward manner.
Combine the solutions to the subproblems into the solution for the original problem.
The merge sort algorithm closely follows the divide-and-conquer paradigm. Intuitively, it operates as follows.
Divide: Divide the n-element sequence to be sorted into two subsequences of n=2
elements each.
Conquer: Sort the two subsequences recursively using merge sort.
Combine: Merge the two sorted subsequences to produce the sorted answer.
The recursion “bottoms out” when the sequence to be sorted has length 1, in which
case there is no work to be done, since every sequence of length 1 is already in
sorted order.
The key operation of the merge sort algorithm is the merging of two sorted
sequences in the “combine” step. We merge by calling an auxiliary procedure
M ERGE .A; p; q; r/, where A is an array and p, q, and r are indices into the array
such that p  q < r. The procedure assumes that the subarrays AŒp : : q and
AŒq C 1 : : r are in sorted order. It merges them to form a single sorted subarray
that replaces the current subarray AŒp : : r.
Our M ERGE procedure takes time ‚.n/, where n D r  p C 1 is the total
number of elements being merged, and it works as follows. Returning to our cardplaying motif, suppose we have two piles of cards face up on a table. Each pile is
sorted, with the smallest cards on top. We wish to merge the two piles into a single
sorted output pile, which is to be face down on the table. Our basic step consists
of choosing the smaller of the two cards on top of the face-up piles, removing it
from its pile (which exposes a new top card), and placing this card face down onto

2.3 Designing algorithms

31

the output pile. We repeat this step until one input pile is empty, at which time
we just take the remaining input pile and place it face down onto the output pile.
Computationally, each basic step takes constant time, since we are comparing just
the two top cards. Since we perform at most n basic steps, merging takes ‚.n/
time.
The following pseudocode implements the above idea, but with an additional
twist that avoids having to check whether either pile is empty in each basic step.
We place on the bottom of each pile a sentinel card, which contains a special value
that we use to simplify our code. Here, we use 1 as the sentinel value, so that
whenever a card with 1 is exposed, it cannot be the smaller card unless both piles
have their sentinel cards exposed. But once that happens, all the nonsentinel cards
have already been placed onto the output pile. Since we know in advance that
exactly r  p C 1 cards will be placed onto the output pile, we can stop once we
have performed that many basic steps.
M ERGE .A; p; q; r/
1 n1 D q  p C 1
2 n2 D r  q
3 let LŒ1 : : n1 C 1 and RŒ1 : : n2 C 1 be new arrays
4 for i D 1 to n1
5
LŒi D AŒp C i  1
6 for j D 1 to n2
7
RŒj  D AŒq C j 
8 LŒn1 C 1 D 1
9 RŒn2 C 1 D 1
10 i D 1
11 j D 1
12 for k D p to r
13
if LŒi  RŒj 
14
AŒk D LŒi
15
i D i C1
16
else AŒk D RŒj 
17
j D j C1
In detail, the M ERGE procedure works as follows. Line 1 computes the length n1
of the subarray AŒp : : q, and line 2 computes the length n2 of the subarray
AŒq C 1 : : r. We create arrays L and R (“left” and “right”), of lengths n1 C 1
and n2 C 1, respectively, in line 3; the extra position in each array will hold the
sentinel. The for loop of lines 4–5 copies the subarray AŒp : : q into LŒ1 : : n1 ,
and the for loop of lines 6–7 copies the subarray AŒq C 1 : : r into RŒ1 : : n2 .
Lines 8–9 put the sentinels at the ends of the arrays L and R. Lines 10–17, illus-

32

Chapter 2 Getting Started

8

9

A … 2
k
L

10 11 12 13 14 15 16 17

4

5

7

1

2

3

8

6 …

9

A … 1

1

2

3

4

5

1

2

3

4

2
i

4

5

7 ∞

R 1
j

2

3

6 ∞

5

L

10 11 12 13 14 15 16 17

4
k

5

8

9

L

1

2

3

2

4
i

5

5
k

4

5

7 ∞

7

1

3

6 …

2

3

4

5

1

2

3

4

4

5

7 ∞

R 1

2
j

3

6 ∞

5

(b)

2

3

8

6 …

1

2

3

R 1

2
j

3

(c)

2

1

10 11 12 13 14 15 16 17

2

1

2
i

(a)

A … 1

7

4

9

A … 1
5

6 ∞

L

1

2

3

2

4
i

5

10 11 12 13 14 15 16 17

2

2

4

5

7 ∞

7
k

1

2

3

6 …

1

2

3

R 1

2

3
j

4

5

6 ∞

(d)

Figure 2.3 The operation of lines 10–17 in the call M ERGE.A; 9; 12; 16/, when the subarray
AŒ9 : : 16 contains the sequence h2; 4; 5; 7; 1; 2; 3; 6i. After copying and inserting sentinels, the
array L contains h2; 4; 5; 7; 1i, and the array R contains h1; 2; 3; 6; 1i. Lightly shaded positions
in A contain their ﬁnal values, and lightly shaded positions in L and R contain values that have yet
to be copied back into A. Taken together, the lightly shaded positions always comprise the values
originally in AŒ9 : : 16, along with the two sentinels. Heavily shaded positions in A contain values
that will be copied over, and heavily shaded positions in L and R contain values that have already
been copied back into A. (a)–(h) The arrays A, L, and R, and their respective indices k, i, and j
prior to each iteration of the loop of lines 12–17.

trated in Figure 2.3, perform the r  p C 1 basic steps by maintaining the following
loop invariant:
At the start of each iteration of the for loop of lines 12–17, the subarray
AŒp : : k  1 contains the k  p smallest elements of LŒ1 : : n1 C 1 and
RŒ1 : : n2 C 1, in sorted order. Moreover, LŒi and RŒj  are the smallest
elements of their arrays that have not been copied back into A.
We must show that this loop invariant holds prior to the ﬁrst iteration of the for
loop of lines 12–17, that each iteration of the loop maintains the invariant, and
that the invariant provides a useful property to show correctness when the loop
terminates.
Initialization: Prior to the ﬁrst iteration of the loop, we have k D p, so that the
subarray AŒp : : k  1 is empty. This empty subarray contains the k  p D 0
smallest elements of L and R, and since i D j D 1, both LŒi and RŒj  are the
smallest elements of their arrays that have not been copied back into A.

2.3 Designing algorithms

8

9

A … 1

L

33

10 11 12 13 14 15 16 17

2

2

3

1
k

2

3

8

6 …

9

A … 1

1

2

3

4

5

1

2

3

4

2

4
i

5

7 ∞

R 1

2

3

6 ∞
j

5

L

10 11 12 13 14 15 16 17

2

2

3

4

8

9

L

1

2

3

2

4

5

2

4

5

3

7 ∞
i

4

2

3

4

5

1

2

3

4

4

5
i

7 ∞

R 1

2

3

6 ∞
j

8

9

L

5

(f)

5

3
k

8

6 …

1

2

3

R 1

2

3

4

9

A … 1
5

6 ∞
j

(g)

A … 1

6 …

1

10 11 12 13 14 15 16 17

2

3

2

(e)

A … 1

2
k

L

1

2

3

2

4

5

10 11 12 13 14 15 16 17

2

2

4

5

7 ∞
i

3

4

5 6

6 …
k

1

2

3

R 1

2

3

4

5

6 ∞
j

(h)

10 11 12 13 14 15 16 17

2

2

3

4

5 6

7 …
k

1

2

3

4

5

1

2

3

4

2

4

5

7 ∞
i

R 1

2

3

6 ∞
j

5

(i)

Figure 2.3, continued (i) The arrays and indices at termination. At this point, the subarray in
AŒ9 : : 16 is sorted, and the two sentinels in L and R are the only two elements in these arrays that
have not been copied into A.

Maintenance: To see that each iteration maintains the loop invariant, let us ﬁrst
suppose that LŒi  RŒj . Then LŒi is the smallest element not yet copied
back into A. Because AŒp : : k  1 contains the k  p smallest elements, after
line 14 copies LŒi into AŒk, the subarray AŒp : : k will contain the k  p C 1
smallest elements. Incrementing k (in the for loop update) and i (in line 15)
reestablishes the loop invariant for the next iteration. If instead LŒi > RŒj ,
then lines 16–17 perform the appropriate action to maintain the loop invariant.
Termination: At termination, k D r C 1. By the loop invariant, the subarray
AŒp : : k  1, which is AŒp : : r, contains the k  p D r  p C 1 smallest
elements of LŒ1 : : n1 C 1 and RŒ1 : : n2 C 1, in sorted order. The arrays L
and R together contain n1 C n2 C 2 D r  p C 3 elements. All but the two
largest have been copied back into A, and these two largest elements are the
sentinels.

34

Chapter 2 Getting Started

To see that the M ERGE procedure runs in ‚.n/ time, where n D r  p C 1,
observe that each of lines 1–3 and 8–11 takes constant time, the for loops of
lines 4–7 take ‚.n1 C n2 / D ‚.n/ time,7 and there are n iterations of the for
loop of lines 12–17, each of which takes constant time.
We can now use the M ERGE procedure as a subroutine in the merge sort algorithm. The procedure M ERGE -S ORT .A; p; r/ sorts the elements in the subarray AŒp : : r. If p  r, the subarray has at most one element and is therefore
already sorted. Otherwise, the divide step simply computes an index q that partitions AŒp : : r into two subarrays: AŒp : : q, containing dn=2e elements, and
AŒq C 1 : : r, containing bn=2c elements.8
M ERGE -S ORT .A; p; r/
1 if p < r
2
q D b.p C r/=2c
3
M ERGE -S ORT .A; p; q/
4
M ERGE -S ORT .A; q C 1; r/
5
M ERGE .A; p; q; r/
To sort the entire sequence A D hAŒ1; AŒ2; : : : ; AŒni, we make the initial call
M ERGE -S ORT .A; 1; A:length/, where once again A:length D n. Figure 2.4 illustrates the operation of the procedure bottom-up when n is a power of 2. The
algorithm consists of merging pairs of 1-item sequences to form sorted sequences
of length 2, merging pairs of sequences of length 2 to form sorted sequences of
length 4, and so on, until two sequences of length n=2 are merged to form the ﬁnal
sorted sequence of length n.
2.3.2

Analyzing divide-and-conquer algorithms

When an algorithm contains a recursive call to itself, we can often describe its
running time by a recurrence equation or recurrence, which describes the overall
running time on a problem of size n in terms of the running time on smaller inputs.
We can then use mathematical tools to solve the recurrence and provide bounds on
the performance of the algorithm.

7 We

shall see in Chapter 3 how to formally interpret equations containing ‚-notation.

8 The expression dxe denotes the least integer greater than or equal to x, and bxc denotes the greatest
integer less than or equal to x. These notations are deﬁned in Chapter 3. The easiest way to verify
that setting q to b.p C r/=2c yields subarrays AŒp : : q and AŒq C 1 : : r of sizes dn=2e and bn=2c,
respectively, is to examine the four cases that arise depending on whether each of p and r is odd or
even.

2.3 Designing algorithms

35

sorted sequence
1

2

2

3

4

5

6

7

1

2

3

merge
2

4

5

7

merge
2

merge

5

4

merge
5

7

1

merge
2

6

4

3

2

merge
7

1

6
merge

3

2

6

initial sequence

Figure 2.4 The operation of merge sort on the array A D h5; 2; 4; 7; 1; 3; 2; 6i. The lengths of the
sorted sequences being merged increase as the algorithm progresses from bottom to top.

A recurrence for the running time of a divide-and-conquer algorithm falls out
from the three steps of the basic paradigm. As before, we let T .n/ be the running
time on a problem of size n. If the problem size is small enough, say n  c
for some constant c, the straightforward solution takes constant time, which we
write as ‚.1/. Suppose that our division of the problem yields a subproblems,
each of which is 1=b the size of the original. (For merge sort, both a and b are 2,
but we shall see many divide-and-conquer algorithms in which a ¤ b.) It takes
time T .n=b/ to solve one subproblem of size n=b, and so it takes time aT .n=b/
to solve a of them. If we take D.n/ time to divide the problem into subproblems
and C.n/ time to combine the solutions to the subproblems into the solution to the
original problem, we get the recurrence
(
‚.1/
if n  c ;
T .n/ D
aT .n=b/ C D.n/ C C.n/ otherwise :
In Chapter 4, we shall see how to solve common recurrences of this form.
Analysis of merge sort
Although the pseudocode for M ERGE -S ORT works correctly when the number of
elements is not even, our recurrence-based analysis is simpliﬁed if we assume that

36

Chapter 2 Getting Started

the original problem size is a power of 2. Each divide step then yields two subsequences of size exactly n=2. In Chapter 4, we shall see that this assumption does
not affect the order of growth of the solution to the recurrence.
We reason as follows to set up the recurrence for T .n/, the worst-case running
time of merge sort on n numbers. Merge sort on just one element takes constant
time. When we have n > 1 elements, we break down the running time as follows.
Divide: The divide step just computes the middle of the subarray, which takes
constant time. Thus, D.n/ D ‚.1/.
Conquer: We recursively solve two subproblems, each of size n=2, which contributes 2T .n=2/ to the running time.
Combine: We have already noted that the M ERGE procedure on an n-element
subarray takes time ‚.n/, and so C.n/ D ‚.n/.
When we add the functions D.n/ and C.n/ for the merge sort analysis, we are
adding a function that is ‚.n/ and a function that is ‚.1/. This sum is a linear
function of n, that is, ‚.n/. Adding it to the 2T .n=2/ term from the “conquer”
step gives the recurrence for the worst-case running time T .n/ of merge sort:
(
‚.1/
if n D 1 ;
T .n/ D
(2.1)
2T .n=2/ C ‚.n/ if n > 1 :
In Chapter 4, we shall see the “master theorem,” which we can use to show
that T .n/ is ‚.n lg n/, where lg n stands for log2 n. Because the logarithm function grows more slowly than any linear function, for large enough inputs, merge
sort, with its ‚.n lg n/ running time, outperforms insertion sort, whose running
time is ‚.n2 /, in the worst case.
We do not need the master theorem to intuitively understand why the solution to
the recurrence (2.1) is T .n/ D ‚.n lg n/. Let us rewrite recurrence (2.1) as
(
c
if n D 1 ;
T .n/ D
(2.2)
2T .n=2/ C cn if n > 1 ;
where the constant c represents the time required to solve problems of size 1 as
well as the time per array element of the divide and combine steps.9

9 It is unlikely that the same constant exactly represents both the time to solve problems of size 1
and the time per array element of the divide and combine steps. We can get around this problem by
letting c be the larger of these times and understanding that our recurrence gives an upper bound on
the running time, or by letting c be the lesser of these times and understanding that our recurrence
gives a lower bound on the running time. Both bounds are on the order of n lg n and, taken together,
give a ‚.n lg n/ running time.

2.3 Designing algorithms

37

Figure 2.5 shows how we can solve recurrence (2.2). For convenience, we assume that n is an exact power of 2. Part (a) of the ﬁgure shows T .n/, which we
expand in part (b) into an equivalent tree representing the recurrence. The cn term
is the root (the cost incurred at the top level of recursion), and the two subtrees of
the root are the two smaller recurrences T .n=2/. Part (c) shows this process carried
one step further by expanding T .n=2/. The cost incurred at each of the two subnodes at the second level of recursion is cn=2. We continue expanding each node
in the tree by breaking it into its constituent parts as determined by the recurrence,
until the problem sizes get down to 1, each with a cost of c. Part (d) shows the
resulting recursion tree.
Next, we add the costs across each level of the tree. The top level has total
cost cn, the next level down has total cost c.n=2/ C c.n=2/ D cn, the level after
that has total cost c.n=4/Cc.n=4/ Cc.n=4/Cc.n=4/ D cn, and so on. In general,
the level i below the top has 2i nodes, each contributing a cost of c.n=2i /, so that
the ith level below the top has total cost 2i c.n=2i / D cn. The bottom level has n
nodes, each contributing a cost of c, for a total cost of cn.
The total number of levels of the recursion tree in Figure 2.5 is lg n C 1, where
n is the number of leaves, corresponding to the input size. An informal inductive
argument justiﬁes this claim. The base case occurs when n D 1, in which case the
tree has only one level. Since lg 1 D 0, we have that lg n C 1 gives the correct
number of levels. Now assume as an inductive hypothesis that the number of levels
of a recursion tree with 2i leaves is lg 2i C 1 D i C 1 (since for any value of i,
we have that lg 2i D i). Because we are assuming that the input size is a power
of 2, the next input size to consider is 2i C1 . A tree with n D 2i C1 leaves has
one more level than a tree with 2i leaves, and so the total number of levels is
.i C 1/ C 1 D lg 2i C1 C 1.
To compute the total cost represented by the recurrence (2.2), we simply add up
the costs of all the levels. The recursion tree has lg n C 1 levels, each costing cn,
for a total cost of cn.lg n C 1/ D cn lg n C cn. Ignoring the low-order term and
the constant c gives the desired result of ‚.n lg n/.
Exercises
2.3-1
Using Figure 2.4 as a model, illustrate the operation of merge sort on the array
A D h3; 41; 52; 26; 38; 57; 9; 49i.
2.3-2
Rewrite the M ERGE procedure so that it does not use sentinels, instead stopping
once either array L or R has had all its elements copied back to A and then copying
the remainder of the other array back into A.

Chapter 2 Getting Started

T(n)

cn

T(n/2)

cn

T(n/2)

cn/2

T(n/4)
(a)

cn/2

T(n/4)

(b)

T(n/4)

T(n/4)

(c)

cn

cn

cn/2

cn/2

cn

lg n
cn/4

cn/4

cn/4

cn/4

cn

…

38

c

c

c

c

c

…

c

c

cn

n
(d)

Total: cn lg n + cn

Figure 2.5 How to construct a recursion tree for the recurrence T .n/ D 2T .n=2/ C cn.
Part (a) shows T .n/, which progressively expands in (b)–(d) to form the recursion tree. The fully
expanded tree in part (d) has lg n C 1 levels (i.e., it has height lg n, as indicated), and each level
contributes a total cost of cn. The total cost, therefore, is cn lg n C cn, which is ‚.n lg n/.

Problems for Chapter 2

39

2.3-3
Use mathematical induction to show that when n is an exact power of 2, the solution of the recurrence
(
2
if n D 2 ;
T .n/ D
2T .n=2/ C n if n D 2k , for k > 1
is T .n/ D n lg n.
2.3-4
We can express insertion sort as a recursive procedure as follows. In order to sort
AŒ1 : : n, we recursively sort AŒ1 : : n  1 and then insert AŒn into the sorted array
AŒ1 : : n  1. Write a recurrence for the running time of this recursive version of
insertion sort.
2.3-5
Referring back to the searching problem (see Exercise 2.1-3), observe that if the
sequence A is sorted, we can check the midpoint of the sequence against  and
eliminate half of the sequence from further consideration. The binary search algorithm repeats this procedure, halving the size of the remaining portion of the
sequence each time. Write pseudocode, either iterative or recursive, for binary
search. Argue that the worst-case running time of binary search is ‚.lg n/.
2.3-6
Observe that the while loop of lines 5–7 of the I NSERTION -S ORT procedure in
Section 2.1 uses a linear search to scan (backward) through the sorted subarray
AŒ1 : : j  1. Can we use a binary search (see Exercise 2.3-5) instead to improve
the overall worst-case running time of insertion sort to ‚.n lg n/?
2.3-7 ?
Describe a ‚.n lg n/-time algorithm that, given a set S of n integers and another
integer x, determines whether or not there exist two elements in S whose sum is
exactly x.

Problems
2-1 Insertion sort on small arrays in merge sort
Although merge sort runs in ‚.n lg n/ worst-case time and insertion sort runs
in ‚.n2 / worst-case time, the constant factors in insertion sort can make it faster
in practice for small problem sizes on many machines. Thus, it makes sense to
coarsen the leaves of the recursion by using insertion sort within merge sort when

40

Chapter 2 Getting Started

subproblems become sufﬁciently small. Consider a modiﬁcation to merge sort in
which n=k sublists of length k are sorted using insertion sort and then merged
using the standard merging mechanism, where k is a value to be determined.
a. Show that insertion sort can sort the n=k sublists, each of length k, in ‚.nk/
worst-case time.
b. Show how to merge the sublists in ‚.n lg.n=k// worst-case time.
c. Given that the modiﬁed algorithm runs in ‚.nk C n lg.n=k// worst-case time,
what is the largest value of k as a function of n for which the modiﬁed algorithm
has the same running time as standard merge sort, in terms of ‚-notation?
d. How should we choose k in practice?
2-2 Correctness of bubblesort
Bubblesort is a popular, but inefﬁcient, sorting algorithm. It works by repeatedly
swapping adjacent elements that are out of order.
B UBBLESORT .A/
1 for i D 1 to A:length  1
2
for j D A:length downto i C 1
3
if AŒj  < AŒj  1
4
exchange AŒj  with AŒj  1
a. Let A0 denote the output of B UBBLESORT .A/. To prove that B UBBLESORT is
correct, we need to prove that it terminates and that
A0 Œ1  A0 Œ2      A0 Œn ;

(2.3)

where n D A:length. In order to show that B UBBLESORT actually sorts, what
else do we need to prove?
The next two parts will prove inequality (2.3).
b. State precisely a loop invariant for the for loop in lines 2–4, and prove that this
loop invariant holds. Your proof should use the structure of the loop invariant
proof presented in this chapter.
c. Using the termination condition of the loop invariant proved in part (b), state
a loop invariant for the for loop in lines 1–4 that will allow you to prove inequality (2.3). Your proof should use the structure of the loop invariant proof
presented in this chapter.

Problems for Chapter 2

41

d. What is the worst-case running time of bubblesort? How does it compare to the
running time of insertion sort?
2-3 Correctness of Horner’s rule
The following code fragment implements Horner’s rule for evaluating a polynomial
P .x/ D

n
X

ak x k

kD0

D a0 C x.a1 C x.a2 C    C x.an1 C xan /   // ;
given the coefﬁcients a0 ; a1 ; : : : ; an and a value for x:
1 y D0
2 for i D n downto 0
3
y D ai C x  y
a. In terms of ‚-notation, what is the running time of this code fragment for
Horner’s rule?
b. Write pseudocode to implement the naive polynomial-evaluation algorithm that
computes each term of the polynomial from scratch. What is the running time
of this algorithm? How does it compare to Horner’s rule?
c. Consider the following loop invariant:
At the start of each iteration of the for loop of lines 2–3,
X

n.i C1/

yD

akCi C1 x k :

kD0

Interpret a summation with no terms as equaling 0. Following the structure of
the loop invariant proof presented
in this chapter, use this loop invariant to show
Pn
that, at termination, y D kD0 ak x k .
d. Conclude by arguing that the given code fragment correctly evaluates a polynomial characterized by the coefﬁcients a0 ; a1 ; : : : ; an .
2-4 Inversions
Let AŒ1 : : n be an array of n distinct numbers. If i < j and AŒi > AŒj , then the
pair .i; j / is called an inversion of A.
a. List the ﬁve inversions of the array h2; 3; 8; 6; 1i.

42

Chapter 2 Getting Started

b. What array with elements from the set f1; 2; : : : ; ng has the most inversions?
How many does it have?
c. What is the relationship between the running time of insertion sort and the
number of inversions in the input array? Justify your answer.
d. Give an algorithm that determines the number of inversions in any permutation
on n elements in ‚.n lg n/ worst-case time. (Hint: Modify merge sort.)

Chapter notes
In 1968, Knuth published the ﬁrst of three volumes with the general title The Art of
Computer Programming [209, 210, 211]. The ﬁrst volume ushered in the modern
study of computer algorithms with a focus on the analysis of running time, and the
full series remains an engaging and worthwhile reference for many of the topics
presented here. According to Knuth, the word “algorithm” is derived from the
name “al-Khowârizmı̂,” a ninth-century Persian mathematician.
Aho, Hopcroft, and Ullman [5] advocated the asymptotic analysis of algorithms—using notations that Chapter 3 introduces, including ‚-notation—as a
means of comparing relative performance. They also popularized the use of recurrence relations to describe the running times of recursive algorithms.
Knuth [211] provides an encyclopedic treatment of many sorting algorithms. His
comparison of sorting algorithms (page 381) includes exact step-counting analyses,
like the one we performed here for insertion sort. Knuth’s discussion of insertion
sort encompasses several variations of the algorithm. The most important of these
is Shell’s sort, introduced by D. L. Shell, which uses insertion sort on periodic
subsequences of the input to produce a faster sorting algorithm.
Merge sort is also described by Knuth. He mentions that a mechanical collator capable of merging two decks of punched cards in a single pass was invented
in 1938. J. von Neumann, one of the pioneers of computer science, apparently
wrote a program for merge sort on the EDVAC computer in 1945.
The early history of proving programs correct is described by Gries [153], who
credits P. Naur with the ﬁrst article in this ﬁeld. Gries attributes loop invariants to
R. W. Floyd. The textbook by Mitchell [256] describes more recent progress in
proving programs correct.

3

Growth of Functions

The order of growth of the running time of an algorithm, deﬁned in Chapter 2,
gives a simple characterization of the algorithm’s efﬁciency and also allows us to
compare the relative performance of alternative algorithms. Once the input size n
becomes large enough, merge sort, with its ‚.n lg n/ worst-case running time,
beats insertion sort, whose worst-case running time is ‚.n2 /. Although we can
sometimes determine the exact running time of an algorithm, as we did for insertion
sort in Chapter 2, the extra precision is not usually worth the effort of computing
it. For large enough inputs, the multiplicative constants and lower-order terms of
an exact running time are dominated by the effects of the input size itself.
When we look at input sizes large enough to make only the order of growth of
the running time relevant, we are studying the asymptotic efﬁciency of algorithms.
That is, we are concerned with how the running time of an algorithm increases with
the size of the input in the limit, as the size of the input increases without bound.
Usually, an algorithm that is asymptotically more efﬁcient will be the best choice
for all but very small inputs.
This chapter gives several standard methods for simplifying the asymptotic analysis of algorithms. The next section begins by deﬁning several types of “asymptotic notation,” of which we have already seen an example in ‚-notation. We then
present several notational conventions used throughout this book, and ﬁnally we
review the behavior of functions that commonly arise in the analysis of algorithms.

3.1 Asymptotic notation
The notations we use to describe the asymptotic running time of an algorithm
are deﬁned in terms of functions whose domains are the set of natural numbers
N D f0; 1; 2; : : :g. Such notations are convenient for describing the worst-case
running-time function T .n/, which usually is deﬁned only on integer input sizes.
We sometimes ﬁnd it convenient, however, to abuse asymptotic notation in a va-

44

Chapter 3 Growth of Functions

riety of ways. For example, we might extend the notation to the domain of real
numbers or, alternatively, restrict it to a subset of the natural numbers. We should
make sure, however, to understand the precise meaning of the notation so that when
we abuse, we do not misuse it. This section deﬁnes the basic asymptotic notations
and also introduces some common abuses.
Asymptotic notation, functions, and running times
We will use asymptotic notation primarily to describe the running times of algorithms, as when we wrote that insertion sort’s worst-case running time is ‚.n2 /.
Asymptotic notation actually applies to functions, however. Recall that we characterized insertion sort’s worst-case running time as an2 CbnCc, for some constants
a, b, and c. By writing that insertion sort’s running time is ‚.n2 /, we abstracted
away some details of this function. Because asymptotic notation applies to functions, what we were writing as ‚.n2 / was the function an2 C bn C c, which in
that case happened to characterize the worst-case running time of insertion sort.
In this book, the functions to which we apply asymptotic notation will usually
characterize the running times of algorithms. But asymptotic notation can apply to
functions that characterize some other aspect of algorithms (the amount of space
they use, for example), or even to functions that have nothing whatsoever to do
with algorithms.
Even when we use asymptotic notation to apply to the running time of an algorithm, we need to understand which running time we mean. Sometimes we are
interested in the worst-case running time. Often, however, we wish to characterize
the running time no matter what the input. In other words, we often wish to make
a blanket statement that covers all inputs, not just the worst case. We shall see
asymptotic notations that are well suited to characterizing running times no matter
what the input.
‚-notation
In Chapter 2, we found that the worst-case running time of insertion sort is
T .n/ D ‚.n2 /. Let us deﬁne what this notation means. For a given function g.n/,
we denote by ‚.g.n// the set of functions
‚.g.n// D ff .n/ W there exist positive constants c1 , c2 , and n0 such that
0  c1 g.n/  f .n/  c2 g.n/ for all n  n0 g :1

1 Within

set notation, a colon means “such that.”

3.1 Asymptotic notation

45

c2 g.n/

cg.n/
f .n/

f .n/

f .n/
cg.n/

c1 g.n/

n0

n
f .n/ D ‚.g.n//
(a)

n0

n
f .n/ D O.g.n//
(b)

n0

n
f .n/ D .g.n//
(c)

Figure 3.1 Graphic examples of the ‚, O, and  notations. In each part, the value of n0 shown
is the minimum possible value; any greater value would also work. (a) ‚-notation bounds a function to within constant factors. We write f .n/ D ‚.g.n// if there exist positive constants n0 , c1 ,
and c2 such that at and to the right of n0 , the value of f .n/ always lies between c1 g.n/ and c2 g.n/
inclusive. (b) O-notation gives an upper bound for a function to within a constant factor. We write
f .n/ D O.g.n// if there are positive constants n0 and c such that at and to the right of n0 , the value
of f .n/ always lies on or below cg.n/. (c) -notation gives a lower bound for a function to within
a constant factor. We write f .n/ D .g.n// if there are positive constants n0 and c such that at and
to the right of n0 , the value of f .n/ always lies on or above cg.n/.

A function f .n/ belongs to the set ‚.g.n// if there exist positive constants c1
and c2 such that it can be “sandwiched” between c1 g.n/ and c2 g.n/, for sufﬁciently large n. Because ‚.g.n// is a set, we could write “f .n/ 2 ‚.g.n//”
to indicate that f .n/ is a member of ‚.g.n//. Instead, we will usually write
“f .n/ D ‚.g.n//” to express the same notion. You might be confused because
we abuse equality in this way, but we shall see later in this section that doing so
has its advantages.
Figure 3.1(a) gives an intuitive picture of functions f .n/ and g.n/, where
f .n/ D ‚.g.n//. For all values of n at and to the right of n0 , the value of f .n/
lies at or above c1 g.n/ and at or below c2 g.n/. In other words, for all n  n0 , the
function f .n/ is equal to g.n/ to within a constant factor. We say that g.n/ is an
asymptotically tight bound for f .n/.
The deﬁnition of ‚.g.n// requires that every member f .n/ 2 ‚.g.n// be
asymptotically nonnegative, that is, that f .n/ be nonnegative whenever n is sufﬁciently large. (An asymptotically positive function is one that is positive for all
sufﬁciently large n.) Consequently, the function g.n/ itself must be asymptotically
nonnegative, or else the set ‚.g.n// is empty. We shall therefore assume that every
function used within ‚-notation is asymptotically nonnegative. This assumption
holds for the other asymptotic notations deﬁned in this chapter as well.

46

Chapter 3 Growth of Functions

In Chapter 2, we introduced an informal notion of ‚-notation that amounted
to throwing away lower-order terms and ignoring the leading coefﬁcient of the
highest-order term. Let us brieﬂy justify this intuition by using the formal deﬁnition to show that 12 n2  3n D ‚.n2 /. To do so, we must determine positive
constants c1 , c2 , and n0 such that
1
c1 n2  n2  3n  c2 n2
2
for all n  n0 . Dividing by n2 yields
1 3
  c2 :
2 n
We can make the right-hand inequality hold for any value of n  1 by choosing any
constant c2  1=2. Likewise, we can make the left-hand inequality hold for any
value of n  7 by choosing any constant c1  1=14. Thus, by choosing c1 D 1=14,
c2 D 1=2, and n0 D 7, we can verify that 12 n2  3n D ‚.n2 /. Certainly, other
choices for the constants exist, but the important thing is that some choice exists.
Note that these constants depend on the function 21 n2  3n; a different function
belonging to ‚.n2 / would usually require different constants.
We can also use the formal deﬁnition to verify that 6n3 ¤ ‚.n2 /. Suppose
for the purpose of contradiction that c2 and n0 exist such that 6n3  c2 n2 for
all n  n0 . But then dividing by n2 yields n  c2 =6, which cannot possibly hold
for arbitrarily large n, since c2 is constant.
Intuitively, the lower-order terms of an asymptotically positive function can be
ignored in determining asymptotically tight bounds because they are insigniﬁcant
for large n. When n is large, even a tiny fraction of the highest-order term sufﬁces to dominate the lower-order terms. Thus, setting c1 to a value that is slightly
smaller than the coefﬁcient of the highest-order term and setting c2 to a value that
is slightly larger permits the inequalities in the deﬁnition of ‚-notation to be satisﬁed. The coefﬁcient of the highest-order term can likewise be ignored, since it
only changes c1 and c2 by a constant factor equal to the coefﬁcient.
As an example, consider any quadratic function f .n/ D an2 C bn C c, where
a, b, and c are constants and a > 0. Throwing away the lower-order terms and
ignoring the constant yields f .n/ D ‚.n2 /. Formally, to show the same
p thing, we
take the constants c1 D a=4, c2 D 7a=4, and n0 D 2  max.jbj =a; jcj =a/. You
may verify that 0  c1 n2  an2 C bn C c  c2 n2 for all n  n0 . In general,
Pd
for any polynomial p.n/ D i D0 ai ni , where the ai are constants and ad > 0, we
have p.n/ D ‚.nd / (see Problem 3-1).
Since any constant is a degree-0 polynomial, we can express any constant function as ‚.n0 /, or ‚.1/. This latter notation is a minor abuse, however, because the
c1 

3.1 Asymptotic notation

47

expression does not indicate what variable is tending to inﬁnity.2 We shall often
use the notation ‚.1/ to mean either a constant or a constant function with respect
to some variable.
O-notation
The ‚-notation asymptotically bounds a function from above and below. When
we have only an asymptotic upper bound, we use O-notation. For a given function g.n/, we denote by O.g.n// (pronounced “big-oh of g of n” or sometimes
just “oh of g of n”) the set of functions
O.g.n// D ff .n/ W there exist positive constants c and n0 such that
0  f .n/  cg.n/ for all n  n0 g :
We use O-notation to give an upper bound on a function, to within a constant
factor. Figure 3.1(b) shows the intuition behind O-notation. For all values n at and
to the right of n0 , the value of the function f .n/ is on or below cg.n/.
We write f .n/ D O.g.n// to indicate that a function f .n/ is a member of the
set O.g.n//. Note that f .n/ D ‚.g.n// implies f .n/ D O.g.n//, since ‚notation is a stronger notion than O-notation. Written set-theoretically, we have
‚.g.n//  O.g.n//. Thus, our proof that any quadratic function an2 C bn C c,
where a > 0, is in ‚.n2 / also shows that any such quadratic function is in O.n2 /.
What may be more surprising is that when a > 0, any linear function an C b is
in O.n2 /, which is easily veriﬁed by taking c D a C jbj and n0 D max.1; b=a/.
If you have seen O-notation before, you might ﬁnd it strange that we should
write, for example, n D O.n2 /. In the literature, we sometimes ﬁnd O-notation
informally describing asymptotically tight bounds, that is, what we have deﬁned
using ‚-notation. In this book, however, when we write f .n/ D O.g.n//, we
are merely claiming that some constant multiple of g.n/ is an asymptotic upper
bound on f .n/, with no claim about how tight an upper bound it is. Distinguishing asymptotic upper bounds from asymptotically tight bounds is standard in the
algorithms literature.
Using O-notation, we can often describe the running time of an algorithm
merely by inspecting the algorithm’s overall structure. For example, the doubly
nested loop structure of the insertion sort algorithm from Chapter 2 immediately
yields an O.n2 / upper bound on the worst-case running time: the cost of each iteration of the inner loop is bounded from above by O.1/ (constant), the indices i

2 The

real problem is that our ordinary notation for functions does not distinguish functions from
values. In -calculus, the parameters to a function are clearly speciﬁed: the function n2 could be
written as n:n2 , or even r:r 2 . Adopting a more rigorous notation, however, would complicate
algebraic manipulations, and so we choose to tolerate the abuse.

48

Chapter 3 Growth of Functions

and j are both at most n, and the inner loop is executed at most once for each of
the n2 pairs of values for i and j .
Since O-notation describes an upper bound, when we use it to bound the worstcase running time of an algorithm, we have a bound on the running time of the algorithm on every input—the blanket statement we discussed earlier. Thus, the O.n2 /
bound on worst-case running time of insertion sort also applies to its running time
on every input. The ‚.n2 / bound on the worst-case running time of insertion sort,
however, does not imply a ‚.n2 / bound on the running time of insertion sort on
every input. For example, we saw in Chapter 2 that when the input is already
sorted, insertion sort runs in ‚.n/ time.
Technically, it is an abuse to say that the running time of insertion sort is O.n2 /,
since for a given n, the actual running time varies, depending on the particular
input of size n. When we say “the running time is O.n2 /,” we mean that there is a
function f .n/ that is O.n2 / such that for any value of n, no matter what particular
input of size n is chosen, the running time on that input is bounded from above by
the value f .n/. Equivalently, we mean that the worst-case running time is O.n2 /.
-notation
Just as O-notation provides an asymptotic upper bound on a function, -notation
provides an asymptotic lower bound. For a given function g.n/, we denote
by .g.n// (pronounced “big-omega of g of n” or sometimes just “omega of g
of n”) the set of functions
.g.n// D ff .n/ W there exist positive constants c and n0 such that
0  cg.n/  f .n/ for all n  n0 g :
Figure 3.1(c) shows the intuition behind -notation. For all values n at or to the
right of n0 , the value of f .n/ is on or above cg.n/.
From the deﬁnitions of the asymptotic notations we have seen thus far, it is easy
to prove the following important theorem (see Exercise 3.1-5).
Theorem 3.1
For any two functions f .n/ and g.n/, we have f .n/ D ‚.g.n// if and only if
f .n/ D O.g.n// and f .n/ D .g.n//.
As an example of the application of this theorem, our proof that an2 C bn C c D
‚.n2 / for any constants a, b, and c, where a > 0, immediately implies that
an2 C bn C c D .n2 / and an2 C bn C c D O.n2 /. In practice, rather than using
Theorem 3.1 to obtain asymptotic upper and lower bounds from asymptotically
tight bounds, as we did for this example, we usually use it to prove asymptotically
tight bounds from asymptotic upper and lower bounds.

3.1 Asymptotic notation

49

When we say that the running time (no modiﬁer) of an algorithm is .g.n//,
we mean that no matter what particular input of size n is chosen for each value
of n, the running time on that input is at least a constant times g.n/, for sufﬁciently
large n. Equivalently, we are giving a lower bound on the best-case running time
of an algorithm. For example, the best-case running time of insertion sort is .n/,
which implies that the running time of insertion sort is .n/.
The running time of insertion sort therefore belongs to both .n/ and O.n2 /,
since it falls anywhere between a linear function of n and a quadratic function of n.
Moreover, these bounds are asymptotically as tight as possible: for instance, the
running time of insertion sort is not .n2 /, since there exists an input for which
insertion sort runs in ‚.n/ time (e.g., when the input is already sorted). It is not
contradictory, however, to say that the worst-case running time of insertion sort
is .n2 /, since there exists an input that causes the algorithm to take .n2 / time.
Asymptotic notation in equations and inequalities
We have already seen how asymptotic notation can be used within mathematical
formulas. For example, in introducing O-notation, we wrote “n D O.n2 /.” We
might also write 2n2 C 3n C 1 D 2n2 C ‚.n/. How do we interpret such formulas?
When the asymptotic notation stands alone (that is, not within a larger formula)
on the right-hand side of an equation (or inequality), as in n D O.n2 /, we have
already deﬁned the equal sign to mean set membership: n 2 O.n2 /. In general,
however, when asymptotic notation appears in a formula, we interpret it as standing for some anonymous function that we do not care to name. For example, the
formula 2n2 C 3n C 1 D 2n2 C ‚.n/ means that 2n2 C 3n C 1 D 2n2 C f .n/,
where f .n/ is some function in the set ‚.n/. In this case, we let f .n/ D 3n C 1,
which indeed is in ‚.n/.
Using asymptotic notation in this manner can help eliminate inessential detail
and clutter in an equation. For example, in Chapter 2 we expressed the worst-case
running time of merge sort as the recurrence
T .n/ D 2T .n=2/ C ‚.n/ :
If we are interested only in the asymptotic behavior of T .n/, there is no point in
specifying all the lower-order terms exactly; they are all understood to be included
in the anonymous function denoted by the term ‚.n/.
The number of anonymous functions in an expression is understood to be equal
to the number of times the asymptotic notation appears. For example, in the expression
n
X
i D1

O.i/ ;

50

Chapter 3 Growth of Functions

there is only a single anonymous function (a function of i). This expression is thus
not the same as O.1/ C O.2/ C    C O.n/, which doesn’t really have a clean
interpretation.
In some cases, asymptotic notation appears on the left-hand side of an equation,
as in
2n2 C ‚.n/ D ‚.n2 / :
We interpret such equations using the following rule: No matter how the anonymous functions are chosen on the left of the equal sign, there is a way to choose
the anonymous functions on the right of the equal sign to make the equation valid.
Thus, our example means that for any function f .n/ 2 ‚.n/, there is some function g.n/ 2 ‚.n2 / such that 2n2 C f .n/ D g.n/ for all n. In other words, the
right-hand side of an equation provides a coarser level of detail than the left-hand
side.
We can chain together a number of such relationships, as in
2n2 C 3n C 1 D 2n2 C ‚.n/
D ‚.n2 / :
We can interpret each equation separately by the rules above. The ﬁrst equation says that there is some function f .n/ 2 ‚.n/ such that 2n2 C 3n C 1 D
2n2 C f .n/ for all n. The second equation says that for any function g.n/ 2 ‚.n/
(such as the f .n/ just mentioned), there is some function h.n/ 2 ‚.n2 / such
that 2n2 C g.n/ D h.n/ for all n. Note that this interpretation implies that
2n2 C 3n C 1 D ‚.n2 /, which is what the chaining of equations intuitively gives
us.
o-notation
The asymptotic upper bound provided by O-notation may or may not be asymptotically tight. The bound 2n2 D O.n2 / is asymptotically tight, but the bound
2n D O.n2 / is not. We use o-notation to denote an upper bound that is not asymptotically tight. We formally deﬁne o.g.n// (“little-oh of g of n”) as the set
o.g.n// D ff .n/ W for any positive constant c > 0, there exists a constant
n0 > 0 such that 0  f .n/ < cg.n/ for all n  n0 g :
For example, 2n D o.n2 /, but 2n2 ¤ o.n2 /.
The deﬁnitions of O-notation and o-notation are similar. The main difference
is that in f .n/ D O.g.n//, the bound 0  f .n/  cg.n/ holds for some constant c > 0, but in f .n/ D o.g.n//, the bound 0  f .n/ < cg.n/ holds for all
constants c > 0. Intuitively, in o-notation, the function f .n/ becomes insigniﬁcant
relative to g.n/ as n approaches inﬁnity; that is,

3.1 Asymptotic notation

51

f .n/
D0:
(3.1)
n!1 g.n/
Some authors use this limit as a deﬁnition of the o-notation; the deﬁnition in this
book also restricts the anonymous functions to be asymptotically nonnegative.
lim

!-notation
By analogy, !-notation is to -notation as o-notation is to O-notation. We use
!-notation to denote a lower bound that is not asymptotically tight. One way to
deﬁne it is by
f .n/ 2 !.g.n// if and only if g.n/ 2 o.f .n// :
Formally, however, we deﬁne !.g.n// (“little-omega of g of n”) as the set
!.g.n// D ff .n/ W for any positive constant c > 0, there exists a constant
n0 > 0 such that 0  cg.n/ < f .n/ for all n  n0 g :
For example, n2 =2 D !.n/, but n2 =2 ¤ !.n2 /. The relation f .n/ D !.g.n//
implies that
f .n/
D1;
n!1 g.n/
if the limit exists. That is, f .n/ becomes arbitrarily large relative to g.n/ as n
approaches inﬁnity.
lim

Comparing functions
Many of the relational properties of real numbers apply to asymptotic comparisons
as well. For the following, assume that f .n/ and g.n/ are asymptotically positive.
Transitivity:
f .n/ D ‚.g.n// and g.n/ D ‚.h.n//

imply

f .n/ D ‚.h.n// ;

f .n/ D O.g.n// and g.n/ D O.h.n//

imply

f .n/ D O.h.n// ;

f .n/ D .g.n// and g.n/ D .h.n//

imply

f .n/ D .h.n// ;

f .n/ D o.g.n// and g.n/ D o.h.n//

imply

f .n/ D o.h.n// ;

f .n/ D !.g.n// and g.n/ D !.h.n//

imply

f .n/ D !.h.n// :

Reﬂexivity:
f .n/ D ‚.f .n// ;
f .n/ D O.f .n// ;
f .n/ D .f .n// :

52

Chapter 3 Growth of Functions

Symmetry:
f .n/ D ‚.g.n// if and only if g.n/ D ‚.f .n// :
Transpose symmetry:
f .n/ D O.g.n// if and only if g.n/ D .f .n// ;
f .n/ D o.g.n//

if and only if g.n/ D !.f .n// :

Because these properties hold for asymptotic notations, we can draw an analogy
between the asymptotic comparison of two functions f and g and the comparison
of two real numbers a and b:
f .n/ D O.g.n//
f .n/ D .g.n//
f .n/ D ‚.g.n//
f .n/ D o.g.n//
f .n/ D !.g.n//

is like
is like
is like
is like
is like

ab;
ab;
aDb;
a<b;
a>b:

We say that f .n/ is asymptotically smaller than g.n/ if f .n/ D o.g.n//, and f .n/
is asymptotically larger than g.n/ if f .n/ D !.g.n//.
One property of real numbers, however, does not carry over to asymptotic notation:
Trichotomy: For any two real numbers a and b, exactly one of the following must
hold: a < b, a D b, or a > b.
Although any two real numbers can be compared, not all functions are asymptotically comparable. That is, for two functions f .n/ and g.n/, it may be the case
that neither f .n/ D O.g.n// nor f .n/ D .g.n// holds. For example, we cannot
compare the functions n and n1Csin n using asymptotic notation, since the value of
the exponent in n1Csin n oscillates between 0 and 2, taking on all values in between.
Exercises
3.1-1
Let f .n/ and g.n/ be asymptotically nonnegative functions. Using the basic deﬁnition of ‚-notation, prove that max.f .n/; g.n// D ‚.f .n/ C g.n//.
3.1-2
Show that for any real constants a and b, where b > 0,
.n C a/b D ‚.nb / :

(3.2)

3.2 Standard notations and common functions

53

3.1-3
Explain why the statement, “The running time of algorithm A is at least O.n2 /,” is
meaningless.
3.1-4
Is 2nC1 D O.2n /? Is 22n D O.2n /?
3.1-5
Prove Theorem 3.1.
3.1-6
Prove that the running time of an algorithm is ‚.g.n// if and only if its worst-case
running time is O.g.n// and its best-case running time is .g.n//.
3.1-7
Prove that o.g.n// \ !.g.n// is the empty set.
3.1-8
We can extend our notation to the case of two parameters n and m that can go to
inﬁnity independently at different rates. For a given function g.n; m/, we denote
by O.g.n; m// the set of functions
O.g.n; m// D ff .n; m/ W there exist positive constants c, n0 , and m0
such that 0  f .n; m/  cg.n; m/
for all n  n0 or m  m0 g :
Give corresponding deﬁnitions for .g.n; m// and ‚.g.n; m//.

3.2 Standard notations and common functions
This section reviews some standard mathematical functions and notations and explores the relationships among them. It also illustrates the use of the asymptotic
notations.
Monotonicity
A function f .n/ is monotonically increasing if m  n implies f .m/  f .n/.
Similarly, it is monotonically decreasing if m  n implies f .m/  f .n/. A
function f .n/ is strictly increasing if m < n implies f .m/ < f .n/ and strictly
decreasing if m < n implies f .m/ > f .n/.

54

Chapter 3 Growth of Functions

Floors and ceilings
For any real number x, we denote the greatest integer less than or equal to x by bxc
(read “the ﬂoor of x”) and the least integer greater than or equal to x by dxe (read
“the ceiling of x”). For all real x,
x  1 < bxc  x  dxe < x C 1 :

(3.3)

For any integer n,
dn=2e C bn=2c D n ;
and for any real number x  0 and integers a; b > 0,


lx m
dx=ae
D
;
b
ab

jx k
bx=ac
D
;
b
ab
la m
a C .b  1/

;
b
b
ja k
a  .b  1/

:
b
b

(3.4)
(3.5)
(3.6)
(3.7)

The ﬂoor function f .x/ D bxc is monotonically increasing, as is the ceiling function f .x/ D dxe.
Modular arithmetic
For any integer a and any positive integer n, the value a mod n is the remainder
(or residue) of the quotient a=n:
a mod n D a  n ba=nc :

(3.8)

It follows that
0  a mod n < n :

(3.9)

Given a well-deﬁned notion of the remainder of one integer when divided by another, it is convenient to provide special notation to indicate equality of remainders.
If .a mod n/ D .b mod n/, we write a  b .mod n/ and say that a is equivalent
to b, modulo n. In other words, a  b .mod n/ if a and b have the same remainder when divided by n. Equivalently, a  b .mod n/ if and only if n is a divisor
of b  a. We write a 6 b .mod n/ if a is not equivalent to b, modulo n.

3.2 Standard notations and common functions

55

Polynomials
Given a nonnegative integer d , a polynomial in n of degree d is a function p.n/
of the form
p.n/ D

d
X

a i ni ;

i D0

where the constants a0 ; a1 ; : : : ; ad are the coefﬁcients of the polynomial and
ad ¤ 0. A polynomial is asymptotically positive if and only if ad > 0. For an
asymptotically positive polynomial p.n/ of degree d , we have p.n/ D ‚.nd /. For
any real constant a  0, the function na is monotonically increasing, and for any
real constant a  0, the function na is monotonically decreasing. We say that a
function f .n/ is polynomially bounded if f .n/ D O.nk / for some constant k.
Exponentials
For all real a > 0, m, and n, we have the following identities:
a0
a1
a1
.am /n
.am /n
am an

D
D
D
D
D
D

1;
a;
1=a ;
amn ;
.an /m ;
amCn :

For all n and a  1, the function an is monotonically increasing in n. When
convenient, we shall assume 00 D 1.
We can relate the rates of growth of polynomials and exponentials by the following fact. For all real constants a and b such that a > 1,
nb
D0;
n!1 a n
from which we can conclude that
lim

(3.10)

nb D o.an / :
Thus, any exponential function with a base strictly greater than 1 grows faster than
any polynomial function.
Using e to denote 2:71828 : : :, the base of the natural logarithm function, we
have for all real x,
1
X
x3
x2
xi
x
C
C  D
;
(3.11)
e D1CxC
2Š
3Š
iŠ
i D0

56

Chapter 3 Growth of Functions

where “Š” denotes the factorial function deﬁned later in this section. For all real x,
we have the inequality
ex  1 C x ;

(3.12)

where equality holds only when x D 0. When jxj  1, we have the approximation
1 C x  ex  1 C x C x 2 :

(3.13)
x

When x ! 0, the approximation of e by 1 C x is quite good:
e x D 1 C x C ‚.x 2 / :
(In this equation, the asymptotic notation is used to describe the limiting behavior
as x ! 0 rather than as x ! 1.) We have for all x,

x n
D ex :
(3.14)
lim 1 C
n!1
n
Logarithms
We shall use the following notations:
lg n
ln n
lgk n
lg lg n

D
D
D
D

log2 n
loge n
.lg n/k
lg.lg n/

(binary logarithm) ,
(natural logarithm) ,
(exponentiation) ,
(composition) .

An important notational convention we shall adopt is that logarithm functions will
apply only to the next term in the formula, so that lg n C k will mean .lg n/ C k
and not lg.n C k/. If we hold b > 1 constant, then for n > 0, the function logb n
is strictly increasing.
For all real a > 0, b > 0, c > 0, and n,
a D b logb a ;
logc .ab/ D logc a C logc b ;
logb an D n logb a ;
logc a
;
logb a D
logc b
logb .1=a/ D  logb a ;
1
;
logb a D
loga b
alogb c D c logb a ;
where, in each equation above, logarithm bases are not 1.

(3.15)

(3.16)

3.2 Standard notations and common functions

57

By equation (3.15), changing the base of a logarithm from one constant to another changes the value of the logarithm by only a constant factor, and so we shall
often use the notation “lg n” when we don’t care about constant factors, such as in
O-notation. Computer scientists ﬁnd 2 to be the most natural base for logarithms
because so many algorithms and data structures involve splitting a problem into
two parts.
There is a simple series expansion for ln.1 C x/ when jxj < 1:
ln.1 C x/ D x 

x3 x4
x5
x2
C

C
  :
2
3
4
5

We also have the following inequalities for x > 1:
x
 ln.1 C x/  x ;
1Cx

(3.17)

where equality holds only for x D 0.
We say that a function f .n/ is polylogarithmically bounded if f .n/ D O.lgk n/
for some constant k. We can relate the growth of polynomials and polylogarithms
by substituting lg n for n and 2a for a in equation (3.10), yielding
lgb n
lgb n
D
lim
D0:
n!1 .2a /lg n
n!1 na
lim

From this limit, we can conclude that
lgb n D o.na /
for any constant a > 0. Thus, any positive polynomial function grows faster than
any polylogarithmic function.
Factorials
The notation nŠ (read “n factorial”) is deﬁned for integers n  0 as
(
1
if n D 0 ;
nŠ D
n  .n  1/Š if n > 0 :
Thus, nŠ D 1  2  3    n.
A weak upper bound on the factorial function is nŠ  nn , since each of the n
terms in the factorial product is at most n. Stirling’s approximation,
 
 n n 
p
1
;
(3.18)
1C‚
nŠ D 2 n
e
n

58

Chapter 3 Growth of Functions

where e is the base of the natural logarithm, gives us a tighter upper bound, and a
lower bound as well. As Exercise 3.2-3 asks you to prove,
nŠ D o.nn / ;
nŠ D !.2n / ;
lg.nŠ/ D ‚.n lg n/ ;

(3.19)

where Stirling’s approximation is helpful in proving equation (3.19). The following
equation also holds for all n  1:
 n n
p
e ˛n
(3.20)
nŠ D 2 n
e
where
1
1
< ˛n <
:
(3.21)
12n C 1
12n
Functional iteration
We use the notation f .i / .n/ to denote the function f .n/ iteratively applied i times
to an initial value of n. Formally, let f .n/ be a function over the reals. For nonnegative integers i, we recursively deﬁne
(
n
if i D 0 ;
f .i / .n/ D
.i 1/
.n// if i > 0 :
f .f
For example, if f .n/ D 2n, then f .i / .n/ D 2i n.
The iterated logarithm function
We use the notation lg n (read “log star of n”) to denote the iterated logarithm, deﬁned as follows. Let lg.i / n be as deﬁned above, with f .n/ D lg n. Because the logarithm of a nonpositive number is undeﬁned, lg.i / n is deﬁned only if lg.i 1/ n > 0.
Be sure to distinguish lg.i / n (the logarithm function applied i times in succession,
starting with argument n) from lgi n (the logarithm of n raised to the ith power).
Then we deﬁne the iterated logarithm function as
˚
lg n D min i  0 W lg.i / n  1 :
The iterated logarithm is a very slowly growing function:
lg 2
lg 4
lg 16
lg 65536
lg .265536 /

D
D
D
D
D

1;
2;
3;
4;
5:

3.2 Standard notations and common functions

59

Since the number of atoms in the observable universe is estimated to be about 1080 ,
which is much less than 265536 , we rarely encounter an input size n such that
lg n > 5.
Fibonacci numbers
We deﬁne the Fibonacci numbers by the following recurrence:
F0 D 0 ;
F1 D 1 ;
Fi D Fi 1 C Fi 2

(3.22)
for i  2 :

Thus, each Fibonacci number is the sum of the two previous ones, yielding the
sequence
0; 1; 1; 2; 3; 5; 8; 13; 21; 34; 55; : : : :
y which
Fibonacci numbers are related to the golden ratio  and to its conjugate ,
are the two roots of the equation
x2 D x C 1
and are given by the following formulas (see Exercise 3.2-6):
p
1C 5
 D
2
D 1:61803 : : : ;
p
5
1

y D
2
D :61803 : : : :
Speciﬁcally, we have
Fi D

 i  yi
;
p
5

ˇ ˇ
which we can prove by induction (Exercise 3.2-7). Since ˇyˇ < 1, we have
ˇ iˇ
ˇy ˇ
1
< p
p
5
5
1
;
<
2
which implies that

(3.23)

(3.24)

60

Chapter 3 Growth of Functions


Fi D

1
i
p C
2
5

;

(3.25)

p
which is to say that the ith Fibonacci number Fi is equal to  i = 5 rounded to the
nearest integer. Thus, Fibonacci numbers grow exponentially.
Exercises
3.2-1
Show that if f .n/ and g.n/ are monotonically increasing functions, then so are
the functions f .n/ C g.n/ and f .g.n//, and if f .n/ and g.n/ are in addition
nonnegative, then f .n/  g.n/ is monotonically increasing.
3.2-2
Prove equation (3.16).
3.2-3
Prove equation (3.19). Also prove that nŠ D !.2n / and nŠ D o.nn /.
3.2-4 ?
Is the function dlg neŠ polynomially bounded? Is the function dlg lg neŠ polynomially bounded?
3.2-5 ?
Which is asymptotically larger: lg.lg n/ or lg .lg n/?
3.2-6
Show that the golden ratio  and its conjugate y both satisfy the equation
x 2 D x C 1.
3.2-7
Prove by induction that the ith Fibonacci number satisﬁes the equality
Fi D

 i  yi
;
p
5

where  is the golden ratio and y is its conjugate.
3.2-8
Show that k ln k D ‚.n/ implies k D ‚.n= ln n/.

Problems for Chapter 3

61

Problems
3-1 Asymptotic behavior of polynomials
Let
p.n/ D

d
X

a i ni ;

i D0

where ad > 0, be a degree-d polynomial in n, and let k be a constant. Use the
deﬁnitions of the asymptotic notations to prove the following properties.
a. If k  d , then p.n/ D O.nk /.
b. If k  d , then p.n/ D .nk /.
c. If k D d , then p.n/ D ‚.nk /.
d. If k > d , then p.n/ D o.nk /.
e. If k < d , then p.n/ D !.nk /.
3-2 Relative asymptotic growths
Indicate, for each pair of expressions .A; B/ in the table below, whether A is O, o,
, !, or ‚ of B. Assume that k  1,  > 0, and c > 1 are constants. Your answer
should be in the form of the table with “yes” or “no” written in each box.
A
lgk n

B
n
cn

c.

nk
p
n

nsin n

d.

2n

2n=2

e.

nlg c

c lg n

f.

lg.nŠ/

lg.nn /

a.
b.

O

o



!

‚

3-3 Ordering by asymptotic growth rates
a. Rank the following functions by order of growth; that is, ﬁnd an arrangement
g1 ; g2 ; : : : ; g30 of the functions satisfying g1 D .g2 /, g2 D .g3 /, . . . ,
g29 D .g30 /. Partition your list into equivalence classes such that functions
f .n/ and g.n/ are in the same class if and only if f .n/ D ‚.g.n//.

62

Chapter 3 Growth of Functions

lg.lg n/

2lg

n

p
. 2/lg n

n2

nŠ

.lg n/Š

n

n1= lg n

. 32 /n

n3

lg2 n

lg.nŠ/

22

ln ln n

lg n

n  2n

nlg lg n

ln n

2lg n

.lg n/lg n

en

4lg n

n

2n

lg .lg n/

p

2

2 lg n

1
p
.n C 1/Š
lg n
n lg n

nC1

22

b. Give an example of a single nonnegative function f .n/ such that for all functions gi .n/ in part (a), f .n/ is neither O.gi .n// nor .gi .n//.
3-4 Asymptotic notation properties
Let f .n/ and g.n/ be asymptotically positive functions. Prove or disprove each of
the following conjectures.
a. f .n/ D O.g.n// implies g.n/ D O.f .n//.
b. f .n/ C g.n/ D ‚.min.f .n/; g.n///.
c. f .n/ D O.g.n// implies lg.f .n// D O.lg.g.n///, where lg.g.n//  1 and
f .n/  1 for all sufﬁciently large n.
d. f .n/ D O.g.n// implies 2f .n/ D O 2g.n/ .
e. f .n/ D O ..f .n//2 /.
f. f .n/ D O.g.n// implies g.n/ D .f .n//.
g. f .n/ D ‚.f .n=2//.
h. f .n/ C o.f .n// D ‚.f .n//.
3-5 Variations on O and ˝
1
Some authors deﬁne  in a slightly different way than we do; let’s use  (read
1
“omega inﬁnity”) for this alternative deﬁnition. We say that f .n/ D .g.n// if
there exists a positive constant c such that f .n/  cg.n/  0 for inﬁnitely many
integers n.
a. Show that for any two functions f .n/ and g.n/ that are asymptotically nonneg1
ative, either f .n/ D O.g.n// or f .n/ D .g.n// or both, whereas this is not
1
true if we use  in place of .

Problems for Chapter 3

63
1

b. Describe the potential advantages and disadvantages of using  instead of  to
characterize the running times of programs.
Some authors also deﬁne O in a slightly different manner; let’s use O 0 for the
alternative deﬁnition. We say that f .n/ D O 0 .g.n// if and only if jf .n/j D
O.g.n//.
c. What happens to each direction of the “if and only if” in Theorem 3.1 if we
substitute O 0 for O but still use ?
e (read “soft-oh”) to mean O with logarithmic factors igSome authors deﬁne O
nored:
e
O.g.n//
D ff .n/ W there exist positive constants c, k, and n0 such that
0  f .n/  cg.n/ lgk .n/ for all n  n0 g :
e and ‚
e in a similar manner. Prove the corresponding analog to Theod. Deﬁne 
rem 3.1.
3-6 Iterated functions
We can apply the iteration operator  used in the lg function to any monotonically
increasing function f .n/ over the reals. For a given constant c 2 R, we deﬁne the
iterated function fc by
˚
fc .n/ D min i  0 W f .i / .n/  c ;
which need not be well deﬁned in all cases. In other words, the quantity fc .n/ is
the number of iterated applications of the function f required to reduce its argument down to c or less.
For each of the following functions f .n/ and constants c, give as tight a bound
as possible on fc .n/.
a.

f .n/
n1

c
0

b.

lg n

1

c.

n=2

1

d.

2
2

f.

n=2
p
n
p
n

g.

n1=3

2

h.

n= lg n

2

e.

1

fc .n/

64

Chapter 3 Growth of Functions

Chapter notes
Knuth [209] traces the origin of the O-notation to a number-theory text by P. Bachmann in 1892. The o-notation was invented by E. Landau in 1909 for his discussion
of the distribution of prime numbers. The  and ‚ notations were advocated by
Knuth [213] to correct the popular, but technically sloppy, practice in the literature
of using O-notation for both upper and lower bounds. Many people continue to
use the O-notation where the ‚-notation is more technically precise. Further discussion of the history and development of asymptotic notations appears in works
by Knuth [209, 213] and Brassard and Bratley [54].
Not all authors deﬁne the asymptotic notations in the same way, although the
various deﬁnitions agree in most common situations. Some of the alternative definitions encompass functions that are not asymptotically nonnegative, as long as
their absolute values are appropriately bounded.
Equation (3.20) is due to Robbins [297]. Other properties of elementary mathematical functions can be found in any good mathematical reference, such as
Abramowitz and Stegun [1] or Zwillinger [362], or in a calculus book, such as
Apostol [18] or Thomas et al. [334]. Knuth [209] and Graham, Knuth, and Patashnik [152] contain a wealth of material on discrete mathematics as used in computer
science.

4

Divide-and-Conquer

In Section 2.3.1, we saw how merge sort serves as an example of the divide-andconquer paradigm. Recall that in divide-and-conquer, we solve a problem recursively, applying three steps at each level of the recursion:
Divide the problem into a number of subproblems that are smaller instances of the
same problem.
Conquer the subproblems by solving them recursively. If the subproblem sizes are
small enough, however, just solve the subproblems in a straightforward manner.
Combine the solutions to the subproblems into the solution for the original problem.
When the subproblems are large enough to solve recursively, we call that the recursive case. Once the subproblems become small enough that we no longer recurse,
we say that the recursion “bottoms out” and that we have gotten down to the base
case. Sometimes, in addition to subproblems that are smaller instances of the same
problem, we have to solve subproblems that are not quite the same as the original
problem. We consider solving such subproblems as part of the combine step.
In this chapter, we shall see more algorithms based on divide-and-conquer. The
ﬁrst one solves the maximum-subarray problem: it takes as input an array of numbers, and it determines the contiguous subarray whose values have the greatest sum.
Then we shall see two divide-and-conquer algorithms for multiplying n n matrices. One runs in ‚.n3 / time, which is no better than the straightforward method of
multiplying square matrices. But the other, Strassen’s algorithm, runs in O.n2:81 /
time, which beats the straightforward method asymptotically.
Recurrences
Recurrences go hand in hand with the divide-and-conquer paradigm, because they
give us a natural way to characterize the running times of divide-and-conquer algorithms. A recurrence is an equation or inequality that describes a function in terms

66

Chapter 4 Divide-and-Conquer

of its value on smaller inputs. For example, in Section 2.3.2 we described the
worst-case running time T .n/ of the M ERGE -S ORT procedure by the recurrence
(
‚.1/
if n D 1 ;
T .n/ D
(4.1)
2T .n=2/ C ‚.n/ if n > 1 ;
whose solution we claimed to be T .n/ D ‚.n lg n/.
Recurrences can take many forms. For example, a recursive algorithm might
divide subproblems into unequal sizes, such as a 2=3-to-1=3 split. If the divide and
combine steps take linear time, such an algorithm would give rise to the recurrence
T .n/ D T .2n=3/ C T .n=3/ C ‚.n/.
Subproblems are not necessarily constrained to being a constant fraction of
the original problem size. For example, a recursive version of linear search
(see Exercise 2.1-3) would create just one subproblem containing only one element fewer than the original problem. Each recursive call would take constant time plus the time for the recursive calls it makes, yielding the recurrence
T .n/ D T .n  1/ C ‚.1/.
This chapter offers three methods for solving recurrences—that is, for obtaining
asymptotic “‚” or “O” bounds on the solution:


In the substitution method, we guess a bound and then use mathematical induction to prove our guess correct.



The recursion-tree method converts the recurrence into a tree whose nodes
represent the costs incurred at various levels of the recursion. We use techniques
for bounding summations to solve the recurrence.



The master method provides bounds for recurrences of the form
T .n/ D aT .n=b/ C f .n/ ;

(4.2)

where a  1, b > 1, and f .n/ is a given function. Such recurrences arise
frequently. A recurrence of the form in equation (4.2) characterizes a divideand-conquer algorithm that creates a subproblems, each of which is 1=b the
size of the original problem, and in which the divide and combine steps together
take f .n/ time.
To use the master method, you will need to memorize three cases, but once
you do that, you will easily be able to determine asymptotic bounds for many
simple recurrences. We will use the master method to determine the running
times of the divide-and-conquer algorithms for the maximum-subarray problem
and for matrix multiplication, as well as for other algorithms based on divideand-conquer elsewhere in this book.

Chapter 4 Divide-and-Conquer

67

Occasionally, we shall see recurrences that are not equalities but rather inequalities, such as T .n/  2T .n=2/ C ‚.n/. Because such a recurrence states only
an upper bound on T .n/, we will couch its solution using O-notation rather than
‚-notation. Similarly, if the inequality were reversed to T .n/  2T .n=2/ C ‚.n/,
then because the recurrence gives only a lower bound on T .n/, we would use
-notation in its solution.
Technicalities in recurrences
In practice, we neglect certain technical details when we state and solve recurrences. For example, if we call M ERGE -S ORT on n elements when n is odd, we
end up with subproblems of size bn=2c and dn=2e. Neither size is actually n=2,
because n=2 is not an integer when n is odd. Technically, the recurrence describing
the worst-case running time of M ERGE -S ORT is really
(
‚.1/
if n D 1 ;
T .n/ D
(4.3)
T .dn=2e/ C T .bn=2c/ C ‚.n/ if n > 1 :
Boundary conditions represent another class of details that we typically ignore.
Since the running time of an algorithm on a constant-sized input is a constant,
the recurrences that arise from the running times of algorithms generally have
T .n/ D ‚.1/ for sufﬁciently small n. Consequently, for convenience, we shall
generally omit statements of the boundary conditions of recurrences and assume
that T .n/ is constant for small n. For example, we normally state recurrence (4.1)
as
T .n/ D 2T .n=2/ C ‚.n/ ;

(4.4)

without explicitly giving values for small n. The reason is that although changing
the value of T .1/ changes the exact solution to the recurrence, the solution typically doesn’t change by more than a constant factor, and so the order of growth is
unchanged.
When we state and solve recurrences, we often omit ﬂoors, ceilings, and boundary conditions. We forge ahead without these details and later determine whether
or not they matter. They usually do not, but you should know when they do. Experience helps, and so do some theorems stating that these details do not affect the
asymptotic bounds of many recurrences characterizing divide-and-conquer algorithms (see Theorem 4.1). In this chapter, however, we shall address some of these
details and illustrate the ﬁne points of recurrence solution methods.

68

4.1

Chapter 4 Divide-and-Conquer

The maximum-subarray problem
Suppose that you been offered the opportunity to invest in the Volatile Chemical
Corporation. Like the chemicals the company produces, the stock price of the
Volatile Chemical Corporation is rather volatile. You are allowed to buy one unit
of stock only one time and then sell it at a later date, buying and selling after the
close of trading for the day. To compensate for this restriction, you are allowed to
learn what the price of the stock will be in the future. Your goal is to maximize
your proﬁt. Figure 4.1 shows the price of the stock over a 17-day period. You
may buy the stock at any one time, starting after day 0, when the price is $100
per share. Of course, you would want to “buy low, sell high”—buy at the lowest
possible price and later on sell at the highest possible price—to maximize your
proﬁt. Unfortunately, you might not be able to buy at the lowest price and then sell
at the highest price within a given period. In Figure 4.1, the lowest price occurs
after day 7, which occurs after the highest price, after day 1.
You might think that you can always maximize proﬁt by either buying at the
lowest price or selling at the highest price. For example, in Figure 4.1, we would
maximize proﬁt by buying at the lowest price, after day 7. If this strategy always
worked, then it would be easy to determine how to maximize proﬁt: ﬁnd the highest
and lowest prices, and then work left from the highest price to ﬁnd the lowest prior
price, work right from the lowest price to ﬁnd the highest later price, and take
the pair with the greater difference. Figure 4.2 shows a simple counterexample,
120
110
100
90
80
70
60
0

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

Day
0
1
2
3
4
5
6
7 8
9 10 11 12 13 14 15 16
Price
100 113 110 85 105 102 86 63 81 101 94 106 101 79 94 90 97
13 3 25 20 3 16 23 18 20 7 12 5 22 15 4 7
Change

Figure 4.1 Information about the price of stock in the Volatile Chemical Corporation after the close
of trading over a period of 17 days. The horizontal axis of the chart indicates the day, and the vertical
axis shows the price. The bottom row of the table gives the change in price from the previous day.

4.1 The maximum-subarray problem

11
10
9
8
7
6

69

Day
Price
Change

0

1

2

3

0
10

1
11
1

2
7
4

3
10
3

4
6
4

4

Figure 4.2 An example showing that the maximum proﬁt does not always start at the lowest price
or end at the highest price. Again, the horizontal axis indicates the day, and the vertical axis shows
the price. Here, the maximum proﬁt of $3 per share would be earned by buying after day 2 and
selling after day 3. The price of $7 after day 2 is not the lowest price overall, and the price of $10
after day 3 is not the highest price overall.

demonstrating that the maximum proﬁt sometimes comes neither by buying at the
lowest price nor by selling at the highest price.
A brute-force solution
We can easily devise a brute-force solution to this problem: just try every possible
pair of buy and sell dates in which the buy date precedes the sell date. A period of n
days has n2 such pairs of dates. Since n2 is ‚.n2 /, and the best we can hope for
is to evaluate each pair of dates in constant time, this approach would take .n2 /
time. Can we do better?
A transformation
In order to design an algorithm with an o.n2 / running time, we will look at the
input in a slightly different way. We want to ﬁnd a sequence of days over which
the net change from the ﬁrst day to the last is maximum. Instead of looking at the
daily prices, let us instead consider the daily change in price, where the change on
day i is the difference between the prices after day i  1 and after day i. The table
in Figure 4.1 shows these daily changes in the bottom row. If we treat this row as
an array A, shown in Figure 4.3, we now want to ﬁnd the nonempty, contiguous
subarray of A whose values have the largest sum. We call this contiguous subarray
the maximum subarray. For example, in the array of Figure 4.3, the maximum
subarray of AŒ1 : : 16 is AŒ8 : : 11, with the sum 43. Thus, you would want to buy
the stock just before day 8 (that is, after day 7) and sell it after day 11, earning a
proﬁt of $43 per share.
At ﬁrst glance, this transformation does not help. We still need to check
n1
D ‚.n2 / subarrays for a period of n days. Exercise 4.1-2 asks you to show
2

70

Chapter 4 Divide-and-Conquer

15

16

A 13 –3 –25 20 –3 –16 –23 18 20 –7 12 –5 –22 15 –4

1

2

3

4

5

6

7

8

9

10

11

12

13

14

7

maximum subarray
Figure 4.3 The change in stock prices as a maximum-subarray problem. Here, the subarray AŒ8 : : 11, with sum 43, has the greatest sum of any contiguous subarray of array A.

that although computing the cost of one subarray might take time proportional to
the length of the subarray, when computing all ‚.n2 / subarray sums, we can organize the computation so that each subarray sum takes O.1/ time, given the values
of previously computed subarray sums, so that the brute-force solution takes ‚.n2 /
time.
So let us seek a more efﬁcient solution to the maximum-subarray problem.
When doing so, we will usually speak of “a” maximum subarray rather than “the”
maximum subarray, since there could be more than one subarray that achieves the
maximum sum.
The maximum-subarray problem is interesting only when the array contains
some negative numbers. If all the array entries were nonnegative, then the
maximum-subarray problem would present no challenge, since the entire array
would give the greatest sum.
A solution using divide-and-conquer
Let’s think about how we might solve the maximum-subarray problem using
the divide-and-conquer technique. Suppose we want to ﬁnd a maximum subarray of the subarray AŒlow : : high. Divide-and-conquer suggests that we divide
the subarray into two subarrays of as equal size as possible. That is, we ﬁnd
the midpoint, say mid, of the subarray, and consider the subarrays AŒlow : : mid
and AŒmid C 1 : : high. As Figure 4.4(a) shows, any contiguous subarray AŒi : : j 
of AŒlow : : high must lie in exactly one of the following places:


entirely in the subarray AŒlow : : mid, so that low  i  j  mid,



entirely in the subarray AŒmid C 1 : : high, so that mid < i  j  high, or



crossing the midpoint, so that low  i  mid < j  high.

Therefore, a maximum subarray of AŒlow : : high must lie in exactly one of these
places. In fact, a maximum subarray of AŒlow : : high must have the greatest
sum over all subarrays entirely in AŒlow : : mid, entirely in AŒmid C 1 : : high,
or crossing the midpoint. We can ﬁnd maximum subarrays of AŒlow : : mid and
AŒmidC1 : : high recursively, because these two subproblems are smaller instances
of the problem of ﬁnding a maximum subarray. Thus, all that is left to do is ﬁnd a

4.1 The maximum-subarray problem

71

crosses the midpoint
low

mid

AŒmid C 1 : : j 
high

low

i

mid

mid C 1

entirely in AŒlow : : mid

entirely in AŒmid C 1 : : high

high
mid C 1

j

AŒi : : mid

(a)

(b)

Figure 4.4 (a) Possible locations of subarrays of AŒlow : : high: entirely in AŒlow : : mid, entirely
in AŒmid C 1 : : high, or crossing the midpoint mid. (b) Any subarray of AŒlow : : high crossing
the midpoint comprises two subarrays AŒi : : mid and AŒmid C 1 : : j , where low  i  mid and
mid < j  high.

maximum subarray that crosses the midpoint, and take a subarray with the largest
sum of the three.
We can easily ﬁnd a maximum subarray crossing the midpoint in time linear
in the size of the subarray AŒlow : : high. This problem is not a smaller instance
of our original problem, because it has the added restriction that the subarray it
chooses must cross the midpoint. As Figure 4.4(b) shows, any subarray crossing
the midpoint is itself made of two subarrays AŒi : : mid and AŒmid C 1 : : j , where
low  i  mid and mid < j  high. Therefore, we just need to ﬁnd maximum
subarrays of the form AŒi : : mid and AŒmid C 1 : : j  and then combine them. The
procedure F IND -M AX -C ROSSING -S UBARRAY takes as input the array A and the
indices low, mid, and high, and it returns a tuple containing the indices demarcating
a maximum subarray that crosses the midpoint, along with the sum of the values in
a maximum subarray.
F IND -M AX -C ROSSING -S UBARRAY .A; low; mid; high/
1 left-sum D 1
2 sum D 0
3 for i D mid downto low
4
sum D sum C AŒi
5
if sum > left-sum
6
left-sum D sum
7
max-left D i
8 right-sum D 1
9 sum D 0
10 for j D mid C 1 to high
11
sum D sum C AŒj 
12
if sum > right-sum
13
right-sum D sum
14
max-right D j
15 return .max-left; max-right; left-sum C right-sum/

72

Chapter 4 Divide-and-Conquer

This procedure works as follows. Lines 1–7 ﬁnd a maximum subarray of the
left half, AŒlow : : mid. Since this subarray must contain AŒmid, the for loop of
lines 3–7 starts the index i at mid and works down to low, so that every subarray
it considers is of the form AŒi : : mid. Lines 1–2 initialize the variables left-sum,
which holds the greatest sum found so far, and sum, holding the sum of the entries
in AŒi : : mid. Whenever we ﬁnd, in line 5, a subarray AŒi : : mid with a sum of
values greater than left-sum, we update left-sum to this subarray’s sum in line 6, and
in line 7 we update the variable max-left to record this index i. Lines 8–14 work
analogously for the right half, AŒmid C 1 : : high. Here, the for loop of lines 10–14
starts the index j at midC1 and works up to high, so that every subarray it considers
is of the form AŒmid C 1 : : j . Finally, line 15 returns the indices max-left and
max-right that demarcate a maximum subarray crossing the midpoint, along with
the sum left-sum Cright-sum of the values in the subarray AŒmax-left : : max-right.
If the subarray AŒlow : : high contains n entries (so that n D high  low C 1),
we claim that the call F IND -M AX -C ROSSING -S UBARRAY .A; low; mid; high/
takes ‚.n/ time. Since each iteration of each of the two for loops takes ‚.1/
time, we just need to count up how many iterations there are altogether. The for
loop of lines 3–7 makes mid  low C 1 iterations, and the for loop of lines 10–14
makes high  mid iterations, and so the total number of iterations is
.mid  low C 1/ C .high  mid/ D high  low C 1
D n:
With a linear-time F IND -M AX -C ROSSING -S UBARRAY procedure in hand, we
can write pseudocode for a divide-and-conquer algorithm to solve the maximumsubarray problem:
F IND -M AXIMUM -S UBARRAY .A; low; high/
1 if high == low
2
return .low; high; AŒlow/
// base case: only one element
3 else mid D b.low C high/=2c
4
.left-low; left-high; left-sum/ D
F IND -M AXIMUM -S UBARRAY .A; low; mid/
5
.right-low; right-high; right-sum/ D
F IND -M AXIMUM -S UBARRAY .A; mid C 1; high/
6
.cross-low; cross-high; cross-sum/ D
F IND -M AX -C ROSSING -S UBARRAY .A; low; mid; high/
7
if left-sum  right-sum and left-sum  cross-sum
8
return .left-low; left-high; left-sum/
9
elseif right-sum  left-sum and right-sum  cross-sum
10
return .right-low; right-high; right-sum/
11
else return .cross-low; cross-high; cross-sum/

4.1 The maximum-subarray problem

73

The initial call F IND -M AXIMUM -S UBARRAY .A; 1; A:length/ will ﬁnd a maximum subarray of AŒ1 : : n.
Similar to F IND -M AX -C ROSSING -S UBARRAY, the recursive procedure F IND M AXIMUM -S UBARRAY returns a tuple containing the indices that demarcate a
maximum subarray, along with the sum of the values in a maximum subarray.
Line 1 tests for the base case, where the subarray has just one element. A subarray with just one element has only one subarray—itself—and so line 2 returns a
tuple with the starting and ending indices of just the one element, along with its
value. Lines 3–11 handle the recursive case. Line 3 does the divide part, computing the index mid of the midpoint. Let’s refer to the subarray AŒlow : : mid as the
left subarray and to AŒmid C 1 : : high as the right subarray. Because we know
that the subarray AŒlow : : high contains at least two elements, each of the left and
right subarrays must have at least one element. Lines 4 and 5 conquer by recursively ﬁnding maximum subarrays within the left and right subarrays, respectively.
Lines 6–11 form the combine part. Line 6 ﬁnds a maximum subarray that crosses
the midpoint. (Recall that because line 6 solves a subproblem that is not a smaller
instance of the original problem, we consider it to be in the combine part.) Line 7
tests whether the left subarray contains a subarray with the maximum sum, and
line 8 returns that maximum subarray. Otherwise, line 9 tests whether the right
subarray contains a subarray with the maximum sum, and line 10 returns that maximum subarray. If neither the left nor right subarrays contain a subarray achieving
the maximum sum, then a maximum subarray must cross the midpoint, and line 11
returns it.
Analyzing the divide-and-conquer algorithm
Next we set up a recurrence that describes the running time of the recursive F IND M AXIMUM -S UBARRAY procedure. As we did when we analyzed merge sort in
Section 2.3.2, we make the simplifying assumption that the original problem size
is a power of 2, so that all subproblem sizes are integers. We denote by T .n/ the
running time of F IND -M AXIMUM -S UBARRAY on a subarray of n elements. For
starters, line 1 takes constant time. The base case, when n D 1, is easy: line 2
takes constant time, and so
T .1/ D ‚.1/ :

(4.5)

The recursive case occurs when n > 1. Lines 1 and 3 take constant time. Each
of the subproblems solved in lines 4 and 5 is on a subarray of n=2 elements (our
assumption that the original problem size is a power of 2 ensures that n=2 is an
integer), and so we spend T .n=2/ time solving each of them. Because we have
to solve two subproblems—for the left subarray and for the right subarray—the
contribution to the running time from lines 4 and 5 comes to 2T .n=2/. As we have

74

Chapter 4 Divide-and-Conquer

already seen, the call to F IND -M AX -C ROSSING -S UBARRAY in line 6 takes ‚.n/
time. Lines 7–11 take only ‚.1/ time. For the recursive case, therefore, we have
T .n/ D ‚.1/ C 2T .n=2/ C ‚.n/ C ‚.1/
D 2T .n=2/ C ‚.n/ :

(4.6)

Combining equations (4.5) and (4.6) gives us a recurrence for the running
time T .n/ of F IND -M AXIMUM -S UBARRAY:
(
‚.1/
if n D 1 ;
T .n/ D
(4.7)
2T .n=2/ C ‚.n/ if n > 1 :
This recurrence is the same as recurrence (4.1) for merge sort. As we shall
see from the master method in Section 4.5, this recurrence has the solution
T .n/ D ‚.n lg n/. You might also revisit the recursion tree in Figure 2.5 to understand why the solution should be T .n/ D ‚.n lg n/.
Thus, we see that the divide-and-conquer method yields an algorithm that is
asymptotically faster than the brute-force method. With merge sort and now the
maximum-subarray problem, we begin to get an idea of how powerful the divideand-conquer method can be. Sometimes it will yield the asymptotically fastest
algorithm for a problem, and other times we can do even better. As Exercise 4.1-5
shows, there is in fact a linear-time algorithm for the maximum-subarray problem,
and it does not use divide-and-conquer.
Exercises
4.1-1
What does F IND -M AXIMUM -S UBARRAY return when all elements of A are negative?
4.1-2
Write pseudocode for the brute-force method of solving the maximum-subarray
problem. Your procedure should run in ‚.n2 / time.
4.1-3
Implement both the brute-force and recursive algorithms for the maximumsubarray problem on your own computer. What problem size n0 gives the crossover
point at which the recursive algorithm beats the brute-force algorithm? Then,
change the base case of the recursive algorithm to use the brute-force algorithm
whenever the problem size is less than n0 . Does that change the crossover point?
4.1-4
Suppose we change the deﬁnition of the maximum-subarray problem to allow the
result to be an empty subarray, where the sum of the values of an empty subar-

4.2 Strassen’s algorithm for matrix multiplication

75

ray is 0. How would you change any of the algorithms that do not allow empty
subarrays to permit an empty subarray to be the result?
4.1-5
Use the following ideas to develop a nonrecursive, linear-time algorithm for the
maximum-subarray problem. Start at the left end of the array, and progress toward
the right, keeping track of the maximum subarray seen so far. Knowing a maximum
subarray of AŒ1 : : j , extend the answer to ﬁnd a maximum subarray ending at index j C1 by using the following observation: a maximum subarray of AŒ1 : : j C 1
is either a maximum subarray of AŒ1 : : j  or a subarray AŒi : : j C 1, for some
1  i  j C 1. Determine a maximum subarray of the form AŒi : : j C 1 in
constant time based on knowing a maximum subarray ending at index j .

4.2 Strassen’s algorithm for matrix multiplication
If you have seen matrices before, then you probably know how to multiply them.
(Otherwise, you should read Section D.1 in Appendix D.) If A D .aij / and
B D .bij / are square n n matrices, then in the product C D A  B, we deﬁne the
entry cij , for i; j D 1; 2; : : : ; n, by
cij D

n
X

ai k  bkj :

(4.8)

kD1

We must compute n2 matrix entries, and each is the sum of n values. The following
procedure takes n n matrices A and B and multiplies them, returning their n n
product C . We assume that each matrix has an attribute rows, giving the number
of rows in the matrix.
S QUARE -M ATRIX -M ULTIPLY .A; B/
1 n D A:rows
2 let C be a new n n matrix
3 for i D 1 to n
4
for j D 1 to n
5
cij D 0
6
for k D 1 to n
7
cij D cij C ai k  bkj
8 return C
The S QUARE -M ATRIX -M ULTIPLY procedure works as follows. The for loop
of lines 3–7 computes the entries of each row i, and within a given row i, the

76

Chapter 4 Divide-and-Conquer

for loop of lines 4–7 computes each of the entries cij , for each column j . Line 5
initializes cij to 0 as we start computing the sum given in equation (4.8), and each
iteration of the for loop of lines 6–7 adds in one more term of equation (4.8).
Because each of the triply-nested for loops runs exactly n iterations, and each
execution of line 7 takes constant time, the S QUARE -M ATRIX -M ULTIPLY procedure takes ‚.n3 / time.
You might at ﬁrst think that any matrix multiplication algorithm must take .n3 /
time, since the natural deﬁnition of matrix multiplication requires that many multiplications. You would be incorrect, however: we have a way to multiply matrices
in o.n3 / time. In this section, we shall see Strassen’s remarkable recursive algorithm for multiplying n n matrices. It runs in ‚.nlg 7 / time, which we shall show
in Section 4.5. Since lg 7 lies between 2:80 and 2:81, Strassen’s algorithm runs in
O.n2:81 / time, which is asymptotically better than the simple S QUARE -M ATRIX M ULTIPLY procedure.
A simple divide-and-conquer algorithm
To keep things simple, when we use a divide-and-conquer algorithm to compute
the matrix product C D A  B, we assume that n is an exact power of 2 in each of
the n n matrices. We make this assumption because in each divide step, we will
divide n n matrices into four n=2 n=2 matrices, and by assuming that n is an
exact power of 2, we are guaranteed that as long as n  2, the dimension n=2 is an
integer.
Suppose that we partition each of A, B, and C into four n=2 n=2 matrices






B11 B12
C11 C12
A11 A12
; BD
; C D
;
(4.9)
AD
A21 A22
B21 B22
C21 C22
so that we rewrite the equation C D A  B as
 
 


A11 A12
B11 B12
C11 C12
D

:
C21 C22
A21 A22
B21 B22

(4.10)

Equation (4.10) corresponds to the four equations
C11
C12
C21
C22

D
D
D
D

A11  B11 C A12  B21 ;
A11  B12 C A12  B22 ;
A21  B11 C A22  B21 ;
A21  B12 C A22  B22 :

(4.11)
(4.12)
(4.13)
(4.14)

Each of these four equations speciﬁes two multiplications of n=2 n=2 matrices
and the addition of their n=2 n=2 products. We can use these equations to create
a straightforward, recursive, divide-and-conquer algorithm:

4.2 Strassen’s algorithm for matrix multiplication

77

S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE .A; B/
1 n D A:rows
2 let C be a new n n matrix
3 if n == 1
4
c11 D a11  b11
5 else partition A, B, and C as in equations (4.9)
6
C11 D S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE .A11 ; B11 /
C S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE .A12 ; B21 /
7
C12 D S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE .A11 ; B12 /
C S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE .A12 ; B22 /
8
C21 D S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE .A21 ; B11 /
C S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE .A22 ; B21 /
9
C22 D S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE .A21 ; B12 /
C S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE .A22 ; B22 /
10 return C
This pseudocode glosses over one subtle but important implementation detail.
How do we partition the matrices in line 5? If we were to create 12 new n=2 n=2
matrices, we would spend ‚.n2 / time copying entries. In fact, we can partition
the matrices without copying entries. The trick is to use index calculations. We
identify a submatrix by a range of row indices and a range of column indices of
the original matrix. We end up representing a submatrix a little differently from
how we represent the original matrix, which is the subtlety we are glossing over.
The advantage is that, since we can specify submatrices by index calculations,
executing line 5 takes only ‚.1/ time (although we shall see that it makes no
difference asymptotically to the overall running time whether we copy or partition
in place).
Now, we derive a recurrence to characterize the running time of S QUARE M ATRIX -M ULTIPLY-R ECURSIVE. Let T .n/ be the time to multiply two n n
matrices using this procedure. In the base case, when n D 1, we perform just the
one scalar multiplication in line 4, and so
T .1/ D ‚.1/ :

(4.15)

The recursive case occurs when n > 1. As discussed, partitioning the matrices in
line 5 takes ‚.1/ time, using index calculations. In lines 6–9, we recursively call
S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE a total of eight times. Because each
recursive call multiplies two n=2 n=2 matrices, thereby contributing T .n=2/ to
the overall running time, the time taken by all eight recursive calls is 8T .n=2/. We
also must account for the four matrix additions in lines 6–9. Each of these matrices
contains n2 =4 entries, and so each of the four matrix additions takes ‚.n2 / time.
Since the number of matrix additions is a constant, the total time spent adding ma-

78

Chapter 4 Divide-and-Conquer

trices in lines 6–9 is ‚.n2 /. (Again, we use index calculations to place the results
of the matrix additions into the correct positions of matrix C , with an overhead
of ‚.1/ time per entry.) The total time for the recursive case, therefore, is the sum
of the partitioning time, the time for all the recursive calls, and the time to add the
matrices resulting from the recursive calls:
T .n/ D ‚.1/ C 8T .n=2/ C ‚.n2 /
D 8T .n=2/ C ‚.n2 / :

(4.16)

Notice that if we implemented partitioning by copying matrices, which would cost
‚.n2 / time, the recurrence would not change, and hence the overall running time
would increase by only a constant factor.
Combining equations (4.15) and (4.16) gives us the recurrence for the running
time of S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE:
(
‚.1/
if n D 1 ;
(4.17)
T .n/ D
2
8T .n=2/ C ‚.n / if n > 1 :
As we shall see from the master method in Section 4.5, recurrence (4.17) has the
solution T .n/ D ‚.n3 /. Thus, this simple divide-and-conquer approach is no
faster than the straightforward S QUARE -M ATRIX -M ULTIPLY procedure.
Before we continue on to examining Strassen’s algorithm, let us review where
the components of equation (4.16) came from. Partitioning each n n matrix by
index calculation takes ‚.1/ time, but we have two matrices to partition. Although
you could say that partitioning the two matrices takes ‚.2/ time, the constant of 2
is subsumed by the ‚-notation. Adding two matrices, each with, say, k entries,
takes ‚.k/ time. Since the matrices we add each have n2 =4 entries, you could
say that adding each pair takes ‚.n2 =4/ time. Again, however, the ‚-notation
subsumes the constant factor of 1=4, and we say that adding two n2 =4 n2 =4
matrices takes ‚.n2 / time. We have four such matrix additions, and once again,
instead of saying that they take ‚.4n2 / time, we say that they take ‚.n2 / time.
(Of course, you might observe that we could say that the four matrix additions
take ‚.4n2 =4/ time, and that 4n2 =4 D n2 , but the point here is that ‚-notation
subsumes constant factors, whatever they are.) Thus, we end up with two terms
of ‚.n2 /, which we can combine into one.
When we account for the eight recursive calls, however, we cannot just subsume the constant factor of 8. In other words, we must say that together they take
8T .n=2/ time, rather than just T .n=2/ time. You can get a feel for why by looking
back at the recursion tree in Figure 2.5, for recurrence (2.1) (which is identical to
recurrence (4.7)), with the recursive case T .n/ D 2T .n=2/C‚.n/. The factor of 2
determined how many children each tree node had, which in turn determined how
many terms contributed to the sum at each level of the tree. If we were to ignore

4.2 Strassen’s algorithm for matrix multiplication

79

the factor of 8 in equation (4.16) or the factor of 2 in recurrence (4.1), the recursion
tree would just be linear, rather than “bushy,” and each level would contribute only
one term to the sum.
Bear in mind, therefore, that although asymptotic notation subsumes constant
multiplicative factors, recursive notation such as T .n=2/ does not.
Strassen’s method
The key to Strassen’s method is to make the recursion tree slightly less bushy. That
is, instead of performing eight recursive multiplications of n=2 n=2 matrices,
it performs only seven. The cost of eliminating one matrix multiplication will be
several new additions of n=2 n=2 matrices, but still only a constant number of
additions. As before, the constant number of matrix additions will be subsumed
by ‚-notation when we set up the recurrence equation to characterize the running
time.
Strassen’s method is not at all obvious. (This might be the biggest understatement in this book.) It has four steps:
1. Divide the input matrices A and B and output matrix C into n=2 n=2 submatrices, as in equation (4.9). This step takes ‚.1/ time by index calculation, just
as in S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE.
2. Create 10 matrices S1 ; S2 ; : : : ; S10 , each of which is n=2 n=2 and is the sum
or difference of two matrices created in step 1. We can create all 10 matrices in
‚.n2 / time.
3. Using the submatrices created in step 1 and the 10 matrices created in step 2,
recursively compute seven matrix products P1 ; P2 ; : : : ; P7 . Each matrix Pi is
n=2 n=2.
4. Compute the desired submatrices C11 ; C12 ; C21 ; C22 of the result matrix C by
adding and subtracting various combinations of the Pi matrices. We can compute all four submatrices in ‚.n2 / time.
We shall see the details of steps 2–4 in a moment, but we already have enough
information to set up a recurrence for the running time of Strassen’s method. Let us
assume that once the matrix size n gets down to 1, we perform a simple scalar multiplication, just as in line 4 of S QUARE -M ATRIX -M ULTIPLY-R ECURSIVE. When
n > 1, steps 1, 2, and 4 take a total of ‚.n2 / time, and step 3 requires us to perform seven multiplications of n=2 n=2 matrices. Hence, we obtain the following
recurrence for the running time T .n/ of Strassen’s algorithm:
(
‚.1/
if n D 1 ;
(4.18)
T .n/ D
2
7T .n=2/ C ‚.n / if n > 1 :

80

Chapter 4 Divide-and-Conquer

We have traded off one matrix multiplication for a constant number of matrix additions. Once we understand recurrences and their solutions, we shall see that this
tradeoff actually leads to a lower asymptotic running time. By the master method
in Section 4.5, recurrence (4.18) has the solution T .n/ D ‚.nlg 7 /.
We now proceed to describe the details. In step 2, we create the following 10
matrices:
S1
S2
S3
S4
S5
S6
S7
S8
S9
S10

D
D
D
D
D
D
D
D
D
D

B12  B22 ;
A11 C A12 ;
A21 C A22 ;
B21  B11 ;
A11 C A22 ;
B11 C B22 ;
A12  A22 ;
B21 C B22 ;
A11  A21 ;
B11 C B12 :

Since we must add or subtract n=2 n=2 matrices 10 times, this step does indeed
take ‚.n2 / time.
In step 3, we recursively multiply n=2 n=2 matrices seven times to compute the
following n=2 n=2 matrices, each of which is the sum or difference of products
of A and B submatrices:
P1
P2
P3
P4
P5
P6
P7

D
D
D
D
D
D
D

A11  S1
S2  B22
S3  B11
A22  S4
S5  S6
S7  S8
S9  S10

D
D
D
D
D
D
D

A11  B12  A11  B22 ;
A11  B22 C A12  B22 ;
A21  B11 C A22  B11 ;
A22  B21  A22  B11 ;
A11  B11 C A11  B22 C A22  B11 C A22  B22 ;
A12  B21 C A12  B22  A22  B21  A22  B22 ;
A11  B11 C A11  B12  A21  B11  A21  B12 :

Note that the only multiplications we need to perform are those in the middle column of the above equations. The right-hand column just shows what these products
equal in terms of the original submatrices created in step 1.
Step 4 adds and subtracts the Pi matrices created in step 3 to construct the four
n=2 n=2 submatrices of the product C . We start with
C11 D P5 C P4  P2 C P6 :

4.2 Strassen’s algorithm for matrix multiplication

81

Expanding out the right-hand side, with the expansion of each Pi on its own line
and vertically aligning terms that cancel out, we see that C11 equals
A11  B11 C A11  B22 C A22  B11 C A22  B22
 A22  B11
C A22  B21
 A11  B22
 A12  B22
 A22  B22  A22  B21 C A12  B22 C A12  B21
A11  B11

C A12  B21 ;

which corresponds to equation (4.11).
Similarly, we set
C12 D P1 C P2 ;
and so C12 equals
A11  B12  A11  B22
C A11  B22 C A12  B22
A11  B12

C A12  B22 ;

corresponding to equation (4.12).
Setting
C21 D P3 C P4
makes C21 equal
A21  B11 C A22  B11
 A22  B11 C A22  B21
A21  B11

C A22  B21 ;

corresponding to equation (4.13).
Finally, we set
C22 D P5 C P1  P3  P7 ;
so that C22 equals
A11  B11 C A11  B22 C A22  B11 C A22  B22
 A11  B22
C A11  B12
 A22  B11
 A21  B11
 A11  B11
 A11  B12 C A21  B11 C A21  B12
A22  B22

C A21  B12 ;

82

Chapter 4 Divide-and-Conquer

which corresponds to equation (4.14). Altogether, we add or subtract n=2 n=2
matrices eight times in step 4, and so this step indeed takes ‚.n2 / time.
Thus, we see that Strassen’s algorithm, comprising steps 1–4, produces the correct matrix product and that recurrence (4.18) characterizes its running time. Since
we shall see in Section 4.5 that this recurrence has the solution T .n/ D ‚.nlg 7 /,
Strassen’s method is asymptotically faster than the straightforward S QUARE M ATRIX -M ULTIPLY procedure. The notes at the end of this chapter discuss some
of the practical aspects of Strassen’s algorithm.
Exercises
Note: Although Exercises 4.2-3, 4.2-4, and 4.2-5 are about variants on Strassen’s
algorithm, you should read Section 4.5 before trying to solve them.
4.2-1
Use Strassen’s algorithm to compute the matrix product



1 3
6 8
:
7 5
4 2
Show your work.
4.2-2
Write pseudocode for Strassen’s algorithm.
4.2-3
How would you modify Strassen’s algorithm to multiply n n matrices in which n
is not an exact power of 2? Show that the resulting algorithm runs in time ‚.nlg 7 /.
4.2-4
What is the largest k such that if you can multiply 3 3 matrices using k multiplications (not assuming commutativity of multiplication), then you can multiply
n n matrices in time o.nlg 7 /? What would the running time of this algorithm be?
4.2-5
V. Pan has discovered a way of multiplying 68 68 matrices using 132,464 multiplications, a way of multiplying 70 70 matrices using 143,640 multiplications,
and a way of multiplying 72 72 matrices using 155,424 multiplications. Which
method yields the best asymptotic running time when used in a divide-and-conquer
matrix-multiplication algorithm? How does it compare to Strassen’s algorithm?

4.3 The substitution method for solving recurrences

83

4.2-6
How quickly can you multiply a k n n matrix by an n k n matrix, using Strassen’s
algorithm as a subroutine? Answer the same question with the order of the input
matrices reversed.
4.2-7
Show how to multiply the complex numbers a C bi and c C d i using only three
multiplications of real numbers. The algorithm should take a, b, c, and d as input
and produce the real component ac  bd and the imaginary component ad C bc
separately.

4.3 The substitution method for solving recurrences
Now that we have seen how recurrences characterize the running times of divideand-conquer algorithms, we will learn how to solve recurrences. We start in this
section with the “substitution” method.
The substitution method for solving recurrences comprises two steps:
1. Guess the form of the solution.
2. Use mathematical induction to ﬁnd the constants and show that the solution
works.
We substitute the guessed solution for the function when applying the inductive
hypothesis to smaller values; hence the name “substitution method.” This method
is powerful, but we must be able to guess the form of the answer in order to apply it.
We can use the substitution method to establish either upper or lower bounds on
a recurrence. As an example, let us determine an upper bound on the recurrence
T .n/ D 2T .bn=2c/ C n ;

(4.19)

which is similar to recurrences (4.3) and (4.4). We guess that the solution is
T .n/ D O.n lg n/. The substitution method requires us to prove that T .n/ 
cn lg n for an appropriate choice of the constant c > 0. We start by assuming
that this bound holds for all positive m < n, in particular for m D bn=2c, yielding
T .bn=2c/  c bn=2c lg.bn=2c/. Substituting into the recurrence yields
T .n/ 

D
D


2.c bn=2c lg.bn=2c// C n
cn lg.n=2/ C n
cn lg n  cn lg 2 C n
cn lg n  cn C n
cn lg n ;

84

Chapter 4 Divide-and-Conquer

where the last step holds as long as c  1.
Mathematical induction now requires us to show that our solution holds for the
boundary conditions. Typically, we do so by showing that the boundary conditions are suitable as base cases for the inductive proof. For the recurrence (4.19),
we must show that we can choose the constant c large enough so that the bound
T .n/  cn lg n works for the boundary conditions as well. This requirement
can sometimes lead to problems. Let us assume, for the sake of argument, that
T .1/ D 1 is the sole boundary condition of the recurrence. Then for n D 1, the
bound T .n/  cn lg n yields T .1/  c1 lg 1 D 0, which is at odds with T .1/ D 1.
Consequently, the base case of our inductive proof fails to hold.
We can overcome this obstacle in proving an inductive hypothesis for a speciﬁc boundary condition with only a little more effort. In the recurrence (4.19),
for example, we take advantage of asymptotic notation requiring us only to prove
T .n/  cn lg n for n  n0 , where n0 is a constant that we get to choose. We
keep the troublesome boundary condition T .1/ D 1, but remove it from consideration in the inductive proof. We do so by ﬁrst observing that for n > 3, the
recurrence does not depend directly on T .1/. Thus, we can replace T .1/ by T .2/
and T .3/ as the base cases in the inductive proof, letting n0 D 2. Note that we
make a distinction between the base case of the recurrence (n D 1) and the base
cases of the inductive proof (n D 2 and n D 3). With T .1/ D 1, we derive from
the recurrence that T .2/ D 4 and T .3/ D 5. Now we can complete the inductive
proof that T .n/  cn lg n for some constant c  1 by choosing c large enough
so that T .2/  c2 lg 2 and T .3/  c3 lg 3. As it turns out, any choice of c  2
sufﬁces for the base cases of n D 2 and n D 3 to hold. For most of the recurrences
we shall examine, it is straightforward to extend boundary conditions to make the
inductive assumption work for small n, and we shall not always explicitly work out
the details.
Making a good guess
Unfortunately, there is no general way to guess the correct solutions to recurrences.
Guessing a solution takes experience and, occasionally, creativity. Fortunately,
though, you can use some heuristics to help you become a good guesser. You
can also use recursion trees, which we shall see in Section 4.4, to generate good
guesses.
If a recurrence is similar to one you have seen before, then guessing a similar
solution is reasonable. As an example, consider the recurrence
T .n/ D 2T .bn=2c C 17/ C n ;
which looks difﬁcult because of the added “17” in the argument to T on the righthand side. Intuitively, however, this additional term cannot substantially affect the

4.3 The substitution method for solving recurrences

85

solution to the recurrence. When n is large, the difference between bn=2c and
bn=2c C 17 is not that large: both cut n nearly evenly in half. Consequently, we
make the guess that T .n/ D O.n lg n/, which you can verify as correct by using
the substitution method (see Exercise 4.3-6).
Another way to make a good guess is to prove loose upper and lower bounds on
the recurrence and then reduce the range of uncertainty. For example, we might
start with a lower bound of T .n/ D .n/ for the recurrence (4.19), since we
have the term n in the recurrence, and we can prove an initial upper bound of
T .n/ D O.n2 /. Then, we can gradually lower the upper bound and raise the
lower bound until we converge on the correct, asymptotically tight solution of
T .n/ D ‚.n lg n/.
Subtleties
Sometimes you might correctly guess an asymptotic bound on the solution of a
recurrence, but somehow the math fails to work out in the induction. The problem
frequently turns out to be that the inductive assumption is not strong enough to
prove the detailed bound. If you revise the guess by subtracting a lower-order term
when you hit such a snag, the math often goes through.
Consider the recurrence
T .n/ D T .bn=2c/ C T .dn=2e/ C 1 :
We guess that the solution is T .n/ D O.n/, and we try to show that T .n/  cn for
an appropriate choice of the constant c. Substituting our guess in the recurrence,
we obtain
T .n/  c bn=2c C c dn=2e C 1
D cn C 1 ;
which does not imply T .n/  cn for any choice of c. We might be tempted to try
a larger guess, say T .n/ D O.n2 /. Although we can make this larger guess work,
our original guess of T .n/ D O.n/ is correct. In order to show that it is correct,
however, we must make a stronger inductive hypothesis.
Intuitively, our guess is nearly right: we are off only by the constant 1, a
lower-order term. Nevertheless, mathematical induction does not work unless we
prove the exact form of the inductive hypothesis. We overcome our difﬁculty
by subtracting a lower-order term from our previous guess. Our new guess is
T .n/  cn  d , where d  0 is a constant. We now have
T .n/  .c bn=2c  d / C .c dn=2e  d / C 1
D cn  2d C 1
 cn  d ;

86

Chapter 4 Divide-and-Conquer

as long as d  1. As before, we must choose the constant c large enough to handle
the boundary conditions.
You might ﬁnd the idea of subtracting a lower-order term counterintuitive. After all, if the math does not work out, we should increase our guess, right?
Not necessarily! When proving an upper bound by induction, it may actually be
more difﬁcult to prove that a weaker upper bound holds, because in order to prove
the weaker bound, we must use the same weaker bound inductively in the proof.
In our current example, when the recurrence has more than one recursive term, we
get to subtract out the lower-order term of the proposed bound once per recursive
term. In the above example, we subtracted out the constant d twice, once for the
T .bn=2c/ term and once for the T .dn=2e/ term. We ended up with the inequality
T .n/  cn  2d C 1, and it was easy to ﬁnd values of d to make cn  2d C 1 be
less than or equal to cn  d .
Avoiding pitfalls
It is easy to err in the use of asymptotic notation. For example, in the recurrence (4.19) we can falsely “prove” T .n/ D O.n/ by guessing T .n/  cn and
then arguing
T .n/  2.c bn=2c/ C n
 cn C n
D O.n/ ;

wrong!!

since c is a constant. The error is that we have not proved the exact form of the
inductive hypothesis, that is, that T .n/  cn. We therefore will explicitly prove
that T .n/  cn when we want to show that T .n/ D O.n/.
Changing variables
Sometimes, a little algebraic manipulation can make an unknown recurrence similar to one you have seen before. As an example, consider the recurrence
p ˘
n C lg n ;
T .n/ D 2T
which looks difﬁcult. We can simplify this recurrence, though, with a change of
variables.
For convenience, we shall not worry about rounding off values, such
p
as n, to be integers. Renaming m D lg n yields
T .2m / D 2T .2m=2 / C m :
We can now rename S.m/ D T .2m / to produce the new recurrence
S.m/ D 2S.m=2/ C m ;

4.3 The substitution method for solving recurrences

87

which is very much like recurrence (4.19). Indeed, this new recurrence has the
same solution: S.m/ D O.m lg m/. Changing back from S.m/ to T .n/, we obtain
T .n/ D T .2m / D S.m/ D O.m lg m/ D O.lg n lg lg n/ :
Exercises
4.3-1
Show that the solution of T .n/ D T .n  1/ C n is O.n2 /.
4.3-2
Show that the solution of T .n/ D T .dn=2e/ C 1 is O.lg n/.
4.3-3
We saw that the solution of T .n/ D 2T .bn=2c/ C n is O.n lg n/. Show that the solution of this recurrence is also .n lg n/. Conclude that the solution is ‚.n lg n/.
4.3-4
Show that by making a different inductive hypothesis, we can overcome the difﬁculty with the boundary condition T .1/ D 1 for recurrence (4.19) without adjusting
the boundary conditions for the inductive proof.
4.3-5
Show that ‚.n lg n/ is the solution to the “exact” recurrence (4.3) for merge sort.
4.3-6
Show that the solution to T .n/ D 2T .bn=2c C 17/ C n is O.n lg n/.
4.3-7
Using the master method in Section 4.5, you can show that the solution to the
recurrence T .n/ D 4T .n=3/ C n is T .n/ D ‚.nlog3 4 /. Show that a substitution
proof with the assumption T .n/  cnlog3 4 fails. Then show how to subtract off a
lower-order term to make a substitution proof work.
4.3-8
Using the master method in Section 4.5, you can show that the solution to the
recurrence T .n/ D 4T .n=2/ C n2 is T .n/ D ‚.n2 /. Show that a substitution
proof with the assumption T .n/  cn2 fails. Then show how to subtract off a
lower-order term to make a substitution proof work.

88

Chapter 4 Divide-and-Conquer

4.3-9
p
Solve the recurrence T .n/ D 3T . n/ C log n by making a change of variables.
Your solution should be asymptotically tight. Do not worry about whether values
are integral.

4.4

The recursion-tree method for solving recurrences
Although you can use the substitution method to provide a succinct proof that
a solution to a recurrence is correct, you might have trouble coming up with a
good guess. Drawing out a recursion tree, as we did in our analysis of the merge
sort recurrence in Section 2.3.2, serves as a straightforward way to devise a good
guess. In a recursion tree, each node represents the cost of a single subproblem
somewhere in the set of recursive function invocations. We sum the costs within
each level of the tree to obtain a set of per-level costs, and then we sum all the
per-level costs to determine the total cost of all levels of the recursion.
A recursion tree is best used to generate a good guess, which you can then verify
by the substitution method. When using a recursion tree to generate a good guess,
you can often tolerate a small amount of “sloppiness,” since you will be verifying
your guess later on. If you are very careful when drawing out a recursion tree and
summing the costs, however, you can use a recursion tree as a direct proof of a
solution to a recurrence. In this section, we will use recursion trees to generate
good guesses, and in Section 4.6, we will use recursion trees directly to prove the
theorem that forms the basis of the master method.
For example, let us see how a recursion tree would provide a good guess for
the recurrence T .n/ D 3T .bn=4c/ C ‚.n2 /. We start by focusing on ﬁnding an
upper bound for the solution. Because we know that ﬂoors and ceilings usually do
not matter when solving recurrences (here’s an example of sloppiness that we can
tolerate), we create a recursion tree for the recurrence T .n/ D 3T .n=4/ C cn2 ,
having written out the implied constant coefﬁcient c > 0.
Figure 4.5 shows how we derive the recursion tree for T .n/ D 3T .n=4/ C cn2 .
For convenience, we assume that n is an exact power of 4 (another example of
tolerable sloppiness) so that all subproblem sizes are integers. Part (a) of the ﬁgure
shows T .n/, which we expand in part (b) into an equivalent tree representing the
recurrence. The cn2 term at the root represents the cost at the top level of recursion,
and the three subtrees of the root represent the costs incurred by the subproblems
of size n=4. Part (c) shows this process carried one step further by expanding each
node with cost T .n=4/ from part (b). The cost for each of the three children of the
root is c.n=4/2 . We continue expanding each node in the tree by breaking it into
its constituent parts as determined by the recurrence.

4.4 The recursion-tree method for solving recurrences

89

cn2

T .n/

T

n
4

cn2

n
4

T

T

n
4

T
(a)

n
16

c

n 2
4

T

n
16

T

n
16

n
16

T

c

n 2
4

T

n
16

(b)

T

n
16

T

n
16

c

n 2
4

T

n
16

T

(c)

cn2

cn2

c

n 2
4

c

n 2
16

n
16

c

n 2
4

c

n 2
16

c

n 2
4

c

n 2
16

3
16

cn2

3 2
16

cn2

log4 n
n 2
16

c

n 2
16

c

n 2
16

c

n 2
16

c

n 2
16

c

n 2
16

…

c

T .1/ T .1/ T .1/ T .1/ T .1/ T .1/ T .1/ T .1/ T .1/ T .1/

…

T .1/ T .1/ T .1/

‚.nlog4 3 /

nlog4 3
(d)

Total: O.n2 /

Figure 4.5 Constructing a recursion tree for the recurrence T .n/ D 3T .n=4/ C cn2 . Part (a)
shows T .n/, which progressively expands in (b)–(d) to form the recursion tree. The fully expanded
tree in part (d) has height log4 n (it has log4 n C 1 levels).

90

Chapter 4 Divide-and-Conquer

Because subproblem sizes decrease by a factor of 4 each time we go down one
level, we eventually must reach a boundary condition. How far from the root do
we reach one? The subproblem size for a node at depth i is n=4i . Thus, the
subproblem size hits n D 1 when n=4i D 1 or, equivalently, when i D log4 n.
Thus, the tree has log4 n C 1 levels (at depths 0; 1; 2; : : : ; log4 n).
Next we determine the cost at each level of the tree. Each level has three times
more nodes than the level above, and so the number of nodes at depth i is 3i .
Because subproblem sizes reduce by a factor of 4 for each level we go down
from the root, each node at depth i, for i D 0; 1; 2; : : : ; log4 n  1, has a cost
of c.n=4i /2 . Multiplying, we see that the total cost over all nodes at depth i, for
i D 0; 1; 2; : : : ; log4 n  1, is 3i c.n=4i /2 D .3=16/i cn2 . The bottom level, at
depth log4 n, has 3log4 n D nlog4 3 nodes, each contributing cost T .1/, for a total
cost of nlog4 3 T .1/, which is ‚.nlog4 3 /, since we assume that T .1/ is a constant.
Now we add up the costs over all levels to determine the cost for the entire tree:
 2
 log4 n1
3
3
3
2
2
2
cn C
cn C    C
cn2 C ‚.nlog4 3 /
T .n/ D cn C
16
16
16

log4 n1 
X
3 i 2
cn C ‚.nlog4 3 /
D
16
i D0
D

.3=16/log 4 n  1 2
cn C ‚.nlog4 3 /
.3=16/  1

(by equation (A.5)) :

This last formula looks somewhat messy until we realize that we can again take
advantage of small amounts of sloppiness and use an inﬁnite decreasing geometric
series as an upper bound. Backing up one step and applying equation (A.6), we
have

log4 n1 
X
3 i 2
cn C ‚.nlog4 3 /
T .n/ D
16
i D0
1
X  3 i
cn2 C ‚.nlog4 3 /
<
16
i D0
1
cn2 C ‚.nlog4 3 /
1  .3=16/
16 2
cn C ‚.nlog4 3 /
D
13
D O.n2 / :
D

Thus, we have derived a guess of T .n/ D O.n2 / for our original recurrence
T .n/ D 3T .bn=4c/ C ‚.n2 /. In this example, the coefﬁcients of cn2 form a
decreasing geometric series and, by equation (A.6), the sum of these coefﬁcients

4.4 The recursion-tree method for solving recurrences

cn

cn

c

91

n
3

c

2n
3

cn

log3=2 n
c

n
9

c

2n
9

c

2n
9

c

4n
9

cn

…

…

Total: O.n lg n/

Figure 4.6 A recursion tree for the recurrence T .n/ D T .n=3/ C T .2n=3/ C cn.

is bounded from above by the constant 16=13. Since the root’s contribution to the
total cost is cn2 , the root contributes a constant fraction of the total cost. In other
words, the cost of the root dominates the total cost of the tree.
In fact, if O.n2 / is indeed an upper bound for the recurrence (as we shall verify in
a moment), then it must be a tight bound. Why? The ﬁrst recursive call contributes
a cost of ‚.n2 /, and so .n2 / must be a lower bound for the recurrence.
Now we can use the substitution method to verify that our guess was correct, that is, T .n/ D O.n2 / is an upper bound for the recurrence T .n/ D
3T .bn=4c/ C ‚.n2 /. We want to show that T .n/  d n2 for some constant d > 0.
Using the same constant c > 0 as before, we have
T .n/  3T .bn=4c/ C cn2
 3d bn=4c2 C cn2
 3d.n=4/2 C cn2
3
d n2 C cn2
D
16
 d n2 ;
where the last step holds as long as d  .16=13/c.
In another, more intricate, example, Figure 4.6 shows the recursion tree for
T .n/ D T .n=3/ C T .2n=3/ C O.n/ :
(Again, we omit ﬂoor and ceiling functions for simplicity.) As before, we let c
represent the constant factor in the O.n/ term. When we add the values across the
levels of the recursion tree shown in the ﬁgure, we get a value of cn for every level.

92

Chapter 4 Divide-and-Conquer

The longest simple path from the root to a leaf is n ! .2=3/n ! .2=3/2 n !
   ! 1. Since .2=3/k n D 1 when k D log3=2 n, the height of the tree is log3=2 n.
Intuitively, we expect the solution to the recurrence to be at most the number
of levels times the cost of each level, or O.cn log3=2 n/ D O.n lg n/. Figure 4.6
shows only the top levels of the recursion tree, however, and not every level in the
tree contributes a cost of cn. Consider the cost of the leaves. If this recursion tree
were a complete binary tree of height log3=2 n, there would be 2log3=2 n D nlog3=2 2
leaves. Since the cost of each leaf is a constant, the total cost of all leaves would
then be ‚.nlog3=2 2 / which, since log3=2 2 is a constant strictly greater than 1,
is !.n lg n/. This recursion tree is not a complete binary tree, however, and so
it has fewer than nlog3=2 2 leaves. Moreover, as we go down from the root, more
and more internal nodes are absent. Consequently, levels toward the bottom of the
recursion tree contribute less than cn to the total cost. We could work out an accurate accounting of all costs, but remember that we are just trying to come up with a
guess to use in the substitution method. Let us tolerate the sloppiness and attempt
to show that a guess of O.n lg n/ for the upper bound is correct.
Indeed, we can use the substitution method to verify that O.n lg n/ is an upper
bound for the solution to the recurrence. We show that T .n/  d n lg n, where d is
a suitable positive constant. We have
T .n/  T .n=3/ C T .2n=3/ C cn
 d.n=3/ lg.n=3/ C d.2n=3/ lg.2n=3/ C cn
D .d.n=3/ lg n  d.n=3/ lg 3/
C .d.2n=3/ lg n  d.2n=3/ lg.3=2// C cn
D d n lg n  d..n=3/ lg 3 C .2n=3/ lg.3=2// C cn
D d n lg n  d..n=3/ lg 3 C .2n=3/ lg 3  .2n=3/ lg 2/ C cn
D d n lg n  d n.lg 3  2=3/ C cn
 d n lg n ;
as long as d  c=.lg 3  .2=3//. Thus, we did not need to perform a more accurate
accounting of costs in the recursion tree.
Exercises
4.4-1
Use a recursion tree to determine a good asymptotic upper bound on the recurrence
T .n/ D 3T .bn=2c/ C n. Use the substitution method to verify your answer.
4.4-2
Use a recursion tree to determine a good asymptotic upper bound on the recurrence
T .n/ D T .n=2/ C n2 . Use the substitution method to verify your answer.

4.5 The master method for solving recurrences

93

4.4-3
Use a recursion tree to determine a good asymptotic upper bound on the recurrence
T .n/ D 4T .n=2 C 2/ C n. Use the substitution method to verify your answer.
4.4-4
Use a recursion tree to determine a good asymptotic upper bound on the recurrence
T .n/ D 2T .n  1/ C 1. Use the substitution method to verify your answer.
4.4-5
Use a recursion tree to determine a good asymptotic upper bound on the recurrence
T .n/ D T .n1/CT .n=2/Cn. Use the substitution method to verify your answer.
4.4-6
Argue that the solution to the recurrence T .n/ D T .n=3/CT .2n=3/Ccn, where c
is a constant, is .n lg n/ by appealing to a recursion tree.
4.4-7
Draw the recursion tree for T .n/ D 4T .bn=2c/ C cn, where c is a constant, and
provide a tight asymptotic bound on its solution. Verify your bound by the substitution method.
4.4-8
Use a recursion tree to give an asymptotically tight solution to the recurrence
T .n/ D T .n  a/ C T .a/ C cn, where a  1 and c > 0 are constants.
4.4-9
Use a recursion tree to give an asymptotically tight solution to the recurrence
T .n/ D T .˛ n/ C T ..1  ˛/n/ C cn, where ˛ is a constant in the range 0 < ˛ < 1
and c > 0 is also a constant.

4.5 The master method for solving recurrences
The master method provides a “cookbook” method for solving recurrences of the
form
T .n/ D aT .n=b/ C f .n/ ;

(4.20)

where a  1 and b > 1 are constants and f .n/ is an asymptotically positive
function. To use the master method, you will need to memorize three cases, but
then you will be able to solve many recurrences quite easily, often without pencil
and paper.

94

Chapter 4 Divide-and-Conquer

The recurrence (4.20) describes the running time of an algorithm that divides a
problem of size n into a subproblems, each of size n=b, where a and b are positive
constants. The a subproblems are solved recursively, each in time T .n=b/. The
function f .n/ encompasses the cost of dividing the problem and combining the
results of the subproblems. For example, the recurrence arising from Strassen’s
algorithm has a D 7, b D 2, and f .n/ D ‚.n2 /.
As a matter of technical correctness, the recurrence is not actually well deﬁned,
because n=b might not be an integer. Replacing each of the a terms T .n=b/ with
either T .bn=bc/ or T .dn=be/ will not affect the asymptotic behavior of the recurrence, however. (We will prove this assertion in the next section.) We normally
ﬁnd it convenient, therefore, to omit the ﬂoor and ceiling functions when writing
divide-and-conquer recurrences of this form.
The master theorem
The master method depends on the following theorem.
Theorem 4.1 (Master theorem)
Let a  1 and b > 1 be constants, let f .n/ be a function, and let T .n/ be deﬁned
on the nonnegative integers by the recurrence
T .n/ D aT .n=b/ C f .n/ ;
where we interpret n=b to mean either bn=bc or dn=be. Then T .n/ has the following asymptotic bounds:
1. If f .n/ D O.nlogb a / for some constant  > 0, then T .n/ D ‚.nlogb a /.
2. If f .n/ D ‚.nlogb a /, then T .n/ D ‚.nlogb a lg n/.
3. If f .n/ D .nlogb aC / for some constant  > 0, and if af .n=b/  cf .n/ for
some constant c < 1 and all sufﬁciently large n, then T .n/ D ‚.f .n//.
Before applying the master theorem to some examples, let’s spend a moment
trying to understand what it says. In each of the three cases, we compare the
function f .n/ with the function nlogb a . Intuitively, the larger of the two functions
determines the solution to the recurrence. If, as in case 1, the function nlogb a is the
larger, then the solution is T .n/ D ‚.nlogb a /. If, as in case 3, the function f .n/
is the larger, then the solution is T .n/ D ‚.f .n//. If, as in case 2, the two functions are the same size, we multiply by a logarithmic factor, and the solution is
T .n/ D ‚.nlogb a lg n/ D ‚.f .n/ lg n/.
Beyond this intuition, you need to be aware of some technicalities. In the ﬁrst
case, not only must f .n/ be smaller than nlogb a , it must be polynomially smaller.

4.5 The master method for solving recurrences

95

That is, f .n/ must be asymptotically smaller than nlogb a by a factor of n for some
constant  > 0. In the third case, not only must f .n/ be larger than nlogb a , it also
must be polynomially larger and in addition satisfy the “regularity” condition that
af .n=b/  cf .n/. This condition is satisﬁed by most of the polynomially bounded
functions that we shall encounter.
Note that the three cases do not cover all the possibilities for f .n/. There is
a gap between cases 1 and 2 when f .n/ is smaller than nlogb a but not polynomially smaller. Similarly, there is a gap between cases 2 and 3 when f .n/ is larger
than nlogb a but not polynomially larger. If the function f .n/ falls into one of these
gaps, or if the regularity condition in case 3 fails to hold, you cannot use the master
method to solve the recurrence.
Using the master method
To use the master method, we simply determine which case (if any) of the master
theorem applies and write down the answer.
As a ﬁrst example, consider
T .n/ D 9T .n=3/ C n :
For this recurrence, we have a D 9, b D 3, f .n/ D n, and thus we have that
nlogb a D nlog3 9 D ‚.n2 ). Since f .n/ D O.nlog3 9 /, where  D 1, we can apply
case 1 of the master theorem and conclude that the solution is T .n/ D ‚.n2 /.
Now consider
T .n/ D T .2n=3/ C 1;
in which a D 1, b D 3=2, f .n/ D 1, and nlogb a D nlog3=2 1 D n0 D 1. Case 2
applies, since f .n/ D ‚.nlogb a / D ‚.1/, and thus the solution to the recurrence
is T .n/ D ‚.lg n/.
For the recurrence
T .n/ D 3T .n=4/ C n lg n ;
we have a D 3, b D 4, f .n/ D n lg n, and nlogb a D nlog4 3 D O.n0:793 /.
Since f .n/ D .nlog4 3C /, where   0:2, case 3 applies if we can show that
the regularity condition holds for f .n/. For sufﬁciently large n, we have that
af .n=b/ D 3.n=4/ lg.n=4/  .3=4/n lg n D cf .n/ for c D 3=4. Consequently,
by case 3, the solution to the recurrence is T .n/ D ‚.n lg n/.
The master method does not apply to the recurrence
T .n/ D 2T .n=2/ C n lg n ;
even though it appears to have the proper form: a D 2, b D 2, f .n/ D n lg n,
and nlogb a D n. You might mistakenly think that case 3 should apply, since

96

Chapter 4 Divide-and-Conquer

f .n/ D n lg n is asymptotically larger than nlogb a D n. The problem is that it
is not polynomially larger. The ratio f .n/=nlogb a D .n lg n/=n D lg n is asymptotically less than n for any positive constant . Consequently, the recurrence falls
into the gap between case 2 and case 3. (See Exercise 4.6-2 for a solution.)
Let’s use the master method to solve the recurrences we saw in Sections 4.1
and 4.2. Recurrence (4.7),
T .n/ D 2T .n=2/ C ‚.n/ ;
characterizes the running times of the divide-and-conquer algorithm for both the
maximum-subarray problem and merge sort. (As is our practice, we omit stating
the base case in the recurrence.) Here, we have a D 2, b D 2, f .n/ D ‚.n/, and
thus we have that nlogb a D nlog2 2 D n. Case 2 applies, since f .n/ D ‚.n/, and so
we have the solution T .n/ D ‚.n lg n/.
Recurrence (4.17),
T .n/ D 8T .n=2/ C ‚.n2 / ;
describes the running time of the ﬁrst divide-and-conquer algorithm that we saw
for matrix multiplication. Now we have a D 8, b D 2, and f .n/ D ‚.n2 /,
and so nlogb a D nlog2 8 D n3 . Since n3 is polynomially larger than f .n/ (that is,
f .n/ D O.n3 / for  D 1), case 1 applies, and T .n/ D ‚.n3 /.
Finally, consider recurrence (4.18),
T .n/ D 7T .n=2/ C ‚.n2 / ;
which describes the running time of Strassen’s algorithm. Here, we have a D 7,
b D 2, f .n/ D ‚.n2 /, and thus nlogb a D nlog2 7 . Rewriting log2 7 as lg 7 and
recalling that 2:80 < lg 7 < 2:81, we see that f .n/ D O.nlg 7 / for  D 0:8.
Again, case 1 applies, and we have the solution T .n/ D ‚.nlg 7 /.
Exercises
4.5-1
Use the master method to give tight asymptotic bounds for the following recurrences.
a. T .n/ D 2T .n=4/ C 1.
p
b. T .n/ D 2T .n=4/ C n.
c. T .n/ D 2T .n=4/ C n.
d. T .n/ D 2T .n=4/ C n2 .

4.6 Proof of the master theorem

97

4.5-2
Professor Caesar wishes to develop a matrix-multiplication algorithm that is
asymptotically faster than Strassen’s algorithm. His algorithm will use the divideand-conquer method, dividing each matrix into pieces of size n=4 n=4, and the
divide and combine steps together will take ‚.n2 / time. He needs to determine
how many subproblems his algorithm has to create in order to beat Strassen’s algorithm. If his algorithm creates a subproblems, then the recurrence for the running
time T .n/ becomes T .n/ D aT .n=4/ C ‚.n2 /. What is the largest integer value
of a for which Professor Caesar’s algorithm would be asymptotically faster than
Strassen’s algorithm?
4.5-3
Use the master method to show that the solution to the binary-search recurrence
T .n/ D T .n=2/ C ‚.1/ is T .n/ D ‚.lg n/. (See Exercise 2.3-5 for a description
of binary search.)
4.5-4
Can the master method be applied to the recurrence T .n/ D 4T .n=2/ C n2 lg n?
Why or why not? Give an asymptotic upper bound for this recurrence.
4.5-5 ?
Consider the regularity condition af .n=b/  cf .n/ for some constant c < 1,
which is part of case 3 of the master theorem. Give an example of constants a  1
and b > 1 and a function f .n/ that satisﬁes all the conditions in case 3 of the
master theorem except the regularity condition.

? 4.6 Proof of the master theorem
This section contains a proof of the master theorem (Theorem 4.1). You do not
need to understand the proof in order to apply the master theorem.
The proof appears in two parts. The ﬁrst part analyzes the master recurrence (4.20), under the simplifying assumption that T .n/ is deﬁned only on exact powers of b > 1, that is, for n D 1; b; b 2 ; : : :. This part gives all the intuition
needed to understand why the master theorem is true. The second part shows how
to extend the analysis to all positive integers n; it applies mathematical technique
to the problem of handling ﬂoors and ceilings.
In this section, we shall sometimes abuse our asymptotic notation slightly by
using it to describe the behavior of functions that are deﬁned only over exact
powers of b. Recall that the deﬁnitions of asymptotic notations require that

98

Chapter 4 Divide-and-Conquer

bounds be proved for all sufﬁciently large numbers, not just those that are powers of b. Since we could make new asymptotic notations that apply only to the set
fb i W i D 0; 1; 2; : : :g, instead of to the nonnegative numbers, this abuse is minor.
Nevertheless, we must always be on guard when we use asymptotic notation over
a limited domain lest we draw improper conclusions. For example, proving that
T .n/ D O.n/ when n is an exact power of 2 does not guarantee that T .n/ D O.n/.
The function T .n/ could be deﬁned as
(
n if n D 1; 2; 4; 8; : : : ;
T .n/ D
n2 otherwise ;
in which case the best upper bound that applies to all values of n is T .n/ D O.n2 /.
Because of this sort of drastic consequence, we shall never use asymptotic notation
over a limited domain without making it absolutely clear from the context that we
are doing so.
4.6.1

The proof for exact powers

The ﬁrst part of the proof of the master theorem analyzes the recurrence (4.20)
T .n/ D aT .n=b/ C f .n/ ;
for the master method, under the assumption that n is an exact power of b > 1,
where b need not be an integer. We break the analysis into three lemmas. The ﬁrst
reduces the problem of solving the master recurrence to the problem of evaluating
an expression that contains a summation. The second determines bounds on this
summation. The third lemma puts the ﬁrst two together to prove a version of the
master theorem for the case in which n is an exact power of b.
Lemma 4.2
Let a  1 and b > 1 be constants, and let f .n/ be a nonnegative function deﬁned
on exact powers of b. Deﬁne T .n/ on exact powers of b by the recurrence
(
‚.1/
if n D 1 ;
T .n/ D
aT .n=b/ C f .n/ if n D b i ;
where i is a positive integer. Then
X

logb n1

T .n/ D ‚.n

logb a

/C

aj f .n=b j / :

(4.21)

j D0

Proof We use the recursion tree in Figure 4.7. The root of the tree has cost f .n/,
and it has a children, each with cost f .n=b/. (It is convenient to think of a as being

4.6 Proof of the master theorem

99

f .n/

f .n/
a
f .n=b/

…

f .n=b/

a

f .n=b/

a

af .n=b/

a

logb n

a
…

a
…

a
…

a
…

a
…

a
…

‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/

f .n=b 2 / f .n=b 2 /…f .n=b 2 /
a
…

…

a
…

a2 f .n=b 2 /

a
…

…

f .n=b 2 / f .n=b 2 /…f .n=b 2 / f .n=b 2 / f .n=b 2 /…f .n=b 2 /

‚.nlogb a /

‚.1/ ‚.1/ ‚.1/

nlogb a
X

logb n1

Total: ‚.nlogb a / C

aj f .n=b j /

j D0

Figure 4.7 The recursion tree generated by T .n/ D aT .n=b/ C f .n/. The tree is a complete a-ary
tree with nlogb a leaves and height logb n. The cost of the nodes at each depth is shown at the right,
and their sum is given in equation (4.21).

an integer, especially when visualizing the recursion tree, but the mathematics does
not require it.) Each of these children has a children, making a2 nodes at depth 2,
and each of the a children has cost f .n=b 2 /. In general, there are aj nodes at
depth j , and each has cost f .n=b j /. The cost of each leaf is T .1/ D ‚.1/, and
each leaf is at depth logb n, since n=b logb n D 1. There are alogb n D nlogb a leaves
in the tree.
We can obtain equation (4.21) by summing the costs of the nodes at each depth
in the tree, as shown in the ﬁgure. The cost for all internal nodes at depth j is
aj f .n=b j /, and so the total cost of all internal nodes is
X

logb n1

aj f .n=b j / :

j D0

In the underlying divide-and-conquer algorithm, this sum represents the costs of
dividing problems into subproblems and then recombining the subproblems. The

100

Chapter 4 Divide-and-Conquer

cost of all the leaves, which is the cost of doing all nlogb a subproblems of size 1,
is ‚.nlogb a /.
In terms of the recursion tree, the three cases of the master theorem correspond
to cases in which the total cost of the tree is (1) dominated by the costs in the
leaves, (2) evenly distributed among the levels of the tree, or (3) dominated by the
cost of the root.
The summation in equation (4.21) describes the cost of the dividing and combining steps in the underlying divide-and-conquer algorithm. The next lemma provides asymptotic bounds on the summation’s growth.
Lemma 4.3
Let a  1 and b > 1 be constants, and let f .n/ be a nonnegative function deﬁned
on exact powers of b. A function g.n/ deﬁned over exact powers of b by
X

logb n1

g.n/ D

aj f .n=b j /

(4.22)

j D0

has the following asymptotic bounds for exact powers of b:
1. If f .n/ D O.nlogb a / for some constant  > 0, then g.n/ D O.nlogb a /.
2. If f .n/ D ‚.nlogb a /, then g.n/ D ‚.nlogb a lg n/.
3. If af .n=b/  cf .n/ for some constant c < 1 and for all sufﬁciently large n,
then g.n/ D ‚.f .n//.
Proof For case 1, we have f .n/ D O.nlogb a /, which implies that f .n=b j / D
O..n=b j /logb a /. Substituting into equation (4.22) yields
!
logb n1
 n logb a
X
j
:
(4.23)
a
g.n/ D O
bj
j D0
We bound the summation within the O-notation by factoring out terms and simplifying, which leaves an increasing geometric series:

logb n1
logb n1 
 n logb a
X
X
ab  j
j
logb a
a
D n
bj
b logb a
j D0
j D0
X

logb n1

D n

logb a

.b  /j

j D0


D n

logb a

b  logb n  1
b  1



4.6 Proof of the master theorem

101


D nlogb a

n  1
b  1


:

Since b and  are constants, we can rewrite the last expression as nlogb a O.n / D
O.nlogb a /. Substituting this expression for the summation in equation (4.23) yields
g.n/ D O.nlogb a / ;
thereby proving case 1.
Because case 2 assumes that f .n/ D ‚.nlogb a /, we have that f .n=b j / D
‚..n=b j /logb a /. Substituting into equation (4.22) yields
!
logb n1
 n logb a
X
j
a
:
(4.24)
g.n/ D ‚
bj
j D0
We bound the summation within the ‚-notation as in case 1, but this time we do not
obtain a geometric series. Instead, we discover that every term of the summation
is the same:
X

logb n1

j D0

aj

logb n1 
 n logb a
X
a j
logb a
D
n
bj
b logb a
j D0

X

logb n1

D nlogb a

1

j D0

D n

logb a

logb n :

Substituting this expression for the summation in equation (4.24) yields
g.n/ D ‚.nlogb a logb n/
D ‚.nlogb a lg n/ ;
proving case 2.
We prove case 3 similarly. Since f .n/ appears in the deﬁnition (4.22) of g.n/
and all terms of g.n/ are nonnegative, we can conclude that g.n/ D .f .n// for
exact powers of b. We assume in the statement of the lemma that af .n=b/  cf .n/
for some constant c < 1 and all sufﬁciently large n. We rewrite this assumption
as f .n=b/  .c=a/f .n/ and iterate j times, yielding f .n=b j /  .c=a/j f .n/ or,
equivalently, aj f .n=b j /  c j f .n/, where we assume that the values we iterate
on are sufﬁciently large. Since the last, and smallest, such value is n=b j 1 , it is
enough to assume that n=b j 1 is sufﬁciently large.
Substituting into equation (4.22) and simplifying yields a geometric series, but
unlike the series in case 1, this one has decreasing terms. We use an O.1/ term to

102

Chapter 4 Divide-and-Conquer

capture the terms that are not covered by our assumption that n is sufﬁciently large:
X

logb n1

g.n/ D

aj f .n=b j /

j D0

X

logb n1



c j f .n/ C O.1/

j D0

 f .n/

1
X

c j C O.1/

j D0



1
D f .n/
1c
D O.f .n// ;


C O.1/

since c is a constant. Thus, we can conclude that g.n/ D ‚.f .n// for exact powers
of b. With case 3 proved, the proof of the lemma is complete.
We can now prove a version of the master theorem for the case in which n is an
exact power of b.
Lemma 4.4
Let a  1 and b > 1 be constants, and let f .n/ be a nonnegative function deﬁned
on exact powers of b. Deﬁne T .n/ on exact powers of b by the recurrence
(
‚.1/
if n D 1 ;
T .n/ D
aT .n=b/ C f .n/ if n D b i ;
where i is a positive integer. Then T .n/ has the following asymptotic bounds for
exact powers of b:
1. If f .n/ D O.nlogb a / for some constant  > 0, then T .n/ D ‚.nlogb a /.
2. If f .n/ D ‚.nlogb a /, then T .n/ D ‚.nlogb a lg n/.
3. If f .n/ D .nlogb aC / for some constant  > 0, and if af .n=b/  cf .n/ for
some constant c < 1 and all sufﬁciently large n, then T .n/ D ‚.f .n//.
Proof We use the bounds in Lemma 4.3 to evaluate the summation (4.21) from
Lemma 4.2. For case 1, we have
T .n/ D ‚.nlogb a / C O.nlogb a /
D ‚.nlogb a / ;

4.6 Proof of the master theorem

103

and for case 2,
T .n/ D ‚.nlogb a / C ‚.nlogb a lg n/
D ‚.nlogb a lg n/ :
For case 3,
T .n/ D ‚.nlogb a / C ‚.f .n//
D ‚.f .n// ;
because f .n/ D .nlogb aC /.
4.6.2 Floors and ceilings
To complete the proof of the master theorem, we must now extend our analysis to
the situation in which ﬂoors and ceilings appear in the master recurrence, so that
the recurrence is deﬁned for all integers, not for just exact powers of b. Obtaining
a lower bound on
T .n/ D aT .dn=be/ C f .n/

(4.25)

and an upper bound on
T .n/ D aT .bn=bc/ C f .n/

(4.26)

is routine, since we can push through the bound dn=be  n=b in the ﬁrst case to
yield the desired result, and we can push through the bound bn=bc  n=b in the
second case. We use much the same technique to lower-bound the recurrence (4.26)
as to upper-bound the recurrence (4.25), and so we shall present only this latter
bound.
We modify the recursion tree of Figure 4.7 to produce the recursion tree in Figure 4.8. As we go down in the recursion tree, we obtain a sequence of recursive
invocations on the arguments
n;
dn=be ;
ddn=be =be ;
dddn=be =be =be ;
::
:
Let us denote the j th element in the sequence by nj , where
(
n
if j D 0 ;
nj D
dnj 1 =be if j > 0 :

(4.27)

104

Chapter 4 Divide-and-Conquer

f .n/

f .n/
a
f .n1 /

f .n1 /

a

a

…

f .n1 /

af .n1 /

a

blogb nc

a
…

f .n2 / … f .n2 /
a
…

f .n2 /

a
…

a
…

f .n2 / … f .n2 /
a
…

a
…

‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/ ‚.1/

f .n2 /
a
…

…

a2 f .n2 /

f .n2 / … f .n2 /
a
…

a
…

…

f .n2 /

‚.nlogb a /

‚.1/ ‚.1/ ‚.1/

‚.nlogb a /
X

blogb nc1

Total: ‚.nlogb a / C

aj f .nj /

j D0

Figure 4.8 The recursion tree generated by T .n/ D aT .dn=be/Cf .n/. The recursive argument nj
is given by equation (4.27).

Our ﬁrst goal is to determine the depth k such that nk is a constant. Using the
inequality dxe  x C 1, we obtain
n0  n ;
n
C1;
n1 
b
n
1
C1;
C
n2 
b2
b
n
1
1
C 2 C C1;
n3 
3
b
b
b
::
:
In general, we have

4.6 Proof of the master theorem



X 1
n
C
bj
bi
i D0

<

X 1
n
C
bj
bi
i D0

D

n
b
:
C
j
b
b1

105

j 1

nj

1

Letting j D blogb nc, we obtain
nblogb nc <
<
D
D
D

n

b
b1
b
n
C
log
n1
b
b
b1
b
n
C
n=b
b1
b
bC
b1
O.1/ ;
b blogb nc

C

and thus we see that at depth blogb nc, the problem size is at most a constant.
From Figure 4.8, we see that
X

blogb nc1

T .n/ D ‚.nlogb a / C

aj f .nj / ;

(4.28)

j D0

which is much the same as equation (4.21), except that n is an arbitrary integer and
not restricted to be an exact power of b.
We can now evaluate the summation
X

blogb nc1

g.n/ D

aj f .nj /

(4.29)

j D0

from equation (4.28) in a manner analogous to the proof of Lemma 4.3. Beginning
with case 3, if af .dn=be/  cf .n/ for n > bCb=.b1/, where c < 1 is a constant,
then it follows that aj f .nj /  c j f .n/. Therefore, we can evaluate the sum in
equation (4.29) just as in Lemma 4.3. For case 2, we have f .n/ D ‚.nlogb a /. If we
can show that f .nj / D O.nlogb a =aj / D O..n=b j /logb a /, then the proof for case 2
of Lemma 4.3 will go through. Observe that j  blogb nc implies b j =n  1. The
bound f .n/ D O.nlogb a / implies that there exists a constant c > 0 such that for all
sufﬁciently large nj ,

106

Chapter 4 Divide-and-Conquer

logb a
n
b
c
C
bj
b1
logb a
 
b
n
bj

c
1C
bj
n b1
logb a
 logb a  
 j
b
n
b

c
1
C
aj
n b1
logb a
 logb a  
n
b
c
1
C
aj
b1
 logb a 
n
O
;
aj


f .nj / 
D
D

D

since c.1 C b=.b  1//logb a is a constant. Thus, we have proved case 2. The proof
of case 1 is almost identical. The key is to prove the bound f .nj / D O.nlogb a /,
which is similar to the corresponding proof of case 2, though the algebra is more
intricate.
We have now proved the upper bounds in the master theorem for all integers n.
The proof of the lower bounds is similar.
Exercises
4.6-1 ?
Give a simple and exact expression for nj in equation (4.27) for the case in which b
is a positive integer instead of an arbitrary real number.
4.6-2 ?
Show that if f .n/ D ‚.nlogb a lgk n/, where k  0, then the master recurrence has
solution T .n/ D ‚.nlogb a lgkC1 n/. For simplicity, conﬁne your analysis to exact
powers of b.
4.6-3 ?
Show that case 3 of the master theorem is overstated, in the sense that the regularity
condition af .n=b/  cf .n/ for some constant c < 1 implies that there exists a
constant  > 0 such that f .n/ D .nlogb aC /.

Problems for Chapter 4

107

Problems
4-1 Recurrence examples
Give asymptotic upper and lower bounds for T .n/ in each of the following recurrences. Assume that T .n/ is constant for n  2. Make your bounds as tight as
possible, and justify your answers.
a. T .n/ D 2T .n=2/ C n4 .
b. T .n/ D T .7n=10/ C n.
c. T .n/ D 16T .n=4/ C n2 .
d. T .n/ D 7T .n=3/ C n2 .
e. T .n/ D 7T .n=2/ C n2 .
p
f. T .n/ D 2T .n=4/ C n.
g. T .n/ D T .n  2/ C n2 .
4-2 Parameter-passing costs
Throughout this book, we assume that parameter passing during procedure calls
takes constant time, even if an N -element array is being passed. This assumption
is valid in most systems because a pointer to the array is passed, not the array itself.
This problem examines the implications of three parameter-passing strategies:
1. An array is passed by pointer. Time D ‚.1/.
2. An array is passed by copying. Time D ‚.N /, where N is the size of the array.
3. An array is passed by copying only the subrange that might be accessed by the
called procedure. Time D ‚.q  p C 1/ if the subarray AŒp : : q is passed.
a. Consider the recursive binary search algorithm for ﬁnding a number in a sorted
array (see Exercise 2.3-5). Give recurrences for the worst-case running times
of binary search when arrays are passed using each of the three methods above,
and give good upper bounds on the solutions of the recurrences. Let N be the
size of the original problem and n be the size of a subproblem.
b. Redo part (a) for the M ERGE -S ORT algorithm from Section 2.3.1.

108

Chapter 4 Divide-and-Conquer

4-3 More recurrence examples
Give asymptotic upper and lower bounds for T .n/ in each of the following recurrences. Assume that T .n/ is constant for sufﬁciently small n. Make your bounds
as tight as possible, and justify your answers.
a. T .n/ D 4T .n=3/ C n lg n.
b. T .n/ D 3T .n=3/ C n= lg n.
p
c. T .n/ D 4T .n=2/ C n2 n.
d. T .n/ D 3T .n=3  2/ C n=2.
e. T .n/ D 2T .n=2/ C n= lg n.
f. T .n/ D T .n=2/ C T .n=4/ C T .n=8/ C n.
g. T .n/ D T .n  1/ C 1=n.
h. T .n/ D T .n  1/ C lg n.
i. T .n/ D T .n  2/ C 1= lg n.
p
p
j. T .n/ D nT . n/ C n.
4-4 Fibonacci numbers
This problem develops properties of the Fibonacci numbers, which are deﬁned
by recurrence (3.22). We shall use the technique of generating functions to solve
the Fibonacci recurrence. Deﬁne the generating function (or formal power series) F as
F .´/ D

1
X

Fi ´i

i D0

D 0 C ´ C ´2 C 2´3 C 3´4 C 5´5 C 8´6 C 13´7 C 21´8 C    ;
where Fi is the ith Fibonacci number.
a. Show that F .´/ D ´ C ´F .´/ C ´2 F .´/.

Problems for Chapter 4

109

b. Show that
F .´/ D
D
D

´
1  ´  ´2
´
y
.1  ´/.1  ´/


1
1
1
;

p
y
5 1  ´ 1  ´

where
p
1C 5
D 1:61803 : : :
D
2
and
p
5
1

D 0:61803 : : : :
y D
2
c. Show that
1
X
1
p . i  yi /´i :
F .´/ D
5
i D0

p
i
D

=
5 for i > 0, rounded to the nearest integer.
d. Use part (c) to proveˇthat
F
i
ˇ
(Hint: Observe that ˇyˇ < 1.)
4-5 Chip testing
Professor Diogenes has n supposedly identical integrated-circuit chips that in principle are capable of testing each other. The professor’s test jig accommodates two
chips at a time. When the jig is loaded, each chip tests the other and reports whether
it is good or bad. A good chip always reports accurately whether the other chip is
good or bad, but the professor cannot trust the answer of a bad chip. Thus, the four
possible outcomes of a test are as follows:
Chip A says
B is good
B is good
B is bad
B is bad

Chip B says
A is good
A is bad
A is good
A is bad

Conclusion
both are good, or both are bad
at least one is bad
at least one is bad
at least one is bad

a. Show that if more than n=2 chips are bad, the professor cannot necessarily determine which chips are good using any strategy based on this kind of pairwise
test. Assume that the bad chips can conspire to fool the professor.

110

Chapter 4 Divide-and-Conquer

b. Consider the problem of ﬁnding a single good chip from among n chips, assuming that more than n=2 of the chips are good. Show that bn=2c pairwise
tests are sufﬁcient to reduce the problem to one of nearly half the size.
c. Show that the good chips can be identiﬁed with ‚.n/ pairwise tests, assuming
that more than n=2 of the chips are good. Give and solve the recurrence that
describes the number of tests.
4-6 Monge arrays
An m n array A of real numbers is a Monge array if for all i, j , k, and l such
that 1  i < k  m and 1  j < l  n, we have
AŒi; j  C AŒk; l  AŒi; l C AŒk; j  :
In other words, whenever we pick two rows and two columns of a Monge array and
consider the four elements at the intersections of the rows and the columns, the sum
of the upper-left and lower-right elements is less than or equal to the sum of the
lower-left and upper-right elements. For example, the following array is Monge:
10
17
24
11
45
36
75

17
22
28
13
44
33
66

13
16
22
6
32
19
51

28
29
34
17
37
21
53

23
23
24
7
23
6
34

a. Prove that an array is Monge if and only if for all i D 1; 2; :::; m  1 and
j D 1; 2; :::; n  1, we have
AŒi; j  C AŒi C 1; j C 1  AŒi; j C 1 C AŒi C 1; j  :
(Hint: For the “if” part, use induction separately on rows and columns.)
b. The following array is not Monge. Change one element in order to make it
Monge. (Hint: Use part (a).)
37
21
53
32
43

23 22 32
6 7 10
34 30 31
13 9 6
21 15 8

Notes for Chapter 4

111

c. Let f .i/ be the index of the column containing the leftmost minimum element
of row i. Prove that f .1/  f .2/      f .m/ for any m n Monge array.
d. Here is a description of a divide-and-conquer algorithm that computes the leftmost minimum element in each row of an m n Monge array A:
Construct a submatrix A0 of A consisting of the even-numbered rows of A.
Recursively determine the leftmost minimum for each row of A0 . Then
compute the leftmost minimum in the odd-numbered rows of A.
Explain how to compute the leftmost minimum in the odd-numbered rows of A
(given that the leftmost minimum of the even-numbered rows is known) in
O.m C n/ time.
e. Write the recurrence describing the running time of the algorithm described in
part (d). Show that its solution is O.m C n log m/.

Chapter notes
Divide-and-conquer as a technique for designing algorithms dates back to at least
1962 in an article by Karatsuba and Ofman [194]. It might have been used well before then, however; according to Heideman, Johnson, and Burrus [163], C. F. Gauss
devised the ﬁrst fast Fourier transform algorithm in 1805, and Gauss’s formulation
breaks the problem into smaller subproblems whose solutions are combined.
The maximum-subarray problem in Section 4.1 is a minor variation on a problem
studied by Bentley [43, Chapter 7].
Strassen’s algorithm [325] caused much excitement when it was published
in 1969. Before then, few imagined the possibility of an algorithm asymptotically
faster than the basic S QUARE -M ATRIX -M ULTIPLY procedure. The asymptotic
upper bound for matrix multiplication has been improved since then. The most
asymptotically efﬁcient algorithm for multiplying n n matrices to date, due to
Coppersmith and Winograd [78], has a running time of O.n2:376 /. The best lower
bound known is just the obvious .n2 / bound (obvious because we must ﬁll in n2
elements of the product matrix).
From a practical point of view, Strassen’s algorithm is often not the method of
choice for matrix multiplication, for four reasons:
1. The constant factor hidden in the ‚.nlg 7 / running time of Strassen’s algorithm is larger than the constant factor in the ‚.n3 /-time S QUARE -M ATRIX M ULTIPLY procedure.
2. When the matrices are sparse, methods tailored for sparse matrices are faster.

112

Chapter 4 Divide-and-Conquer

3. Strassen’s algorithm is not quite as numerically stable as S QUARE -M ATRIX M ULTIPLY. In other words, because of the limited precision of computer arithmetic on noninteger values, larger errors accumulate in Strassen’s algorithm
than in S QUARE -M ATRIX -M ULTIPLY.
4. The submatrices formed at the levels of recursion consume space.
The latter two reasons were mitigated around 1990. Higham [167] demonstrated
that the difference in numerical stability had been overemphasized; although
Strassen’s algorithm is too numerically unstable for some applications, it is within
acceptable limits for others. Bailey, Lee, and Simon [32] discuss techniques for
reducing the memory requirements for Strassen’s algorithm.
In practice, fast matrix-multiplication implementations for dense matrices use
Strassen’s algorithm for matrix sizes above a “crossover point,” and they switch
to a simpler method once the subproblem size reduces to below the crossover
point. The exact value of the crossover point is highly system dependent. Analyses
that count operations but ignore effects from caches and pipelining have produced
crossover points as low as n D 8 (by Higham [167]) or n D 12 (by Huss-Lederman
et al. [186]). D’Alberto and Nicolau [81] developed an adaptive scheme, which
determines the crossover point by benchmarking when their software package is
installed. They found crossover points on various systems ranging from n D 400
to n D 2150, and they could not ﬁnd a crossover point on a couple of systems.
Recurrences were studied as early as 1202 by L. Fibonacci, for whom the Fibonacci numbers are named. A. De Moivre introduced the method of generating
functions (see Problem 4-4) for solving recurrences. The master method is adapted
from Bentley, Haken, and Saxe [44], which provides the extended method justiﬁed
by Exercise 4.6-2. Knuth [209] and Liu [237] show how to solve linear recurrences
using the method of generating functions. Purdom and Brown [287] and Graham,
Knuth, and Patashnik [152] contain extended discussions of recurrence solving.
Several researchers, including Akra and Bazzi [13], Roura [299], Verma [346],
and Yap [360], have given methods for solving more general divide-and-conquer
recurrences than are solved by the master method. We describe the result of Akra
and Bazzi here, as modiﬁed by Leighton [228]. The Akra-Bazzi method works for
recurrences of the form
(
‚.1/
if 1  x  x0 ;
(4.30)
T .x/ D Pk
i D1 ai T .bi x/ C f .x/ if x > x0 ;
where


x  1 is a real number,



x0 is a constant such that x0  1=bi and x0  1=.1  bi / for i D 1; 2; : : : ; k,



ai is a positive constant for i D 1; 2; : : : ; k,

Notes for Chapter 4

113



bi is a constant in the range 0 < bi < 1 for i D 1; 2; : : : ; k,



k  1 is an integer constant, and



f .x/ is a nonnegative function that satisﬁes the polynomial-growth condition: there exist positive constants c1 and c2 such that for all x  1, for
i D 1; 2; : : : ; k, and for all u such that bi x  u  x, we have c1 f .x/ 
f .u/  c2 f .x/. (If jf 0 .x/j is upper-bounded by some polynomial in x, then
f .x/ satisﬁes the polynomial-growth condition. For example, f .x/ D x ˛ lgˇ x
satisﬁes this condition for any real constants ˛ and ˇ.)

Although the master method does not apply to a recurrence such as T .n/ D
T .bn=3c/ C T .b2n=3c/ C O.n/, the Akra-Bazzi method does. To solve the rePk
currence (4.30), we ﬁrst ﬁnd the unique real number p such that i D1 ai bip D 1.
(Such a p always exists.) The solution to the recurrence is then

 
Z x
f .u/
p
du
:
T .n/ D ‚ x 1 C
pC1
1 u
The Akra-Bazzi method can be somewhat difﬁcult to use, but it serves in solving
recurrences that model division of the problem into substantially unequally sized
subproblems. The master method is simpler to use, but it applies only when subproblem sizes are equal.

5

Probabilistic Analysis and Randomized
Algorithms

This chapter introduces probabilistic analysis and randomized algorithms. If you
are unfamiliar with the basics of probability theory, you should read Appendix C,
which reviews this material. We shall revisit probabilistic analysis and randomized
algorithms several times throughout this book.

5.1

The hiring problem
Suppose that you need to hire a new ofﬁce assistant. Your previous attempts at
hiring have been unsuccessful, and you decide to use an employment agency. The
employment agency sends you one candidate each day. You interview that person
and then decide either to hire that person or not. You must pay the employment
agency a small fee to interview an applicant. To actually hire an applicant is more
costly, however, since you must ﬁre your current ofﬁce assistant and pay a substantial hiring fee to the employment agency. You are committed to having, at all times,
the best possible person for the job. Therefore, you decide that, after interviewing
each applicant, if that applicant is better qualiﬁed than the current ofﬁce assistant,
you will ﬁre the current ofﬁce assistant and hire the new applicant. You are willing
to pay the resulting price of this strategy, but you wish to estimate what that price
will be.
The procedure H IRE -A SSISTANT, given below, expresses this strategy for hiring
in pseudocode. It assumes that the candidates for the ofﬁce assistant job are numbered 1 through n. The procedure assumes that you are able to, after interviewing
candidate i, determine whether candidate i is the best candidate you have seen so
far. To initialize, the procedure creates a dummy candidate, numbered 0, who is
less qualiﬁed than each of the other candidates.

5.1 The hiring problem

115

H IRE -A SSISTANT .n/
1 best D 0
// candidate 0 is a least-qualiﬁed dummy candidate
2 for i D 1 to n
3
interview candidate i
4
if candidate i is better than candidate best
5
best D i
6
hire candidate i
The cost model for this problem differs from the model described in Chapter 2.
We focus not on the running time of H IRE -A SSISTANT, but instead on the costs
incurred by interviewing and hiring. On the surface, analyzing the cost of this algorithm may seem very different from analyzing the running time of, say, merge sort.
The analytical techniques used, however, are identical whether we are analyzing
cost or running time. In either case, we are counting the number of times certain
basic operations are executed.
Interviewing has a low cost, say ci , whereas hiring is expensive, costing ch . Letting m be the number of people hired, the total cost associated with this algorithm
is O.ci n C ch m/. No matter how many people we hire, we always interview n
candidates and thus always incur the cost ci n associated with interviewing. We
therefore concentrate on analyzing ch m, the hiring cost. This quantity varies with
each run of the algorithm.
This scenario serves as a model for a common computational paradigm. We often need to ﬁnd the maximum or minimum value in a sequence by examining each
element of the sequence and maintaining a current “winner.” The hiring problem
models how often we update our notion of which element is currently winning.
Worst-case analysis
In the worst case, we actually hire every candidate that we interview. This situation
occurs if the candidates come in strictly increasing order of quality, in which case
we hire n times, for a total hiring cost of O.ch n/.
Of course, the candidates do not always come in increasing order of quality. In
fact, we have no idea about the order in which they arrive, nor do we have any
control over this order. Therefore, it is natural to ask what we expect to happen in
a typical or average case.
Probabilistic analysis
Probabilistic analysis is the use of probability in the analysis of problems. Most
commonly, we use probabilistic analysis to analyze the running time of an algorithm. Sometimes we use it to analyze other quantities, such as the hiring cost

116

Chapter 5 Probabilistic Analysis and Randomized Algorithms

in procedure H IRE -A SSISTANT. In order to perform a probabilistic analysis, we
must use knowledge of, or make assumptions about, the distribution of the inputs.
Then we analyze our algorithm, computing an average-case running time, where
we take the average over the distribution of the possible inputs. Thus we are, in
effect, averaging the running time over all possible inputs. When reporting such a
running time, we will refer to it as the average-case running time.
We must be very careful in deciding on the distribution of inputs. For some
problems, we may reasonably assume something about the set of all possible inputs, and then we can use probabilistic analysis as a technique for designing an
efﬁcient algorithm and as a means for gaining insight into a problem. For other
problems, we cannot describe a reasonable input distribution, and in these cases
we cannot use probabilistic analysis.
For the hiring problem, we can assume that the applicants come in a random
order. What does that mean for this problem? We assume that we can compare
any two candidates and decide which one is better qualiﬁed; that is, there is a
total order on the candidates. (See Appendix B for the deﬁnition of a total order.) Thus, we can rank each candidate with a unique number from 1 through n,
using rank.i/ to denote the rank of applicant i, and adopt the convention that a
higher rank corresponds to a better qualiﬁed applicant. The ordered list hrank.1/;
rank.2/; : : : ; rank.n/i is a permutation of the list h1; 2; : : : ; ni. Saying that the
applicants come in a random order is equivalent to saying that this list of ranks is
equally likely to be any one of the nŠ permutations of the numbers 1 through n.
Alternatively, we say that the ranks form a uniform random permutation; that is,
each of the possible nŠ permutations appears with equal probability.
Section 5.2 contains a probabilistic analysis of the hiring problem.
Randomized algorithms
In order to use probabilistic analysis, we need to know something about the distribution of the inputs. In many cases, we know very little about the input distribution.
Even if we do know something about the distribution, we may not be able to model
this knowledge computationally. Yet we often can use probability and randomness
as a tool for algorithm design and analysis, by making the behavior of part of the
algorithm random.
In the hiring problem, it may seem as if the candidates are being presented to us
in a random order, but we have no way of knowing whether or not they really are.
Thus, in order to develop a randomized algorithm for the hiring problem, we must
have greater control over the order in which we interview the candidates. We will,
therefore, change the model slightly. We say that the employment agency has n
candidates, and they send us a list of the candidates in advance. On each day, we
choose, randomly, which candidate to interview. Although we know nothing about

5.1 The hiring problem

117

the candidates (besides their names), we have made a signiﬁcant change. Instead
of relying on a guess that the candidates come to us in a random order, we have
instead gained control of the process and enforced a random order.
More generally, we call an algorithm randomized if its behavior is determined
not only by its input but also by values produced by a random-number generator. We shall assume that we have at our disposal a random-number generator
R ANDOM. A call to R ANDOM.a; b/ returns an integer between a and b, inclusive, with each such integer being equally likely. For example, R ANDOM.0; 1/
produces 0 with probability 1=2, and it produces 1 with probability 1=2. A call to
R ANDOM.3; 7/ returns either 3, 4, 5, 6, or 7, each with probability 1=5. Each integer returned by R ANDOM is independent of the integers returned on previous calls.
You may imagine R ANDOM as rolling a .b  a C 1/-sided die to obtain its output. (In practice, most programming environments offer a pseudorandom-number
generator: a deterministic algorithm returning numbers that “look” statistically
random.)
When analyzing the running time of a randomized algorithm, we take the expectation of the running time over the distribution of values returned by the random
number generator. We distinguish these algorithms from those in which the input
is random by referring to the running time of a randomized algorithm as an expected running time. In general, we discuss the average-case running time when
the probability distribution is over the inputs to the algorithm, and we discuss the
expected running time when the algorithm itself makes random choices.
Exercises
5.1-1
Show that the assumption that we are always able to determine which candidate is
best, in line 4 of procedure H IRE -A SSISTANT, implies that we know a total order
on the ranks of the candidates.
5.1-2 ?
Describe an implementation of the procedure R ANDOM.a; b/ that only makes calls
to R ANDOM.0; 1/. What is the expected running time of your procedure, as a
function of a and b?
5.1-3 ?
Suppose that you want to output 0 with probability 1=2 and 1 with probability 1=2.
At your disposal is a procedure B IASED -R ANDOM , that outputs either 0 or 1. It
outputs 1 with some probability p and 0 with probability 1  p, where 0 < p < 1,
but you do not know what p is. Give an algorithm that uses B IASED -R ANDOM
as a subroutine, and returns an unbiased answer, returning 0 with probability 1=2

118

Chapter 5 Probabilistic Analysis and Randomized Algorithms

and 1 with probability 1=2. What is the expected running time of your algorithm
as a function of p?

5.2

Indicator random variables
In order to analyze many algorithms, including the hiring problem, we use indicator
random variables. Indicator random variables provide a convenient method for
converting between probabilities and expectations. Suppose we are given a sample
space S and an event A. Then the indicator random variable I fAg associated with
event A is deﬁned as
(
1 if A occurs ;
I fAg D
(5.1)
0 if A does not occur :
As a simple example, let us determine the expected number of heads that we
obtain when ﬂipping a fair coin. Our sample space is S D fH; T g, with Pr fH g D
Pr fT g D 1=2. We can then deﬁne an indicator random variable XH , associated
with the coin coming up heads, which is the event H . This variable counts the
number of heads obtained in this ﬂip, and it is 1 if the coin comes up heads and 0
otherwise. We write
XH

D I fH g
(
1 if H occurs ;
D
0 if T occurs :

The expected number of heads obtained in one ﬂip of the coin is simply the expected value of our indicator variable XH :
E ŒXH  D
D
D
D

E ŒI fH g
1  Pr fH g C 0  Pr fT g
1  .1=2/ C 0  .1=2/
1=2 :

Thus the expected number of heads obtained by one ﬂip of a fair coin is 1=2. As
the following lemma shows, the expected value of an indicator random variable
associated with an event A is equal to the probability that A occurs.
Lemma 5.1
Given a sample space S and an event A in the sample space S, let XA D I fAg.
Then E ŒXA  D Pr fAg.

5.2 Indicator random variables

119

Proof By the deﬁnition of an indicator random variable from equation (5.1) and
the deﬁnition of expected value, we have
E ŒXA  D E ŒI fAg
˚
D 1  Pr fAg C 0  Pr A
D Pr fAg ;
where A denotes S  A, the complement of A.
Although indicator random variables may seem cumbersome for an application
such as counting the expected number of heads on a ﬂip of a single coin, they are
useful for analyzing situations in which we perform repeated random trials. For
example, indicator random variables give us a simple way to arrive at the result
of equation (C.37). In this equation, we compute the number of heads in n coin
ﬂips by considering separately the probability of obtaining 0 heads, 1 head, 2 heads,
etc. The simpler method proposed in equation (C.38) instead uses indicator random
variables implicitly. Making this argument more explicit, we let Xi be the indicator
random variable associated with the event in which the ith ﬂip comes up heads:
Xi D I fthe ith ﬂip results in the event H g. Let X be the random variable denoting
the total number of heads in the n coin ﬂips, so that
XD

n
X

Xi :

i D1

We wish to compute the expected number of heads, and so we take the expectation
of both sides of the above equation to obtain
#
" n
X
Xi :
E ŒX  D E
i D1

The above equation gives the expectation of the sum of n indicator random variables. By Lemma 5.1, we can easily compute the expectation of each of the random
variables. By equation (C.21)—linearity of expectation—it is easy to compute the
expectation of the sum: it equals the sum of the expectations of the n random
variables. Linearity of expectation makes the use of indicator random variables a
powerful analytical technique; it applies even when there is dependence among the
random variables. We now can easily compute the expected number of heads:

120

Chapter 5 Probabilistic Analysis and Randomized Algorithms

E ŒX  D E

" n
X

#
Xi

i D1

D

n
X

E ŒXi 

i D1

D

n
X

1=2

i D1

D n=2 :
Thus, compared to the method used in equation (C.37), indicator random variables
greatly simplify the calculation. We shall use indicator random variables throughout this book.
Analysis of the hiring problem using indicator random variables
Returning to the hiring problem, we now wish to compute the expected number of
times that we hire a new ofﬁce assistant. In order to use a probabilistic analysis, we
assume that the candidates arrive in a random order, as discussed in the previous
section. (We shall see in Section 5.3 how to remove this assumption.) Let X be the
random variable whose value equals the number of times we hire a new ofﬁce assistant. We could then apply the deﬁnition of expected value from equation (C.20)
to obtain
E ŒX  D

n
X

x Pr fX D xg ;

xD1

but this calculation would be cumbersome. We shall instead use indicator random
variables to greatly simplify the calculation.
To use indicator random variables, instead of computing E ŒX  by deﬁning one
variable associated with the number of times we hire a new ofﬁce assistant, we
deﬁne n variables related to whether or not each particular candidate is hired. In
particular, we let Xi be the indicator random variable associated with the event in
which the ith candidate is hired. Thus,
Xi

D I fcandidate i is hiredg
(
1 if candidate i is hired ;
D
0 if candidate i is not hired ;

and
X D X1 C X2 C    C Xn :

(5.2)

5.2 Indicator random variables

121

By Lemma 5.1, we have that
E ŒXi  D Pr fcandidate i is hiredg ;
and we must therefore compute the probability that lines 5–6 of H IRE -A SSISTANT
are executed.
Candidate i is hired, in line 6, exactly when candidate i is better than each of
candidates 1 through i  1. Because we have assumed that the candidates arrive in
a random order, the ﬁrst i candidates have appeared in a random order. Any one of
these ﬁrst i candidates is equally likely to be the best-qualiﬁed so far. Candidate i
has a probability of 1=i of being better qualiﬁed than candidates 1 through i  1
and thus a probability of 1=i of being hired. By Lemma 5.1, we conclude that
E ŒXi  D 1=i :

(5.3)

Now we can compute E ŒX :
#
" n
X
Xi
(by equation (5.2))
E ŒX  D E

(5.4)

i D1

D

n
X

E ŒXi 

(by linearity of expectation)

1=i

(by equation (5.3))

i D1

D

n
X
i D1

D ln n C O.1/ (by equation (A.7)) .

(5.5)

Even though we interview n people, we actually hire only approximately ln n of
them, on average. We summarize this result in the following lemma.
Lemma 5.2
Assuming that the candidates are presented in a random order, algorithm H IRE A SSISTANT has an average-case total hiring cost of O.ch ln n/.
Proof The bound follows immediately from our deﬁnition of the hiring cost
and equation (5.5), which shows that the expected number of hires is approximately ln n.
The average-case hiring cost is a signiﬁcant improvement over the worst-case
hiring cost of O.ch n/.

122

Chapter 5 Probabilistic Analysis and Randomized Algorithms

Exercises
5.2-1
In H IRE -A SSISTANT, assuming that the candidates are presented in a random order, what is the probability that you hire exactly one time? What is the probability
that you hire exactly n times?
5.2-2
In H IRE -A SSISTANT, assuming that the candidates are presented in a random order, what is the probability that you hire exactly twice?
5.2-3
Use indicator random variables to compute the expected value of the sum of n dice.
5.2-4
Use indicator random variables to solve the following problem, which is known as
the hat-check problem. Each of n customers gives a hat to a hat-check person at a
restaurant. The hat-check person gives the hats back to the customers in a random
order. What is the expected number of customers who get back their own hat?
5.2-5
Let AŒ1 : : n be an array of n distinct numbers. If i < j and AŒi > AŒj , then
the pair .i; j / is called an inversion of A. (See Problem 2-4 for more on inversions.) Suppose that the elements of A form a uniform random permutation of
h1; 2; : : : ; ni. Use indicator random variables to compute the expected number of
inversions.

5.3

Randomized algorithms
In the previous section, we showed how knowing a distribution on the inputs can
help us to analyze the average-case behavior of an algorithm. Many times, we do
not have such knowledge, thus precluding an average-case analysis. As mentioned
in Section 5.1, we may be able to use a randomized algorithm.
For a problem such as the hiring problem, in which it is helpful to assume that
all permutations of the input are equally likely, a probabilistic analysis can guide
the development of a randomized algorithm. Instead of assuming a distribution
of inputs, we impose a distribution. In particular, before running the algorithm,
we randomly permute the candidates in order to enforce the property that every
permutation is equally likely. Although we have modiﬁed the algorithm, we still
expect to hire a new ofﬁce assistant approximately ln n times. But now we expect

5.3 Randomized algorithms

123

this to be the case for any input, rather than for inputs drawn from a particular
distribution.
Let us further explore the distinction between probabilistic analysis and randomized algorithms. In Section 5.2, we claimed that, assuming that the candidates arrive in a random order, the expected number of times we hire a new ofﬁce assistant
is about ln n. Note that the algorithm here is deterministic; for any particular input,
the number of times a new ofﬁce assistant is hired is always the same. Furthermore,
the number of times we hire a new ofﬁce assistant differs for different inputs, and it
depends on the ranks of the various candidates. Since this number depends only on
the ranks of the candidates, we can represent a particular input by listing, in order,
the ranks of the candidates, i.e., hrank.1/; rank.2/; : : : ; rank.n/i. Given the rank
list A1 D h1; 2; 3; 4; 5; 6; 7; 8; 9; 10i, a new ofﬁce assistant is always hired 10 times,
since each successive candidate is better than the previous one, and lines 5–6 are
executed in each iteration. Given the list of ranks A2 D h10; 9; 8; 7; 6; 5; 4; 3; 2; 1i,
a new ofﬁce assistant is hired only once, in the ﬁrst iteration. Given a list of ranks
A3 D h5; 2; 1; 8; 4; 7; 10; 9; 3; 6i, a new ofﬁce assistant is hired three times,
upon interviewing the candidates with ranks 5, 8, and 10. Recalling that the cost
of our algorithm depends on how many times we hire a new ofﬁce assistant, we
see that there are expensive inputs such as A1 , inexpensive inputs such as A2 , and
moderately expensive inputs such as A3 .
Consider, on the other hand, the randomized algorithm that ﬁrst permutes the
candidates and then determines the best candidate. In this case, we randomize in
the algorithm, not in the input distribution. Given a particular input, say A3 above,
we cannot say how many times the maximum is updated, because this quantity
differs with each run of the algorithm. The ﬁrst time we run the algorithm on A3 ,
it may produce the permutation A1 and perform 10 updates; but the second time
we run the algorithm, we may produce the permutation A2 and perform only one
update. The third time we run it, we may perform some other number of updates.
Each time we run the algorithm, the execution depends on the random choices
made and is likely to differ from the previous execution of the algorithm. For this
algorithm and many other randomized algorithms, no particular input elicits its
worst-case behavior. Even your worst enemy cannot produce a bad input array,
since the random permutation makes the input order irrelevant. The randomized
algorithm performs badly only if the random-number generator produces an “unlucky” permutation.
For the hiring problem, the only change needed in the code is to randomly permute the array.

124

Chapter 5 Probabilistic Analysis and Randomized Algorithms

R ANDOMIZED -H IRE -A SSISTANT .n/
1 randomly permute the list of candidates
2 best D 0
// candidate 0 is a least-qualiﬁed dummy candidate
3 for i D 1 to n
4
interview candidate i
5
if candidate i is better than candidate best
6
best D i
7
hire candidate i
With this simple change, we have created a randomized algorithm whose performance matches that obtained by assuming that the candidates were presented in a
random order.
Lemma 5.3
The expected hiring cost of the procedure R ANDOMIZED -H IRE -A SSISTANT is
O.ch ln n/.
Proof After permuting the input array, we have achieved a situation identical to
that of the probabilistic analysis of H IRE -A SSISTANT.
Comparing Lemmas 5.2 and 5.3 highlights the difference between probabilistic
analysis and randomized algorithms. In Lemma 5.2, we make an assumption about
the input. In Lemma 5.3, we make no such assumption, although randomizing the
input takes some additional time. To remain consistent with our terminology, we
couched Lemma 5.2 in terms of the average-case hiring cost and Lemma 5.3 in
terms of the expected hiring cost. In the remainder of this section, we discuss some
issues involved in randomly permuting inputs.
Randomly permuting arrays
Many randomized algorithms randomize the input by permuting the given input
array. (There are other ways to use randomization.) Here, we shall discuss two
methods for doing so. We assume that we are given an array A which, without loss
of generality, contains the elements 1 through n. Our goal is to produce a random
permutation of the array.
One common method is to assign each element AŒi of the array a random priority P Œi, and then sort the elements of A according to these priorities. For example, if our initial array is A D h1; 2; 3; 4i and we choose random priorities
P D h36; 3; 62; 19i, we would produce an array B D h2; 4; 1; 3i, since the second
priority is the smallest, followed by the fourth, then the ﬁrst, and ﬁnally the third.
We call this procedure P ERMUTE -B Y-S ORTING :

5.3 Randomized algorithms

125

P ERMUTE -B Y-S ORTING .A/
1 n D A:length
2 let P Œ1 : : n be a new array
3 for i D 1 to n
4
P Œi D R ANDOM.1; n3 /
5 sort A, using P as sort keys
Line 4 chooses a random number between 1 and n3 . We use a range of 1 to n3
to make it likely that all the priorities in P are unique. (Exercise 5.3-5 asks you
to prove that the probability that all entries are unique is at least 1  1=n, and
Exercise 5.3-6 asks how to implement the algorithm even if two or more priorities
are identical.) Let us assume that all the priorities are unique.
The time-consuming step in this procedure is the sorting in line 5. As we shall
see in Chapter 8, if we use a comparison sort, sorting takes .n lg n/ time. We
can achieve this lower bound, since we have seen that merge sort takes ‚.n lg n/
time. (We shall see other comparison sorts that take ‚.n lg n/ time in Part II.
Exercise 8.3-4 asks you to solve the very similar problem of sorting numbers in the
range 0 to n3  1 in O.n/ time.) After sorting, if P Œi is the j th smallest priority,
then AŒi lies in position j of the output. In this manner we obtain a permutation. It
remains to prove that the procedure produces a uniform random permutation, that
is, that the procedure is equally likely to produce every permutation of the numbers
1 through n.
Lemma 5.4
Procedure P ERMUTE - BY-S ORTING produces a uniform random permutation of the
input, assuming that all priorities are distinct.
Proof We start by considering the particular permutation in which each element AŒi receives the ith smallest priority. We shall show that this permutation
occurs with probability exactly 1=nŠ. For i D 1; 2; : : : ; n, let Ei be the event
that element AŒi receives the ith smallest priority. Then we wish to compute the
probability that for all i, event Ei occurs, which is
Pr fE1 \ E2 \ E3 \    \ En1 \ En g :
Using Exercise C.2-5, this probability is equal to
Pr fE1 g  Pr fE2 j E1 g  Pr fE3 j E2 \ E1 g  Pr fE4 j E3 \ E2 \ E1 g
   Pr fEi j Ei 1 \ Ei 2 \    \ E1 g    Pr fEn j En1 \    \ E1 g :
We have that Pr fE1 g D 1=n because it is the probability that one priority
chosen randomly out of a set of n is the smallest priority. Next, we observe

126

Chapter 5 Probabilistic Analysis and Randomized Algorithms

that Pr fE2 j E1 g D 1=.n  1/ because given that element AŒ1 has the smallest priority, each of the remaining n  1 elements has an equal chance of having the second smallest priority. In general, for i D 2; 3; : : : ; n, we have that
Pr fEi j Ei 1 \ Ei 2 \    \ E1 g D 1=.n  i C 1/, since, given that elements AŒ1
through AŒi  1 have the i  1 smallest priorities (in order), each of the remaining
n  .i  1/ elements has an equal chance of having the ith smallest priority. Thus,
we have
   
 
1
1
1
1

Pr fE1 \ E2 \ E3 \    \ En1 \ En g D
n
n1
2
1
1
;
D
nŠ
and we have shown that the probability of obtaining the identity permutation
is 1=nŠ.
We can extend this proof to work for any permutation of priorities. Consider
any ﬁxed permutation D h .1/; .2/; : : : ; .n/i of the set f1; 2; : : : ; ng. Let us
denote by ri the rank of the priority assigned to element AŒi, where the element
with the j th smallest priority has rank j . If we deﬁne Ei as the event in which
element AŒi receives the .i /th smallest priority, or ri D .i /, the same proof
still applies. Therefore, if we calculate the probability of obtaining any particular
permutation, the calculation is identical to the one above, so that the probability of
obtaining this permutation is also 1=nŠ.
You might think that to prove that a permutation is a uniform random permutation, it sufﬁces to show that, for each element AŒi, the probability that the element
winds up in position j is 1=n. Exercise 5.3-4 shows that this weaker condition is,
in fact, insufﬁcient.
A better method for generating a random permutation is to permute the given
array in place. The procedure R ANDOMIZE -I N -P LACE does so in O.n/ time. In
its ith iteration, it chooses the element AŒi randomly from among elements AŒi
through AŒn. Subsequent to the ith iteration, AŒi is never altered.
R ANDOMIZE -I N -P LACE .A/
1 n D A:length
2 for i D 1 to n
3
swap AŒi with AŒR ANDOM.i; n/
We shall use a loop invariant to show that procedure R ANDOMIZE -I N -P LACE
produces a uniform random permutation. A k-permutation on a set of n elements is a sequence containing k of the n elements, with no repetitions. (See
Appendix C.) There are nŠ=.n  k/Š such possible k-permutations.

5.3 Randomized algorithms

127

Lemma 5.5
Procedure R ANDOMIZE -I N -P LACE computes a uniform random permutation.
Proof

We use the following loop invariant:

Just prior to the ith iteration of the for loop of lines 2–3, for each possible
.i  1/-permutation of the n elements, the subarray AŒ1 : : i  1 contains
this .i  1/-permutation with probability .n  i C 1/Š=nŠ.
We need to show that this invariant is true prior to the ﬁrst loop iteration, that each
iteration of the loop maintains the invariant, and that the invariant provides a useful
property to show correctness when the loop terminates.
Initialization: Consider the situation just before the ﬁrst loop iteration, so that
i D 1. The loop invariant says that for each possible 0-permutation, the subarray AŒ1 : : 0 contains this 0-permutation with probability .n  i C 1/Š=nŠ D
nŠ=nŠ D 1. The subarray AŒ1 : : 0 is an empty subarray, and a 0-permutation
has no elements. Thus, AŒ1 : : 0 contains any 0-permutation with probability 1,
and the loop invariant holds prior to the ﬁrst iteration.
Maintenance: We assume that just before the ith iteration, each possible
.i  1/-permutation appears in the subarray AŒ1 : : i  1 with probability
.n  i C 1/Š=nŠ, and we shall show that after the ith iteration, each possible
i-permutation appears in the subarray AŒ1 : : i with probability .n  i/Š=nŠ.
Incrementing i for the next iteration then maintains the loop invariant.
Let us examine the ith iteration. Consider a particular i-permutation, and denote the elements in it by hx1 ; x2 ; : : : ; xi i. This permutation consists of an
.i  1/-permutation hx1 ; : : : ; xi 1 i followed by the value xi that the algorithm
places in AŒi. Let E1 denote the event in which the ﬁrst i  1 iterations have
created the particular .i  1/-permutation hx1 ; : : : ; xi 1 i in AŒ1 : : i  1. By the
loop invariant, Pr fE1 g D .n  i C 1/Š=nŠ. Let E2 be the event that ith iteration
puts xi in position AŒi. The i-permutation hx1 ; : : : ; xi i appears in AŒ1 : : i precisely when both E1 and E2 occur, and so we wish to compute Pr fE2 \ E1 g.
Using equation (C.14), we have
Pr fE2 \ E1 g D Pr fE2 j E1 g Pr fE1 g :
The probability Pr fE2 j E1 g equals 1=.ni C1/ because in line 3 the algorithm
chooses xi randomly from the n  i C 1 values in positions AŒi : : n. Thus, we
have

128

Chapter 5 Probabilistic Analysis and Randomized Algorithms

Pr fE2 \ E1 g D Pr fE2 j E1 g Pr fE1 g
.n  i C 1/Š
1

D
ni C1
nŠ
.n  i/Š
:
D
nŠ
Termination: At termination, i D n C 1, and we have that the subarray AŒ1 : : n
is a given n-permutation with probability .n.nC1/C1/=nŠ D 0Š=nŠ D 1=nŠ.
Thus, R ANDOMIZE -I N -P LACE produces a uniform random permutation.
A randomized algorithm is often the simplest and most efﬁcient way to solve a
problem. We shall use randomized algorithms occasionally throughout this book.
Exercises
5.3-1
Professor Marceau objects to the loop invariant used in the proof of Lemma 5.5. He
questions whether it is true prior to the ﬁrst iteration. He reasons that we could just
as easily declare that an empty subarray contains no 0-permutations. Therefore,
the probability that an empty subarray contains a 0-permutation should be 0, thus
invalidating the loop invariant prior to the ﬁrst iteration. Rewrite the procedure
R ANDOMIZE -I N -P LACE so that its associated loop invariant applies to a nonempty
subarray prior to the ﬁrst iteration, and modify the proof of Lemma 5.5 for your
procedure.
5.3-2
Professor Kelp decides to write a procedure that produces at random any permutation besides the identity permutation. He proposes the following procedure:
P ERMUTE -W ITHOUT-I DENTITY .A/
1 n D A:length
2 for i D 1 to n  1
3
swap AŒi with AŒR ANDOM.i C 1; n/
Does this code do what Professor Kelp intends?
5.3-3
Suppose that instead of swapping element AŒi with a random element from the
subarray AŒi : : n, we swapped it with a random element from anywhere in the
array:

5.3 Randomized algorithms

129

P ERMUTE -W ITH -A LL .A/
1 n D A:length
2 for i D 1 to n
3
swap AŒi with AŒR ANDOM.1; n/
Does this code produce a uniform random permutation? Why or why not?
5.3-4
Professor Armstrong suggests the following procedure for generating a uniform
random permutation:
P ERMUTE -B Y-C YCLIC .A/
1 n D A:length
2 let BŒ1 : : n be a new array
3 offset D R ANDOM .1; n/
4 for i D 1 to n
5
dest D i C offset
6
if dest > n
7
dest D dest  n
8
BŒdest D AŒi
9 return B
Show that each element AŒi has a 1=n probability of winding up in any particular
position in B. Then show that Professor Armstrong is mistaken by showing that
the resulting permutation is not uniformly random.
5.3-5 ?
Prove that in the array P in procedure P ERMUTE -B Y-S ORTING, the probability
that all elements are unique is at least 1  1=n.
5.3-6
Explain how to implement the algorithm P ERMUTE -B Y-S ORTING to handle the
case in which two or more priorities are identical. That is, your algorithm should
produce a uniform random permutation, even if two or more priorities are identical.
5.3-7
Suppose we want to create a random sample of the set f1; 2; 3; : : : ; ng, that is,
an m-element subset S, where 0  m  n, such that each m-subset is equally
likely to be created. One way would be to set AŒi D i for i D 1; 2; 3; : : : ; n,
call R ANDOMIZE -I N -P LACE .A/, and then take just the ﬁrst m array elements.
This method would make n calls to the R ANDOM procedure. If n is much larger
than m, we can create a random sample with fewer calls to R ANDOM. Show that

130

Chapter 5 Probabilistic Analysis and Randomized Algorithms

the following recursive procedure returns a random m-subset S of f1; 2; 3; : : : ; ng,
in which each m-subset is equally likely, while making only m calls to R ANDOM:
R ANDOM -S AMPLE .m; n/
1 if m == 0
2
return ;
3 else S D R ANDOM -S AMPLE .m  1; n  1/
4
i D R ANDOM.1; n/
5
if i 2 S
6
S D S [ fng
7
else S D S [ fig
8
return S

? 5.4 Probabilistic analysis and further uses of indicator random variables
This advanced section further illustrates probabilistic analysis by way of four examples. The ﬁrst determines the probability that in a room of k people, two of
them share the same birthday. The second example examines what happens when
we randomly toss balls into bins. The third investigates “streaks” of consecutive
heads when we ﬂip coins. The ﬁnal example analyzes a variant of the hiring problem in which you have to make decisions without actually interviewing all the
candidates.
5.4.1

The birthday paradox

Our ﬁrst example is the birthday paradox. How many people must there be in a
room before there is a 50% chance that two of them were born on the same day of
the year? The answer is surprisingly few. The paradox is that it is in fact far fewer
than the number of days in a year, or even half the number of days in a year, as we
shall see.
To answer this question, we index the people in the room with the integers
1; 2; : : : ; k, where k is the number of people in the room. We ignore the issue
of leap years and assume that all years have n D 365 days. For i D 1; 2; : : : ; k,
let bi be the day of the year on which person i’s birthday falls, where 1  bi  n.
We also assume that birthdays are uniformly distributed across the n days of the
year, so that Pr fbi D rg D 1=n for i D 1; 2; : : : ; k and r D 1; 2; : : : ; n.
The probability that two given people, say i and j , have matching birthdays
depends on whether the random selection of birthdays is independent. We assume
from now on that birthdays are independent, so that the probability that i’s birthday

5.4 Probabilistic analysis and further uses of indicator random variables

131

and j ’s birthday both fall on day r is
Pr fbi D r and bj D rg D Pr fbi D rg Pr fbj D rg
D 1=n2 :
Thus, the probability that they both fall on the same day is
Pr fbi D bj g D
D

n
X
rD1
n
X

Pr fbi D r and bj D rg
.1=n2 /

rD1

D 1=n :

(5.6)

More intuitively, once bi is chosen, the probability that bj is chosen to be the same
day is 1=n. Thus, the probability that i and j have the same birthday is the same
as the probability that the birthday of one of them falls on a given day. Notice,
however, that this coincidence depends on the assumption that the birthdays are
independent.
We can analyze the probability of at least 2 out of k people having matching
birthdays by looking at the complementary event. The probability that at least two
of the birthdays match is 1 minus the probability that all the birthdays are different.
The event that k people have distinct birthdays is
Bk D

k
\

Ai ;

i D1

where Ai is the event that person i’s birthday is different from person j ’s for
all j < i. Since we can write Bk D Ak \ Bk1 , we obtain from equation (C.16)
the recurrence
Pr fBk g D Pr fBk1 g Pr fAk j Bk1 g ;

(5.7)

where we take Pr fB1 g D Pr fA1 g D 1 as an initial condition. In other words,
the probability that b1 ; b2 ; : : : ; bk are distinct birthdays is the probability that
b1 ; b2 ; : : : ; bk1 are distinct birthdays times the probability that bk ¤ bi for
i D 1; 2; : : : ; k  1, given that b1 ; b2 ; : : : ; bk1 are distinct.
If b1 ; b2 ; : : : ; bk1 are distinct, the conditional probability that bk ¤ bi for
i D 1; 2; : : : ; k  1 is Pr fAk j Bk1 g D .n  k C 1/=n, since out of the n days,
n  .k  1/ days are not taken. We iteratively apply the recurrence (5.7) to obtain

132

Chapter 5 Probabilistic Analysis and Randomized Algorithms

Pr fBk g D Pr fBk1 g Pr fAk j Bk1 g
D Pr fBk2 g Pr fAk1 j Bk2 g Pr fAk j Bk1 g
::
:
D Pr fB1 g Pr fA2 j B1 g Pr fA3 j B2 g    Pr fAk j Bk1 g

 


n2
nkC1
n1
D 1

n
n
n

 


2
k1
1
1
 1 
:
D 1 1
n
n
n
Inequality (3.12), 1 C x  e x , gives us
Pr fBk g  e 1=n e 2=n    e .k1/=n
Pk1

D e  i D1 i=n
D e k.k1/=2n
 1=2
when k.k  1/=2n  ln.1=2/. The probability that all k birthdays are distinct
is at most 1=2
p when k.k  1/  2n ln 2 or, solving the quadratic equation, when
k  .1 C 1 C .8 ln 2/n/=2. For n D 365, we must have k  23. Thus, if at
least 23 people are in a room, the probability is at least 1=2 that at least two people
have the same birthday. On Mars, a year is 669 Martian days long; it therefore
takes 31 Martians to get the same effect.
An analysis using indicator random variables
We can use indicator random variables to provide a simpler but approximate analysis of the birthday paradox. For each pair .i; j / of the k people in the room, we
deﬁne the indicator random variable Xij , for 1  i < j  k, by
Xij

D I fperson i and person j have the same birthdayg
(
1 if person i and person j have the same birthday ;
D
0 otherwise :

By equation (5.6), the probability that two people have matching birthdays is 1=n,
and thus by Lemma 5.1, we have
E ŒXij  D Pr fperson i and person j have the same birthdayg
D 1=n :
Letting X be the random variable that counts the number of pairs of individuals
having the same birthday, we have

5.4 Probabilistic analysis and further uses of indicator random variables

XD

k
k
X
X

133

Xij :

i D1 j Di C1

Taking expectations of both sides and applying linearity of expectation, we obtain
" k
#
k
X X
E ŒX  D E
Xij
i D1 j Di C1

D

k
X

k
X

E ŒXij 

i D1 j Di C1

D
D

!
k 1
2 n

k.k  1/
:
2n

When k.k  1/  2n, therefore, the expected number
p of pairs of people with the
same birthday is at least 1. Thus, if we have at least 2nC1 individuals in a room,
we can expect at least two to have the same birthday. For n D 365, if k D 28, the
expected number of pairs with the same birthday is .28  27/=.2  365/  1:0356.
Thus, with at least 28 people, we expect to ﬁnd at least one matching pair of birthdays. On Mars, where a year is 669 Martian days long, we need at least 38 Martians.
The ﬁrst analysis, which used only probabilities, determined the number of people required for the probability to exceed 1=2 that a matching pair of birthdays
exists, and the second analysis, which used indicator random variables, determined
the number such that the expected number of matching birthdays is 1. Although
the exact numbers
of people differ for the two situations, they are the same asympp
totically: ‚. n/.
5.4.2 Balls and bins
Consider a process in which we randomly toss identical balls into b bins, numbered
1; 2; : : : ; b. The tosses are independent, and on each toss the ball is equally likely
to end up in any bin. The probability that a tossed ball lands in any given bin is 1=b.
Thus, the ball-tossing process is a sequence of Bernoulli trials (see Appendix C.4)
with a probability 1=b of success, where success means that the ball falls in the
given bin. This model is particularly useful for analyzing hashing (see Chapter 11),
and we can answer a variety of interesting questions about the ball-tossing process.
(Problem C-1 asks additional questions about balls and bins.)

134

Chapter 5 Probabilistic Analysis and Randomized Algorithms

How many balls fall in a given bin? The number of balls that fall in a given bin
follows the binomial distribution b.kI n; 1=b/. If we toss n balls, equation (C.37)
tells us that the expected number of balls that fall in the given bin is n=b.
How many balls must we toss, on the average, until a given bin contains a ball?
The number of tosses until the given bin receives a ball follows the geometric
distribution with probability 1=b and, by equation (C.32), the expected number of
tosses until success is 1=.1=b/ D b.
How many balls must we toss until every bin contains at least one ball? Let us
call a toss in which a ball falls into an empty bin a “hit.” We want to know the
expected number n of tosses required to get b hits.
Using the hits, we can partition the n tosses into stages. The ith stage consists of
the tosses after the .i  1/st hit until the ith hit. The ﬁrst stage consists of the ﬁrst
toss, since we are guaranteed to have a hit when all bins are empty. For each toss
during the ith stage, i  1 bins contain balls and b  i C 1 bins are empty. Thus,
for each toss in the ith stage, the probability of obtaining a hit is .b  i C 1/=b.
Let ni denote the number of tosses in the ith stage. Thus, the number of tosses
Pb
required to get b hits is n D i D1 ni . Each random variable ni has a geometric
distribution with probability of success .b  i C 1/=b and thus, by equation (C.32),
we have
E Œni  D

b
:
bi C1

By linearity of expectation, we have
#
" b
X
ni
E Œn D E
i D1

D

b
X

E Œni 

i D1

D

b
X
i D1

D b

b
bi C1

b
X
1
i D1

i

D b.ln b C O.1// (by equation (A.7)) .
It therefore takes approximately b ln b tosses before we can expect that every bin
has a ball. This problem is also known as the coupon collector’s problem, which
says that a person trying to collect each of b different coupons expects to acquire
approximately b ln b randomly obtained coupons in order to succeed.

5.4 Probabilistic analysis and further uses of indicator random variables

135

5.4.3 Streaks
Suppose you ﬂip a fair coin n times. What is the longest streak of consecutive
heads that you expect to see? The answer is ‚.lg n/, as the following analysis
shows.
We ﬁrst prove that the expected length of the longest streak of heads is O.lg n/.
The probability that each coin ﬂip is a head is 1=2. Let Ai k be the event that a
streak of heads of length at least k begins with the ith coin ﬂip or, more precisely,
the event that the k consecutive coin ﬂips i; i C 1; : : : ; i C k  1 yield only heads,
where 1  k  n and 1  i  nk C1. Since coin ﬂips are mutually independent,
for any given event Ai k , the probability that all k ﬂips are heads is
Pr fAi k g D 1=2k :

(5.8)

For k D 2 dlg ne,
Pr fAi;2dlg ne g D 1=22dlg ne
 1=22 lg n
D 1=n2 ;
and thus the probability that a streak of heads of length at least 2 dlg ne begins in
position i is quite small. There are at most n  2 dlg ne C 1 positions where such
a streak can begin. The probability that a streak of heads of length at least 2 dlg ne
begins anywhere is therefore
)
(n2dlg neC1
n2dlg neC1
[
X
Ai;2dlg ne
1=n2

Pr
i D1

i D1

<

n
X

1=n2

i D1

D 1=n ;

(5.9)

since by Boole’s inequality (C.19), the probability of a union of events is at most
the sum of the probabilities of the individual events. (Note that Boole’s inequality
holds even for events such as these that are not independent.)
We now use inequality (5.9) to bound the length of the longest streak. For
j D 0; 1; 2; : : : ; n, let Lj be the event that the longest streak of heads has length exactly j , and let L be the length of the longest streak. By the deﬁnition of expected
value, we have
E ŒL D

n
X
j D0

j Pr fLj g :

(5.10)

136

Chapter 5 Probabilistic Analysis and Randomized Algorithms

We could try to evaluate this sum using upper bounds on each Pr fLj g similar to
those computed in inequality (5.9). Unfortunately, this method would yield weak
bounds. We can use some intuition gained by the above analysis to obtain a good
bound, however. Informally, we observe that for no individual term in the summation in equation (5.10) are both the factors j and Pr fLj g large. Why? When
j  2 dlg ne, then Pr fLj g is very small, and when j < 2 dlg ne, then j is fairly
small. More formally, we note that the events Lj for j D 0; 1; : : : ; n are disjoint,
and so the
least 2 dlg ne begins anyPprobability that a streak of heads of length at P
where is jnD2dlg ne Pr fLj g. By inequality (5.9), we have jnD2dlg ne Pr fLj g < 1=n.
P2dlg ne1
Pn
Pr fLj g  1. Thus,
Also, noting that j D0 Pr fLj g D 1, we have that j D0
we obtain
E ŒL D

n
X

j Pr fLj g

j D0

X

2dlg ne1

D

j Pr fLj g C

j D0

X

n
X

j Pr fLj g

j D2dlg ne
n
X

2dlg ne1

<

.2 dlg ne/ Pr fLj g C

j D0

j D2dlg ne

X

2dlg ne1

D 2 dlg ne

n Pr fLj g

Pr fLj g C n

j D0

n
X

Pr fLj g

j D2dlg ne

< 2 dlg ne  1 C n  .1=n/
D O.lg n/ :
The probability that a streak of heads exceeds r dlg ne ﬂips diminishes quickly
with r. For r  1, the probability that a streak of at least r dlg ne heads starts in
position i is
Pr fAi;rdlg ne g D 1=2rdlg ne
 1=nr :
Thus, the probability is at most n=nr D 1=nr1 that the longest streak is at
least r dlg ne, or equivalently, the probability is at least 1  1=nr1 that the longest
streak has length less than r dlg ne.
As an example, for n D 1000 coin ﬂips, the probability of having a streak of at
least 2 dlg ne D 20 heads is at most 1=n D 1=1000. The chance of having a streak
longer than 3 dlg ne D 30 heads is at most 1=n2 D 1=1,000,000.
We now prove a complementary lower bound: the expected length of the longest
streak of heads in n coin ﬂips is .lg n/. To prove this bound, we look for streaks

5.4 Probabilistic analysis and further uses of indicator random variables

137

of length s by partitioning the n ﬂips into approximately n=s groups of s ﬂips
each. If we choose s D b.lg n/=2c, we can show that it is likely that at least one
of these groups comes up all heads, and hence it is likely that the longest streak
has length at least s D .lg n/. We then show that the longest streak has expected
length .lg n/.
We partition the n coin ﬂips into at least bn= b.lg n/=2cc groups of b.lg n/=2c
consecutive ﬂips, and we bound the probability that no group comes up all heads.
By equation (5.8), the probability that the group starting in position i comes up all
heads is
Pr fAi;b.lg n/=2c g D 1=2b.lg n/=2c
p
 1= n :
The probability that a streak of heads ofplength at least b.lg n/=2c does not begin
in position i is therefore at most 1  1= n. Since the bn= b.lg n/=2cc groups are
formed from mutually exclusive, independent coin ﬂips, the probability that every
one of these groups fails to be a streak of length b.lg n/=2c is at most
p n=b.lg n/=2c1
p bn=b.lg n/=2cc
 1  1= n
1  1= n
p 2n= lg n1
 1  1= n
 e .2n= lg n1/=
D O.e  lg n /
D O.1=n/ :

p
n

x
For this argument, we used inequality (3.12),
p 1 C x  e , and the fact, which you
might want to verify, that .2n= lg n  1/= n  lg n for sufﬁciently large n.
Thus, the probability that the longest streak exceeds b.lg n/=2c is
n
X

Pr fLj g  1  O.1=n/ :

(5.11)

j Db.lg n/=2cC1

We can now calculate a lower bound on the expected length of the longest streak,
beginning with equation (5.10) and proceeding in a manner similar to our analysis
of the upper bound:

138

Chapter 5 Probabilistic Analysis and Randomized Algorithms

E ŒL D

n
X

j Pr fLj g

j D0

X

n
X

b.lg n/=2c

D

j Pr fLj g C

j D0

X

b.lg n/=2c



0  Pr fLj g C

j D0

n
X

b.lg n/=2c Pr fLj g

j Db.lg n/=2cC1

X

b.lg n/=2c

D 0

j Pr fLj g

j Db.lg n/=2cC1

Pr fLj g C b.lg n/=2c

j D0

 0 C b.lg n/=2c .1  O.1=n//
D .lg n/ :

n
X

Pr fLj g

j Db.lg n/=2cC1

(by inequality (5.11))

As with the birthday paradox, we can obtain a simpler but approximate analysis
using indicator random variables. We let Xi k D I fAi k g be the indicator random
variable associated with a streak of heads of length at least k beginning with the
ith coin ﬂip. To count the total number of such streaks, we deﬁne
XD

nkC1
X

Xi k :

i D1

Taking expectations and using linearity of expectation, we have
#
"nkC1
X
Xi k
E ŒX  D E
i D1

D

nkC1
X

E ŒXi k 

i D1

D

nkC1
X

Pr fAi k g

i D1

D

nkC1
X

1=2k

i D1

nkC1
:
D
2k
By plugging in various values for k, we can calculate the expected number of
streaks of length k. If this number is large (much greater than 1), then we expect
many streaks of length k to occur and the probability that one occurs is high. If

5.4 Probabilistic analysis and further uses of indicator random variables

139

this number is small (much less than 1), then we expect few streaks of length k to
occur and the probability that one occurs is low. If k D c lg n, for some positive
constant c, we obtain
n  c lg n C 1
2c lg n
n  c lg n C 1
D
nc
1
.c lg n  1/=n
D

nc1
nc1
c1
D ‚.1=n / :

E ŒX  D

If c is large, the expected number of streaks of length c lg n is small, and we conclude that they are unlikely to occur. On the other hand, if c D 1=2, then we obtain
E ŒX  D ‚.1=n1=21 / D ‚.n1=2 /, and we expect that there are a large number
of streaks of length .1=2/ lg n. Therefore, one streak of such a length is likely to
occur. From these rough estimates alone, we can conclude that the expected length
of the longest streak is ‚.lg n/.
5.4.4 The on-line hiring problem
As a ﬁnal example, we consider a variant of the hiring problem. Suppose now that
we do not wish to interview all the candidates in order to ﬁnd the best one. We
also do not wish to hire and ﬁre as we ﬁnd better and better applicants. Instead, we
are willing to settle for a candidate who is close to the best, in exchange for hiring
exactly once. We must obey one company requirement: after each interview we
must either immediately offer the position to the applicant or immediately reject the
applicant. What is the trade-off between minimizing the amount of interviewing
and maximizing the quality of the candidate hired?
We can model this problem in the following way. After meeting an applicant,
we are able to give each one a score; let score.i/ denote the score we give to the ith
applicant, and assume that no two applicants receive the same score. After we have
seen j applicants, we know which of the j has the highest score, but we do not
know whether any of the remaining nj applicants will receive a higher score. We
decide to adopt the strategy of selecting a positive integer k < n, interviewing and
then rejecting the ﬁrst k applicants, and hiring the ﬁrst applicant thereafter who has
a higher score than all preceding applicants. If it turns out that the best-qualiﬁed
applicant was among the ﬁrst k interviewed, then we hire the nth applicant. We
formalize this strategy in the procedure O N -L INE -M AXIMUM .k; n/, which returns
the index of the candidate we wish to hire.

140

Chapter 5 Probabilistic Analysis and Randomized Algorithms

O N -L INE -M AXIMUM .k; n/
1 bestscore D 1
2 for i D 1 to k
3
if score.i/ > bestscore
4
bestscore D score.i/
5 for i D k C 1 to n
6
if score.i/ > bestscore
7
return i
8 return n
We wish to determine, for each possible value of k, the probability that we
hire the most qualiﬁed applicant. We then choose the best possible k, and
implement the strategy with that value. For the moment, assume that k is
ﬁxed. Let M.j / D max1i j fscore.i/g denote the maximum score among applicants 1 through j . Let S be the event that we succeed in choosing the bestqualiﬁed applicant, and let Si be the event that we succeed when the best-qualiﬁed
applicant is the
one interviewed. Since the various Si are disjoint, we have
Pith
n
that Pr fSg D i D1 Pr fSi g. Noting that we never succeed when the best-qualiﬁed
applicant is one of the ﬁrst k, we have that Pr fSi g D 0 for i D 1; 2; : : : ; k. Thus,
we obtain
Pr fSg D

n
X

Pr fSi g :

(5.12)

i DkC1

We now compute Pr fSi g. In order to succeed when the best-qualiﬁed applicant
is the ith one, two things must happen. First, the best-qualiﬁed applicant must be
in position i, an event which we denote by Bi . Second, the algorithm must not
select any of the applicants in positions k C 1 through i  1, which happens only if,
for each j such that k C 1  j  i  1, we ﬁnd that score.j / < bestscore in line 6.
(Because scores are unique, we can ignore the possibility of score.j / D bestscore.)
In other words, all of the values score.k C 1/ through score.i  1/ must be less
than M.k/; if any are greater than M.k/, we instead return the index of the ﬁrst
one that is greater. We use Oi to denote the event that none of the applicants in
position k C 1 through i  1 are chosen. Fortunately, the two events Bi and Oi
are independent. The event Oi depends only on the relative ordering of the values
in positions 1 through i  1, whereas Bi depends only on whether the value in
position i is greater than the values in all other positions. The ordering of the
values in positions 1 through i  1 does not affect whether the value in position i
is greater than all of them, and the value in position i does not affect the ordering
of the values in positions 1 through i  1. Thus we can apply equation (C.15) to
obtain

5.4 Probabilistic analysis and further uses of indicator random variables

141

Pr fSi g D Pr fBi \ Oi g D Pr fBi g Pr fOi g :
The probability Pr fBi g is clearly 1=n, since the maximum is equally likely to
be in any one of the n positions. For event Oi to occur, the maximum value in
positions 1 through i 1, which is equally likely to be in any of these i 1 positions,
must be in one of the ﬁrst k positions. Consequently, Pr fOi g D k=.i  1/ and
Pr fSi g D k=.n.i  1//. Using equation (5.12), we have
Pr fSg D

n
X

Pr fSi g

i DkC1
n
X

D

k
n.i  1/
i DkC1

D

n
k X 1
n
i 1
i DkC1

kX1
:
n
i
n1

D

i Dk

We approximate by integrals to bound this summation from above and below. By
the inequalities (A.12), we have
Z n1
Z n
n1
X
1
1
1
dx 

dx :
i
k x
k1 x
i Dk

Evaluating these deﬁnite integrals gives us the bounds
k
k
.ln n  ln k/  Pr fSg  .ln.n  1/  ln.k  1// ;
n
n
which provide a rather tight bound for Pr fSg. Because we wish to maximize our
probability of success, let us focus on choosing the value of k that maximizes the
lower bound on Pr fSg. (Besides, the lower-bound expression is easier to maximize
than the upper-bound expression.) Differentiating the expression .k=n/.ln nln k/
with respect to k, we obtain
1
.ln n  ln k  1/ :
n
Setting this derivative equal to 0, we see that we maximize the lower bound on the
probability when ln k D ln n  1 D ln.n=e/ or, equivalently, when k D n=e. Thus,
if we implement our strategy with k D n=e, we succeed in hiring our best-qualiﬁed
applicant with probability at least 1=e.

142

Chapter 5 Probabilistic Analysis and Randomized Algorithms

Exercises
5.4-1
How many people must there be in a room before the probability that someone
has the same birthday as you do is at least 1=2? How many people must there be
before the probability that at least two people have a birthday on July 4 is greater
than 1=2?
5.4-2
Suppose that we toss balls into b bins until some bin contains two balls. Each toss
is independent, and each ball is equally likely to end up in any bin. What is the
expected number of ball tosses?
5.4-3 ?
For the analysis of the birthday paradox, is it important that the birthdays be mutually independent, or is pairwise independence sufﬁcient? Justify your answer.
5.4-4 ?
How many people should be invited to a party in order to make it likely that there
are three people with the same birthday?
5.4-5 ?
What is the probability that a k-string over a set of size n forms a k-permutation?
How does this question relate to the birthday paradox?
5.4-6 ?
Suppose that n balls are tossed into n bins, where each toss is independent and the
ball is equally likely to end up in any bin. What is the expected number of empty
bins? What is the expected number of bins with exactly one ball?
5.4-7 ?
Sharpen the lower bound on streak length by showing that in n ﬂips of a fair coin,
the probability is less than 1=n that no streak longer than lg n2 lg lg n consecutive
heads occurs.

Problems for Chapter 5

143

Problems
5-1 Probabilistic counting
With a b-bit counter, we can ordinarily only count up to 2b  1. With R. Morris’s
probabilistic counting, we can count up to a much larger value at the expense of
some loss of precision.
We let a counter value of i represent a count of ni for i D 0; 1; : : : ; 2b  1, where
the ni form an increasing sequence of nonnegative values. We assume that the initial value of the counter is 0, representing a count of n0 D 0. The I NCREMENT
operation works on a counter containing the value i in a probabilistic manner. If
i D 2b  1, then the operation reports an overﬂow error. Otherwise, the I NCRE MENT operation increases the counter by 1 with probability 1=.ni C1  ni /, and it
leaves the counter unchanged with probability 1  1=.ni C1  ni /.
If we select ni D i for all i  0, then the counter is an ordinary one. More
interesting situations arise if we select, say, ni D 2i 1 for i > 0 or ni D Fi (the
ith Fibonacci number—see Section 3.2).
For this problem, assume that n2b 1 is large enough that the probability of an
overﬂow error is negligible.
a. Show that the expected value represented by the counter after n I NCREMENT
operations have been performed is exactly n.
b. The analysis of the variance of the count represented by the counter depends
on the sequence of the ni . Let us consider a simple case: ni D 100i for
all i  0. Estimate the variance in the value represented by the register after n
I NCREMENT operations have been performed.
5-2 Searching an unsorted array
This problem examines three algorithms for searching for a value x in an unsorted
array A consisting of n elements.
Consider the following randomized strategy: pick a random index i into A. If
AŒi D x, then we terminate; otherwise, we continue the search by picking a new
random index into A. We continue picking random indices into A until we ﬁnd an
index j such that AŒj  D x or until we have checked every element of A. Note
that we pick from the whole set of indices each time, so that we may examine a
given element more than once.
a. Write pseudocode for a procedure R ANDOM -S EARCH to implement the strategy above. Be sure that your algorithm terminates when all indices into A have
been picked.

144

Chapter 5 Probabilistic Analysis and Randomized Algorithms

b. Suppose that there is exactly one index i such that AŒi D x. What is the
expected number of indices into A that we must pick before we ﬁnd x and
R ANDOM -S EARCH terminates?
c. Generalizing your solution to part (b), suppose that there are k  1 indices i
such that AŒi D x. What is the expected number of indices into A that we
must pick before we ﬁnd x and R ANDOM -S EARCH terminates? Your answer
should be a function of n and k.
d. Suppose that there are no indices i such that AŒi D x. What is the expected
number of indices into A that we must pick before we have checked all elements
of A and R ANDOM -S EARCH terminates?
Now consider a deterministic linear search algorithm, which we refer to as
D ETERMINISTIC -S EARCH. Speciﬁcally, the algorithm searches A for x in order,
considering AŒ1; AŒ2; AŒ3; : : : ; AŒn until either it ﬁnds AŒi D x or it reaches
the end of the array. Assume that all possible permutations of the input array are
equally likely.
e. Suppose that there is exactly one index i such that AŒi D x. What is the
average-case running time of D ETERMINISTIC -S EARCH? What is the worstcase running time of D ETERMINISTIC -S EARCH?
f. Generalizing your solution to part (e), suppose that there are k  1 indices i
such that AŒi D x. What is the average-case running time of D ETERMINISTIC S EARCH? What is the worst-case running time of D ETERMINISTIC -S EARCH?
Your answer should be a function of n and k.
g. Suppose that there are no indices i such that AŒi D x. What is the average-case
running time of D ETERMINISTIC -S EARCH? What is the worst-case running
time of D ETERMINISTIC -S EARCH?
Finally, consider a randomized algorithm S CRAMBLE -S EARCH that works by
ﬁrst randomly permuting the input array and then running the deterministic linear search given above on the resulting permuted array.
h. Letting k be the number of indices i such that AŒi D x, give the worst-case and
expected running times of S CRAMBLE -S EARCH for the cases in which k D 0
and k D 1. Generalize your solution to handle the case in which k  1.
i. Which of the three searching algorithms would you use? Explain your answer.

Notes for Chapter 5

145

Chapter notes
Bollobás [53], Hofri [174], and Spencer [321] contain a wealth of advanced probabilistic techniques. The advantages of randomized algorithms are discussed and
surveyed by Karp [200] and Rabin [288]. The textbook by Motwani and Raghavan
[262] gives an extensive treatment of randomized algorithms.
Several variants of the hiring problem have been widely studied. These problems
are more commonly referred to as “secretary problems.” An example of work in
this area is the paper by Ajtai, Meggido, and Waarts [11].

II

Sorting and Order Statistics

Introduction
This part presents several algorithms that solve the following sorting problem:
Input: A sequence of n numbers ha1 ; a2 ; : : : ; an i.
Output: A permutation (reordering) ha10 ; a20 ; : : : ; an0 i of the input sequence such
that a10  a20      an0 .
The input sequence is usually an n-element array, although it may be represented
in some other fashion, such as a linked list.
The structure of the data
In practice, the numbers to be sorted are rarely isolated values. Each is usually part
of a collection of data called a record. Each record contains a key, which is the
value to be sorted. The remainder of the record consists of satellite data, which are
usually carried around with the key. In practice, when a sorting algorithm permutes
the keys, it must permute the satellite data as well. If each record includes a large
amount of satellite data, we often permute an array of pointers to the records rather
than the records themselves in order to minimize data movement.
In a sense, it is these implementation details that distinguish an algorithm from
a full-blown program. A sorting algorithm describes the method by which we
determine the sorted order, regardless of whether we are sorting individual numbers
or large records containing many bytes of satellite data. Thus, when focusing on the
problem of sorting, we typically assume that the input consists only of numbers.
Translating an algorithm for sorting numbers into a program for sorting records

148

Part II Sorting and Order Statistics

is conceptually straightforward, although in a given engineering situation other
subtleties may make the actual programming task a challenge.
Why sorting?
Many computer scientists consider sorting to be the most fundamental problem in
the study of algorithms. There are several reasons:


Sometimes an application inherently needs to sort information. For example,
in order to prepare customer statements, banks need to sort checks by check
number.



Algorithms often use sorting as a key subroutine. For example, a program that
renders graphical objects which are layered on top of each other might have
to sort the objects according to an “above” relation so that it can draw these
objects from bottom to top. We shall see numerous algorithms in this text that
use sorting as a subroutine.



We can draw from among a wide variety of sorting algorithms, and they employ a rich set of techniques. In fact, many important techniques used throughout algorithm design appear in the body of sorting algorithms that have been
developed over the years. In this way, sorting is also a problem of historical
interest.



We can prove a nontrivial lower bound for sorting (as we shall do in Chapter 8).
Our best upper bounds match the lower bound asymptotically, and so we know
that our sorting algorithms are asymptotically optimal. Moreover, we can use
the lower bound for sorting to prove lower bounds for certain other problems.



Many engineering issues come to the fore when implementing sorting algorithms. The fastest sorting program for a particular situation may depend on
many factors, such as prior knowledge about the keys and satellite data, the
memory hierarchy (caches and virtual memory) of the host computer, and the
software environment. Many of these issues are best dealt with at the algorithmic level, rather than by “tweaking” the code.

Sorting algorithms
We introduced two algorithms that sort n real numbers in Chapter 2. Insertion sort
takes ‚.n2 / time in the worst case. Because its inner loops are tight, however,
it is a fast in-place sorting algorithm for small input sizes. (Recall that a sorting
algorithm sorts in place if only a constant number of elements of the input array are ever stored outside the array.) Merge sort has a better asymptotic running
time, ‚.n lg n/, but the M ERGE procedure it uses does not operate in place.

Part II

Sorting and Order Statistics

149

In this part, we shall introduce two more algorithms that sort arbitrary real numbers. Heapsort, presented in Chapter 6, sorts n numbers in place in O.n lg n/ time.
It uses an important data structure, called a heap, with which we can also implement a priority queue.
Quicksort, in Chapter 7, also sorts n numbers in place, but its worst-case running
time is ‚.n2 /. Its expected running time is ‚.n lg n/, however, and it generally
outperforms heapsort in practice. Like insertion sort, quicksort has tight code, and
so the hidden constant factor in its running time is small. It is a popular algorithm
for sorting large input arrays.
Insertion sort, merge sort, heapsort, and quicksort are all comparison sorts: they
determine the sorted order of an input array by comparing elements. Chapter 8 begins by introducing the decision-tree model in order to study the performance limitations of comparison sorts. Using this model, we prove a lower bound of .n lg n/
on the worst-case running time of any comparison sort on n inputs, thus showing
that heapsort and merge sort are asymptotically optimal comparison sorts.
Chapter 8 then goes on to show that we can beat this lower bound of .n lg n/
if we can gather information about the sorted order of the input by means other
than comparing elements. The counting sort algorithm, for example, assumes that
the input numbers are in the set f0; 1; : : : ; kg. By using array indexing as a tool
for determining relative order, counting sort can sort n numbers in ‚.k C n/ time.
Thus, when k D O.n/, counting sort runs in time that is linear in the size of the
input array. A related algorithm, radix sort, can be used to extend the range of
counting sort. If there are n integers to sort, each integer has d digits, and each
digit can take on up to k possible values, then radix sort can sort the numbers
in ‚.d.n C k// time. When d is a constant and k is O.n/, radix sort runs in
linear time. A third algorithm, bucket sort, requires knowledge of the probabilistic
distribution of numbers in the input array. It can sort n real numbers uniformly
distributed in the half-open interval Œ0; 1/ in average-case O.n/ time.
The following table summarizes the running times of the sorting algorithms from
Chapters 2 and 6–8. As usual, n denotes the number of items to sort. For counting
sort, the items to sort are integers in the set f0; 1; : : : ; kg. For radix sort, each item
is a d -digit number, where each digit takes on k possible values. For bucket sort,
we assume that the keys are real numbers uniformly distributed in the half-open
interval Œ0; 1/. The rightmost column gives the average-case or expected running
time, indicating which it gives when it differs from the worst-case running time.
We omit the average-case running time of heapsort because we do not analyze it in
this book.

150

Part II Sorting and Order Statistics

Algorithm

Worst-case
running time

Average-case/expected
running time

Insertion sort
Merge sort
Heapsort
Quicksort
Counting sort
Radix sort
Bucket sort

‚.n2 /
‚.n lg n/
O.n lg n/
‚.n2 /
‚.k C n/
‚.d.n C k//
‚.n2 /

‚.n2 /
‚.n lg n/
—
‚.n lg n/ (expected)
‚.k C n/
‚.d.n C k//
‚.n/ (average-case)

Order statistics
The ith order statistic of a set of n numbers is the ith smallest number in the set.
We can, of course, select the ith order statistic by sorting the input and indexing
the ith element of the output. With no assumptions about the input distribution,
this method runs in .n lg n/ time, as the lower bound proved in Chapter 8 shows.
In Chapter 9, we show that we can ﬁnd the ith smallest element in O.n/ time,
even when the elements are arbitrary real numbers. We present a randomized algorithm with tight pseudocode that runs in ‚.n2 / time in the worst case, but whose
expected running time is O.n/. We also give a more complicated algorithm that
runs in O.n/ worst-case time.
Background
Although most of this part does not rely on difﬁcult mathematics, some sections
do require mathematical sophistication. In particular, analyses of quicksort, bucket
sort, and the order-statistic algorithm use probability, which is reviewed in Appendix C, and the material on probabilistic analysis and randomized algorithms in
Chapter 5. The analysis of the worst-case linear-time algorithm for order statistics involves somewhat more sophisticated mathematics than the other worst-case
analyses in this part.

6

Heapsort

In this chapter, we introduce another sorting algorithm: heapsort. Like merge sort,
but unlike insertion sort, heapsort’s running time is O.n lg n/. Like insertion sort,
but unlike merge sort, heapsort sorts in place: only a constant number of array
elements are stored outside the input array at any time. Thus, heapsort combines
the better attributes of the two sorting algorithms we have already discussed.
Heapsort also introduces another algorithm design technique: using a data structure, in this case one we call a “heap,” to manage information. Not only is the heap
data structure useful for heapsort, but it also makes an efﬁcient priority queue. The
heap data structure will reappear in algorithms in later chapters.
The term “heap” was originally coined in the context of heapsort, but it has since
come to refer to “garbage-collected storage,” such as the programming languages
Java and Lisp provide. Our heap data structure is not garbage-collected storage,
and whenever we refer to heaps in this book, we shall mean a data structure rather
than an aspect of garbage collection.

6.1 Heaps
The (binary) heap data structure is an array object that we can view as a
nearly complete binary tree (see Section B.5.3), as shown in Figure 6.1. Each
node of the tree corresponds to an element of the array. The tree is completely ﬁlled on all levels except possibly the lowest, which is ﬁlled from the
left up to a point. An array A that represents a heap is an object with two attributes: A:length, which (as usual) gives the number of elements in the array, and
A:heap-size, which represents how many elements in the heap are stored within
array A. That is, although AŒ1 : : A:length may contain numbers, only the elements in AŒ1 : : A:heap-size, where 0  A:heap-size  A:length, are valid elements of the heap. The root of the tree is AŒ1, and given the index i of a node, we
can easily compute the indices of its parent, left child, and right child:

152

Chapter 6 Heapsort

1

16
2

3

14

10

4

8
8

9

10

2

4

1

5

6

7

7

9

3

(a)

1

2

3

4

5

6

7

8

9

10

16 14 10 8

7

9

3

2

4

1

(b)

Figure 6.1 A max-heap viewed as (a) a binary tree and (b) an array. The number within the circle
at each node in the tree is the value stored at that node. The number above a node is the corresponding
index in the array. Above and below the array are lines showing parent-child relationships; parents
are always to the left of their children. The tree has height three; the node at index 4 (with value 8)
has height one.

PARENT .i/
1 return bi=2c
L EFT .i/
1 return 2i
R IGHT .i/
1 return 2i C 1
On most computers, the L EFT procedure can compute 2i in one instruction by
simply shifting the binary representation of i left by one bit position. Similarly, the
R IGHT procedure can quickly compute 2i C 1 by shifting the binary representation
of i left by one bit position and then adding in a 1 as the low-order bit. The
PARENT procedure can compute bi=2c by shifting i right one bit position. Good
implementations of heapsort often implement these procedures as “macros” or “inline” procedures.
There are two kinds of binary heaps: max-heaps and min-heaps. In both kinds,
the values in the nodes satisfy a heap property, the speciﬁcs of which depend on
the kind of heap. In a max-heap, the max-heap property is that for every node i
other than the root,
AŒPARENT.i/  AŒi ;
that is, the value of a node is at most the value of its parent. Thus, the largest
element in a max-heap is stored at the root, and the subtree rooted at a node contains

6.1 Heaps

153

values no larger than that contained at the node itself. A min-heap is organized in
the opposite way; the min-heap property is that for every node i other than the
root,
AŒPARENT.i/  AŒi :
The smallest element in a min-heap is at the root.
For the heapsort algorithm, we use max-heaps. Min-heaps commonly implement priority queues, which we discuss in Section 6.5. We shall be precise in
specifying whether we need a max-heap or a min-heap for any particular application, and when properties apply to either max-heaps or min-heaps, we just use the
term “heap.”
Viewing a heap as a tree, we deﬁne the height of a node in a heap to be the
number of edges on the longest simple downward path from the node to a leaf, and
we deﬁne the height of the heap to be the height of its root. Since a heap of n elements is based on a complete binary tree, its height is ‚.lg n/ (see Exercise 6.1-2).
We shall see that the basic operations on heaps run in time at most proportional
to the height of the tree and thus take O.lg n/ time. The remainder of this chapter
presents some basic procedures and shows how they are used in a sorting algorithm
and a priority-queue data structure.


The M AX -H EAPIFY procedure, which runs in O.lg n/ time, is the key to maintaining the max-heap property.



The B UILD -M AX -H EAP procedure, which runs in linear time, produces a maxheap from an unordered input array.



The H EAPSORT procedure, which runs in O.n lg n/ time, sorts an array in
place.



The M AX -H EAP -I NSERT, H EAP -E XTRACT-M AX, H EAP -I NCREASE -K EY,
and H EAP -M AXIMUM procedures, which run in O.lg n/ time, allow the heap
data structure to implement a priority queue.

Exercises
6.1-1
What are the minimum and maximum numbers of elements in a heap of height h?
6.1-2
Show that an n-element heap has height blg nc.
6.1-3
Show that in any subtree of a max-heap, the root of the subtree contains the largest
value occurring anywhere in that subtree.

154

Chapter 6 Heapsort

6.1-4
Where in a max-heap might the smallest element reside, assuming that all elements
are distinct?
6.1-5
Is an array that is in sorted order a min-heap?
6.1-6
Is the array with values h23; 17; 14; 6; 13; 10; 1; 5; 7; 12i a max-heap?
6.1-7
Show that, with the array representation for storing an n-element heap, the leaves
are the nodes indexed by bn=2c C 1; bn=2c C 2; : : : ; n.

6.2

Maintaining the heap property
In order to maintain the max-heap property, we call the procedure M AX -H EAPIFY.
Its inputs are an array A and an index i into the array. When it is called, M AX H EAPIFY assumes that the binary trees rooted at L EFT .i/ and R IGHT .i/ are maxheaps, but that AŒi might be smaller than its children, thus violating the max-heap
property. M AX -H EAPIFY lets the value at AŒi “ﬂoat down” in the max-heap so
that the subtree rooted at index i obeys the max-heap property.
M AX -H EAPIFY .A; i/
1 l D L EFT .i/
2 r D R IGHT .i/
3 if l  A:heap-size and AŒl > AŒi
4
largest D l
5 else largest D i
6 if r  A:heap-size and AŒr > AŒlargest
7
largest D r
8 if largest ¤ i
9
exchange AŒi with AŒlargest
10
M AX -H EAPIFY .A; largest/
Figure 6.2 illustrates the action of M AX -H EAPIFY. At each step, the largest of
the elements AŒi, AŒL EFT .i/, and AŒR IGHT .i/ is determined, and its index is
stored in largest. If AŒi is largest, then the subtree rooted at node i is already a
max-heap and the procedure terminates. Otherwise, one of the two children has the
largest element, and AŒi is swapped with AŒlargest, which causes node i and its

6.2 Maintaining the heap property

155

1

1

16
i

16

2

3

2

3

4

10

14

10

4

14
8

9

10

2

8

1

5

6

7

7

9

3

(a)

4

i

4

8

9

10

2

8

1

5

6

7

7

9

3

(b)

1

16
2

3

14

10

4

8
8

9

2

4

i

5

6

7

7

9

3

10

1
(c)

Figure 6.2 The action of M AX -H EAPIFY.A; 2/, where A: heap-size D 10. (a) The initial conﬁguration, with AŒ2 at node i D 2 violating the max-heap property since it is not larger than
both children. The max-heap property is restored for node 2 in (b) by exchanging AŒ2 with AŒ4,
which destroys the max-heap property for node 4. The recursive call M AX -H EAPIFY.A; 4/ now
has i D 4. After swapping AŒ4 with AŒ9, as shown in (c), node 4 is ﬁxed up, and the recursive call
M AX -H EAPIFY.A; 9/ yields no further change to the data structure.

children to satisfy the max-heap property. The node indexed by largest, however,
now has the original value AŒi, and thus the subtree rooted at largest might violate
the max-heap property. Consequently, we call M AX -H EAPIFY recursively on that
subtree.
The running time of M AX -H EAPIFY on a subtree of size n rooted at a given
node i is the ‚.1/ time to ﬁx up the relationships among the elements AŒi,
AŒL EFT .i/, and AŒR IGHT .i/, plus the time to run M AX -H EAPIFY on a subtree
rooted at one of the children of node i (assuming that the recursive call occurs).
The children’s subtrees each have size at most 2n=3—the worst case occurs when
the bottom level of the tree is exactly half full—and therefore we can describe the
running time of M AX -H EAPIFY by the recurrence
T .n/  T .2n=3/ C ‚.1/ :

156

Chapter 6 Heapsort

The solution to this recurrence, by case 2 of the master theorem (Theorem 4.1),
is T .n/ D O.lg n/. Alternatively, we can characterize the running time of M AX H EAPIFY on a node of height h as O.h/.
Exercises
6.2-1
Using Figure 6.2 as a model, illustrate the operation of M AX -H EAPIFY .A; 3/ on
the array A D h27; 17; 3; 16; 13; 10; 1; 5; 7; 12; 4; 8; 9; 0i.
6.2-2
Starting with the procedure M AX -H EAPIFY, write pseudocode for the procedure
M IN -H EAPIFY .A; i/, which performs the corresponding manipulation on a minheap. How does the running time of M IN -H EAPIFY compare to that of M AX H EAPIFY?
6.2-3
What is the effect of calling M AX -H EAPIFY .A; i/ when the element AŒi is larger
than its children?
6.2-4
What is the effect of calling M AX -H EAPIFY .A; i/ for i > A:heap-size=2?
6.2-5
The code for M AX -H EAPIFY is quite efﬁcient in terms of constant factors, except
possibly for the recursive call in line 10, which might cause some compilers to
produce inefﬁcient code. Write an efﬁcient M AX -H EAPIFY that uses an iterative
control construct (a loop) instead of recursion.
6.2-6
Show that the worst-case running time of M AX -H EAPIFY on a heap of size n
is .lg n/. (Hint: For a heap with n nodes, give node values that cause M AX H EAPIFY to be called recursively at every node on a simple path from the root
down to a leaf.)

6.3

Building a heap
We can use the procedure M AX -H EAPIFY in a bottom-up manner to convert an
array AŒ1 : : n, where n D A:length, into a max-heap. By Exercise 6.1-7, the
elements in the subarray AŒ.bn=2cC1/ : : n are all leaves of the tree, and so each is

6.3 Building a heap

157

a 1-element heap to begin with. The procedure B UILD -M AX -H EAP goes through
the remaining nodes of the tree and runs M AX -H EAPIFY on each one.
B UILD -M AX -H EAP .A/
1 A:heap-size D A:length
2 for i D bA:length=2c downto 1
3
M AX -H EAPIFY .A; i/
Figure 6.3 shows an example of the action of B UILD -M AX -H EAP.
To show why B UILD -M AX -H EAP works correctly, we use the following loop
invariant:
At the start of each iteration of the for loop of lines 2–3, each node i C 1;
i C 2; : : : ; n is the root of a max-heap.
We need to show that this invariant is true prior to the ﬁrst loop iteration, that each
iteration of the loop maintains the invariant, and that the invariant provides a useful
property to show correctness when the loop terminates.
Initialization: Prior to the ﬁrst iteration of the loop, i D bn=2c. Each node
bn=2c C 1; bn=2c C 2; : : : ; n is a leaf and is thus the root of a trivial max-heap.
Maintenance: To see that each iteration maintains the loop invariant, observe that
the children of node i are numbered higher than i. By the loop invariant, therefore, they are both roots of max-heaps. This is precisely the condition required
for the call M AX -H EAPIFY .A; i/ to make node i a max-heap root. Moreover,
the M AX -H EAPIFY call preserves the property that nodes i C 1; i C 2; : : : ; n
are all roots of max-heaps. Decrementing i in the for loop update reestablishes
the loop invariant for the next iteration.
Termination: At termination, i D 0. By the loop invariant, each node 1; 2; : : : ; n
is the root of a max-heap. In particular, node 1 is.
We can compute a simple upper bound on the running time of B UILD -M AX H EAP as follows. Each call to M AX -H EAPIFY costs O.lg n/ time, and B UILD M AX -H EAP makes O.n/ such calls. Thus, the running time is O.n lg n/. This
upper bound, though correct, is not asymptotically tight.
We can derive a tighter bound by observing that the time for M AX -H EAPIFY to
run at a node varies with the height of the node in the tree, and the heights of most
nodes are small. Our tighter analysis relies on the properties
that an n-element heap
˙
has height blg nc (see Exercise 6.1-2) and at most n=2hC1 nodes of any height h
(see Exercise 6.3-3).
The time required by M AX -H EAPIFY when called on a node of height h is O.h/,
and so we can express the total cost of B UILD -M AX -H EAP as being bounded from
above by

158

Chapter 6 Heapsort

A 4

1

3

2 16 9 10 14 8

7

1

1

4

4

2

3

1

3

4

5

2

2

i 16

3

1

6

7

9

10

3

4

i

2

8

9

10

8

9

10

14

8

7

14

8

7

5

6

7

16

9

10

(a)

(b)

1

1

4

4

2

3

1

3

2

i

i

3

1

10

4

5

6

7

4

5

6

7

14

16

9

10

14

16

9

3

8

9

10

2

8

7

i

8

9

10

2

8

7

(c)

(d)

1

1

4

16

2

3

2

3

16

10

14

10

4

14
8

9

10

2

8

1

5

6

7

7

9

3

(e)

4

8
8

9

10

2

4

1

5

6

7

7

9

3

(f)

Figure 6.3 The operation of B UILD -M AX -H EAP, showing the data structure before the call to
M AX -H EAPIFY in line 3 of B UILD -M AX -H EAP. (a) A 10-element input array A and the binary tree it represents. The ﬁgure shows that the loop index i refers to node 5 before the call
M AX -H EAPIFY.A; i/. (b) The data structure that results. The loop index i for the next iteration
refers to node 4. (c)–(e) Subsequent iterations of the for loop in B UILD -M AX -H EAP. Observe that
whenever M AX -H EAPIFY is called on a node, the two subtrees of that node are both max-heaps.
(f) The max-heap after B UILD -M AX -H EAP ﬁnishes.

6.4 The heapsort algorithm
blg nc l

n m

X
hD0

2hC1

159

X h
O.h/ D O n
2h
blg nc

!
:

hD0

We evalaute the last summation by substituting x D 1=2 in the formula (A.8),
yielding
1
X
h
2h

D

hD0

1=2
.1  1=2/2

D 2:
Thus, we can bound the running time of B UILD -M AX -H EAP as
!
!
blg nc
1
X h
X
h
D O n
O n
2h
2h
hD0

hD0

D O.n/ :
Hence, we can build a max-heap from an unordered array in linear time.
We can build a min-heap by the procedure B UILD -M IN -H EAP, which is the
same as B UILD -M AX -H EAP but with the call to M AX -H EAPIFY in line 3 replaced
by a call to M IN -H EAPIFY (see Exercise 6.2-2). B UILD -M IN -H EAP produces a
min-heap from an unordered linear array in linear time.
Exercises
6.3-1
Using Figure 6.3 as a model, illustrate the operation of B UILD -M AX -H EAP on the
array A D h5; 3; 17; 10; 84; 19; 6; 22; 9i.
6.3-2
Why do we want the loop index i in line 2 of B UILD -M AX -H EAP to decrease from
bA:length=2c to 1 rather than increase from 1 to bA:length=2c?
6.3-3

˙
Show that there are at most n=2hC1 nodes of height h in any n-element heap.

6.4 The heapsort algorithm
The heapsort algorithm starts by using B UILD -M AX -H EAP to build a max-heap
on the input array AŒ1 : : n, where n D A:length. Since the maximum element
of the array is stored at the root AŒ1, we can put it into its correct ﬁnal position

160

Chapter 6 Heapsort

by exchanging it with AŒn. If we now discard node n from the heap—and we
can do so by simply decrementing A:heap-size—we observe that the children of
the root remain max-heaps, but the new root element might violate the max-heap
property. All we need to do to restore the max-heap property, however, is call
M AX -H EAPIFY .A; 1/, which leaves a max-heap in AŒ1 : : n  1. The heapsort
algorithm then repeats this process for the max-heap of size n  1 down to a heap
of size 2. (See Exercise 6.4-2 for a precise loop invariant.)
H EAPSORT .A/
1 B UILD -M AX -H EAP .A/
2 for i D A:length downto 2
3
exchange AŒ1 with AŒi
4
A:heap-size D A:heap-size  1
5
M AX -H EAPIFY .A; 1/
Figure 6.4 shows an example of the operation of H EAPSORT after line 1 has built
the initial max-heap. The ﬁgure shows the max-heap before the ﬁrst iteration of
the for loop of lines 2–5 and after each iteration.
The H EAPSORT procedure takes time O.n lg n/, since the call to B UILD -M AX H EAP takes time O.n/ and each of the n  1 calls to M AX -H EAPIFY takes
time O.lg n/.
Exercises
6.4-1
Using Figure 6.4 as a model, illustrate the operation of H EAPSORT on the array
A D h5; 13; 2; 25; 7; 17; 20; 8; 4i.
6.4-2
Argue the correctness of H EAPSORT using the following loop invariant:
At the start of each iteration of the for loop of lines 2–5, the subarray
AŒ1 : : i is a max-heap containing the i smallest elements of AŒ1 : : n, and
the subarray AŒi C 1 : : n contains the n  i largest elements of AŒ1 : : n,
sorted.
6.4-3
What is the running time of H EAPSORT on an array A of length n that is already
sorted in increasing order? What about decreasing order?
6.4-4
Show that the worst-case running time of H EAPSORT is .n lg n/.

6.4 The heapsort algorithm

161

16

14

14

10

8
2

7
4

9

4
2

3

16 i

4

7

1

2

8

7

3
1

7
2

3

4
10

2
14

1

4
i 9

16

3

1
10

2
14

8 i

(e)

(f)

4

3

2

i 7

8

2
9

1

i 4

16

10

7
14

(g)

8

1
9

16

3 i

4
10

(h)

7
14

9

16

(d)

3

3

i
14 16

9

2

14

1

9

9

(c)

16

1

7

8

(b)

7
14

10

3

10

(a)

8

i 10

8

1

4

10

8

9

16
(i)

1
i 2

3
A

4
10

7
14

8

1

2 3

4 7

8 9 10 14 16

9

16
(j)

(k)

Figure 6.4 The operation of H EAPSORT . (a) The max-heap data structure just after B UILD -M AX H EAP has built it in line 1. (b)–(j) The max-heap just after each call of M AX -H EAPIFY in line 5,
showing the value of i at that time. Only lightly shaded nodes remain in the heap. (k) The resulting
sorted array A.

162

Chapter 6 Heapsort

6.4-5 ?
Show that when all elements are distinct, the best-case running time of H EAPSORT
is .n lg n/.

6.5

Priority queues
Heapsort is an excellent algorithm, but a good implementation of quicksort, presented in Chapter 7, usually beats it in practice. Nevertheless, the heap data structure itself has many uses. In this section, we present one of the most popular applications of a heap: as an efﬁcient priority queue. As with heaps, priority queues
come in two forms: max-priority queues and min-priority queues. We will focus
here on how to implement max-priority queues, which are in turn based on maxheaps; Exercise 6.5-3 asks you to write the procedures for min-priority queues.
A priority queue is a data structure for maintaining a set S of elements, each
with an associated value called a key. A max-priority queue supports the following
operations:
I NSERT .S; x/ inserts the element x into the set S, which is equivalent to the operation S D S [ fxg.
M AXIMUM .S/ returns the element of S with the largest key.
E XTRACT-M AX .S/ removes and returns the element of S with the largest key.
I NCREASE -K EY .S; x; k/ increases the value of element x’s key to the new value k,
which is assumed to be at least as large as x’s current key value.
Among their other applications, we can use max-priority queues to schedule
jobs on a shared computer. The max-priority queue keeps track of the jobs to
be performed and their relative priorities. When a job is ﬁnished or interrupted,
the scheduler selects the highest-priority job from among those pending by calling
E XTRACT-M AX. The scheduler can add a new job to the queue at any time by
calling I NSERT.
Alternatively, a min-priority queue supports the operations I NSERT, M INIMUM,
E XTRACT-M IN, and D ECREASE -K EY. A min-priority queue can be used in an
event-driven simulator. The items in the queue are events to be simulated, each
with an associated time of occurrence that serves as its key. The events must be
simulated in order of their time of occurrence, because the simulation of an event
can cause other events to be simulated in the future. The simulation program calls
E XTRACT-M IN at each step to choose the next event to simulate. As new events are
produced, the simulator inserts them into the min-priority queue by calling I NSERT.

6.5 Priority queues

163

We shall see other uses for min-priority queues, highlighting the D ECREASE -K EY
operation, in Chapters 23 and 24.
Not surprisingly, we can use a heap to implement a priority queue. In a given application, such as job scheduling or event-driven simulation, elements of a priority
queue correspond to objects in the application. We often need to determine which
application object corresponds to a given priority-queue element, and vice versa.
When we use a heap to implement a priority queue, therefore, we often need to
store a handle to the corresponding application object in each heap element. The
exact makeup of the handle (such as a pointer or an integer) depends on the application. Similarly, we need to store a handle to the corresponding heap element
in each application object. Here, the handle would typically be an array index.
Because heap elements change locations within the array during heap operations,
an actual implementation, upon relocating a heap element, would also have to update the array index in the corresponding application object. Because the details
of accessing application objects depend heavily on the application and its implementation, we shall not pursue them here, other than noting that in practice, these
handles do need to be correctly maintained.
Now we discuss how to implement the operations of a max-priority queue. The
procedure H EAP -M AXIMUM implements the M AXIMUM operation in ‚.1/ time.
H EAP -M AXIMUM .A/
1 return AŒ1
The procedure H EAP -E XTRACT-M AX implements the E XTRACT-M AX operation. It is similar to the for loop body (lines 3–5) of the H EAPSORT procedure.
H EAP -E XTRACT-M AX .A/
1 if A:heap-size < 1
2
error “heap underﬂow”
3 max D AŒ1
4 AŒ1 D AŒA:heap-size
5 A:heap-size D A:heap-size  1
6 M AX -H EAPIFY .A; 1/
7 return max
The running time of H EAP -E XTRACT-M AX is O.lg n/, since it performs only a
constant amount of work on top of the O.lg n/ time for M AX -H EAPIFY.
The procedure H EAP -I NCREASE -K EY implements the I NCREASE -K EY operation. An index i into the array identiﬁes the priority-queue element whose key we
wish to increase. The procedure ﬁrst updates the key of element AŒi to its new
value. Because increasing the key of AŒi might violate the max-heap property,

164

Chapter 6 Heapsort

the procedure then, in a manner reminiscent of the insertion loop (lines 5–7) of
I NSERTION -S ORT from Section 2.1, traverses a simple path from this node toward
the root to ﬁnd a proper place for the newly increased key. As H EAP -I NCREASE K EY traverses this path, it repeatedly compares an element to its parent, exchanging their keys and continuing if the element’s key is larger, and terminating if the element’s key is smaller, since the max-heap property now holds. (See Exercise 6.5-5
for a precise loop invariant.)
H EAP -I NCREASE -K EY .A; i; key/
1 if key < AŒi
2
error “new key is smaller than current key”
3 AŒi D key
4 while i > 1 and AŒPARENT.i/ < AŒi
5
exchange AŒi with AŒPARENT.i/
6
i D PARENT.i/
Figure 6.5 shows an example of a H EAP -I NCREASE -K EY operation. The running
time of H EAP -I NCREASE -K EY on an n-element heap is O.lg n/, since the path
traced from the node updated in line 3 to the root has length O.lg n/.
The procedure M AX -H EAP -I NSERT implements the I NSERT operation. It takes
as an input the key of the new element to be inserted into max-heap A. The procedure ﬁrst expands the max-heap by adding to the tree a new leaf whose key is 1.
Then it calls H EAP -I NCREASE -K EY to set the key of this new node to its correct
value and maintain the max-heap property.
M AX -H EAP -I NSERT .A; key/
1 A:heap-size D A:heap-size C 1
2 AŒA:heap-size D 1
3 H EAP -I NCREASE -K EY .A; A:heap-size; key/
The running time of M AX -H EAP -I NSERT on an n-element heap is O.lg n/.
In summary, a heap can support any priority-queue operation on a set of size n
in O.lg n/ time.
Exercises
6.5-1
Illustrate the operation of H EAP -E XTRACT-M AX on the heap A D h15; 13; 9; 5;
12; 8; 7; 4; 0; 6; 2; 1i.

6.5 Priority queues

165

16

16

14

10

8

7

9

14
3

8

7

i
2

10
9

3

i

4

1

15

2

1

(a)

(b)

16

16
i

14

15

10

10

i
15
2

7
8

9

1

3

14
2

(c)

7
8

9

3

1
(d)

Figure 6.5 The operation of H EAP -I NCREASE -K EY. (a) The max-heap of Figure 6.4(a) with a
node whose index is i heavily shaded. (b) This node has its key increased to 15. (c) After one
iteration of the while loop of lines 4–6, the node and its parent have exchanged keys, and the index i
moves up to the parent. (d) The max-heap after one more iteration of the while loop. At this point,
AŒPARENT.i/  AŒi. The max-heap property now holds and the procedure terminates.

6.5-2
Illustrate the operation of M AX -H EAP -I NSERT .A; 10/ on the heap A D h15; 13; 9;
5; 12; 8; 7; 4; 0; 6; 2; 1i.
6.5-3
Write pseudocode for the procedures H EAP -M INIMUM, H EAP -E XTRACT-M IN,
H EAP -D ECREASE -K EY, and M IN -H EAP -I NSERT that implement a min-priority
queue with a min-heap.
6.5-4
Why do we bother setting the key of the inserted node to 1 in line 2 of M AX H EAP -I NSERT when the next thing we do is increase its key to the desired value?

166

Chapter 6 Heapsort

6.5-5
Argue the correctness of H EAP -I NCREASE -K EY using the following loop invariant:
At the start of each iteration of the while loop of lines 4–6, the subarray
AŒ1 : : A:heap-size satisﬁes the max-heap property, except that there may
be one violation: AŒi may be larger than AŒPARENT.i/.
You may assume that the subarray AŒ1 : : A:heap-size satisﬁes the max-heap property at the time H EAP -I NCREASE -K EY is called.
6.5-6
Each exchange operation on line 5 of H EAP -I NCREASE -K EY typically requires
three assignments. Show how to use the idea of the inner loop of I NSERTION S ORT to reduce the three assignments down to just one assignment.
6.5-7
Show how to implement a ﬁrst-in, ﬁrst-out queue with a priority queue. Show
how to implement a stack with a priority queue. (Queues and stacks are deﬁned in
Section 10.1.)
6.5-8
The operation H EAP -D ELETE .A; i/ deletes the item in node i from heap A. Give
an implementation of H EAP -D ELETE that runs in O.lg n/ time for an n-element
max-heap.
6.5-9
Give an O.n lg k/-time algorithm to merge k sorted lists into one sorted list,
where n is the total number of elements in all the input lists. (Hint: Use a minheap for k-way merging.)

Problems
6-1 Building a heap using insertion
We can build a heap by repeatedly calling M AX -H EAP -I NSERT to insert the elements into the heap. Consider the following variation on the B UILD -M AX -H EAP
procedure:

Problems for Chapter 6

167

B UILD -M AX -H EAP0 .A/
1 A:heap-size D 1
2 for i D 2 to A:length
3
M AX -H EAP -I NSERT .A; AŒi/
a. Do the procedures B UILD -M AX -H EAP and B UILD -M AX -H EAP 0 always create
the same heap when run on the same input array? Prove that they do, or provide
a counterexample.
b. Show that in the worst case, B UILD -M AX -H EAP 0 requires ‚.n lg n/ time to
build an n-element heap.
6-2 Analysis of d -ary heaps
A d -ary heap is like a binary heap, but (with one possible exception) non-leaf
nodes have d children instead of 2 children.
a. How would you represent a d -ary heap in an array?
b. What is the height of a d -ary heap of n elements in terms of n and d ?
c. Give an efﬁcient implementation of E XTRACT-M AX in a d -ary max-heap. Analyze its running time in terms of d and n.
d. Give an efﬁcient implementation of I NSERT in a d -ary max-heap. Analyze its
running time in terms of d and n.
e. Give an efﬁcient implementation of I NCREASE -K EY .A; i; k/, which ﬂags an
error if k < AŒi, but otherwise sets AŒi D k and then updates the d -ary maxheap structure appropriately. Analyze its running time in terms of d and n.
6-3 Young tableaus
An m n Young tableau is an m n matrix such that the entries of each row are
in sorted order from left to right and the entries of each column are in sorted order
from top to bottom. Some of the entries of a Young tableau may be 1, which we
treat as nonexistent elements. Thus, a Young tableau can be used to hold r  mn
ﬁnite numbers.
a. Draw a 4 4 Young tableau containing the elements f9; 16; 3; 2; 4; 8; 5; 14; 12g.
b. Argue that an m n Young tableau Y is empty if Y Œ1; 1 D 1. Argue that Y
is full (contains mn elements) if Y Œm; n < 1.

168

Chapter 6 Heapsort

c. Give an algorithm to implement E XTRACT-M IN on a nonempty m n Young
tableau that runs in O.m C n/ time. Your algorithm should use a recursive subroutine that solves an m n problem by recursively solving either
an .m  1/ n or an m .n  1/ subproblem. (Hint: Think about M AX H EAPIFY.) Deﬁne T .p/, where p D m C n, to be the maximum running time
of E XTRACT-M IN on any m n Young tableau. Give and solve a recurrence
for T .p/ that yields the O.m C n/ time bound.
d. Show how to insert a new element into a nonfull m
O.m C n/ time.

n Young tableau in

e. Using no other sorting method as a subroutine, show how to use an n n Young
tableau to sort n2 numbers in O.n3 / time.
f. Give an O.m C n/-time algorithm to determine whether a given number is
stored in a given m n Young tableau.

Chapter notes
The heapsort algorithm was invented by Williams [357], who also described how
to implement a priority queue with a heap. The B UILD -M AX -H EAP procedure
was suggested by Floyd [106].
We use min-heaps to implement min-priority queues in Chapters 16, 23, and 24.
We also give an implementation with improved time bounds for certain operations
in Chapter 19 and, assuming that the keys are drawn from a bounded set of nonnegative integers, Chapter 20.
If the data are b-bit integers, and the computer memory consists of addressable
b-bit words, Fredman and Willard [115] showed how
p to implement M INIMUM in
and
E
XTRACT-M IN in O. lg n/ time. Thorup [337] has
O.1/ time and I NSERT
p
improved the O. lg n/ bound to O.lg lg n/ time. This bound uses an amount of
space unbounded in n, but it can be implemented in linear space by using randomized hashing.
An important special case of priority queues occurs when the sequence of
E XTRACT-M IN operations is monotone, that is, the values returned by successive E XTRACT-M IN operations are monotonically increasing over time. This case
arises in several important applications, such as Dijkstra’s single-source shortestpaths algorithm, which we discuss in Chapter 24, and in discrete-event simulation. For Dijkstra’s algorithm it is particularly important that the D ECREASE -K EY
operation be implemented efﬁciently. For the monotone case, if the data are integers in the range 1; 2; : : : ; C , Ahuja, Mehlhorn, Orlin, and Tarjan [8] describe

Notes for Chapter 6

169

how to implement E XTRACT-M IN and I NSERT in O.lg C / amortized time (see
Chapter 17 for more on amortized analysis) and D ECREASE -K EY in O.1/ time,
using p
a data structure called a radix heap. The O.lg C / bound can be improved
to O. lg C / using Fibonacci heaps (see Chapter 19) in conjunction with radix
heaps. Cherkassky, Goldberg, and Silverstein [65] further improved the bound to
O.lg1=3C C / expected time by combining the multilevel bucketing structure of
Denardo and Fox [85] with the heap of Thorup mentioned earlier. Raman [291]
further improved these results to obtain a bound of O.min.lg1=4C C; lg1=3C n//,
for any ﬁxed  > 0.

7

Quicksort

The quicksort algorithm has a worst-case running time of ‚.n2 / on an input array
of n numbers. Despite this slow worst-case running time, quicksort is often the best
practical choice for sorting because it is remarkably efﬁcient on the average: its
expected running time is ‚.n lg n/, and the constant factors hidden in the ‚.n lg n/
notation are quite small. It also has the advantage of sorting in place (see page 17),
and it works well even in virtual-memory environments.
Section 7.1 describes the algorithm and an important subroutine used by quicksort for partitioning. Because the behavior of quicksort is complex, we start with
an intuitive discussion of its performance in Section 7.2 and postpone its precise
analysis to the end of the chapter. Section 7.3 presents a version of quicksort that
uses random sampling. This algorithm has a good expected running time, and no
particular input elicits its worst-case behavior. Section 7.4 analyzes the randomized algorithm, showing that it runs in ‚.n2 / time in the worst case and, assuming
distinct elements, in expected O.n lg n/ time.

7.1

Description of quicksort
Quicksort, like merge sort, applies the divide-and-conquer paradigm introduced
in Section 2.3.1. Here is the three-step divide-and-conquer process for sorting a
typical subarray AŒp : : r:
Divide: Partition (rearrange) the array AŒp : : r into two (possibly empty) subarrays AŒp : : q  1 and AŒq C 1 : : r such that each element of AŒp : : q  1 is
less than or equal to AŒq, which is, in turn, less than or equal to each element
of AŒq C 1 : : r. Compute the index q as part of this partitioning procedure.
Conquer: Sort the two subarrays AŒp : : q  1 and AŒq C 1 : : r by recursive calls
to quicksort.

7.1 Description of quicksort

171

Combine: Because the subarrays are already sorted, no work is needed to combine
them: the entire array AŒp : : r is now sorted.
The following procedure implements quicksort:
Q UICKSORT .A; p; r/
1 if p < r
2
q D PARTITION .A; p; r/
3
Q UICKSORT .A; p; q  1/
4
Q UICKSORT .A; q C 1; r/
To sort an entire array A, the initial call is Q UICKSORT .A; 1; A:length/.
Partitioning the array
The key to the algorithm is the PARTITION procedure, which rearranges the subarray AŒp : : r in place.
PARTITION .A; p; r/
1 x D AŒr
2 i D p1
3 for j D p to r  1
4
if AŒj   x
5
i D i C1
6
exchange AŒi with AŒj 
7 exchange AŒi C 1 with AŒr
8 return i C 1
Figure 7.1 shows how PARTITION works on an 8-element array. PARTITION
always selects an element x D AŒr as a pivot element around which to partition the
subarray AŒp : : r. As the procedure runs, it partitions the array into four (possibly
empty) regions. At the start of each iteration of the for loop in lines 3–6, the regions
satisfy certain properties, shown in Figure 7.2. We state these properties as a loop
invariant:
At the beginning of each iteration of the loop of lines 3–6, for any array
index k,
1. If p  k  i, then AŒk  x.
2. If i C 1  k  j  1, then AŒk > x.
3. If k D r, then AŒk D x.

172

Chapter 7 Quicksort

(a)

i p,j
2 8

6

r
4

(b)

p,i j
2 8

5

6

r
4

7

1

3

(c)

p,i
2 8

j
7

1

3

5

6

r
4

(d)

p,i
2 8

7

j
1

5

6

r
4

3

(e)

p
2

i
1

7

8

j
3

5

6

r
4

(f)

p
2

1

i
3

8

7

j
5

6

r
4

(g)

p
2

1

i
3

8

7

5

j
6

r
4

(h)

p
2

1

i
3

8

7

5

6

r
4

(i)

p
2

1

i
3

4

7

5

6

r
8

7

1

3

5

Figure 7.1 The operation of PARTITION on a sample array. Array entry AŒr becomes the pivot
element x. Lightly shaded array elements are all in the ﬁrst partition with values no greater than x.
Heavily shaded elements are in the second partition with values greater than x. The unshaded elements have not yet been put in one of the ﬁrst two partitions, and the ﬁnal white element is the
pivot x. (a) The initial array and variable settings. None of the elements have been placed in either
of the ﬁrst two partitions. (b) The value 2 is “swapped with itself” and put in the partition of smaller
values. (c)–(d) The values 8 and 7 are added to the partition of larger values. (e) The values 1 and 8
are swapped, and the smaller partition grows. (f) The values 3 and 7 are swapped, and the smaller
partition grows. (g)–(h) The larger partition grows to include 5 and 6, and the loop terminates. (i) In
lines 7–8, the pivot element is swapped so that it lies between the two partitions.

The indices between j and r  1 are not covered by any of the three cases, and the
values in these entries have no particular relationship to the pivot x.
We need to show that this loop invariant is true prior to the ﬁrst iteration, that
each iteration of the loop maintains the invariant, and that the invariant provides a
useful property to show correctness when the loop terminates.

7.1 Description of quicksort

p

i

≤x

173

j

>x

r
x
unrestricted

Figure 7.2 The four regions maintained by the procedure PARTITION on a subarray AŒp : : r. The
values in AŒp : : i are all less than or equal to x, the values in AŒi C 1 : : j  1 are all greater than x,
and AŒr D x. The subarray AŒj : : r  1 can take on any values.

Initialization: Prior to the ﬁrst iteration of the loop, i D p  1 and j D p. Because no values lie between p and i and no values lie between i C 1 and j  1,
the ﬁrst two conditions of the loop invariant are trivially satisﬁed. The assignment in line 1 satisﬁes the third condition.
Maintenance: As Figure 7.3 shows, we consider two cases, depending on the
outcome of the test in line 4. Figure 7.3(a) shows what happens when AŒj  > x;
the only action in the loop is to increment j . After j is incremented, condition 2
holds for AŒj  1 and all other entries remain unchanged. Figure 7.3(b) shows
what happens when AŒj   x; the loop increments i, swaps AŒi and AŒj ,
and then increments j . Because of the swap, we now have that AŒi  x, and
condition 1 is satisﬁed. Similarly, we also have that AŒj  1 > x, since the
item that was swapped into AŒj  1 is, by the loop invariant, greater than x.
Termination: At termination, j D r. Therefore, every entry in the array is in one
of the three sets described by the invariant, and we have partitioned the values
in the array into three sets: those less than or equal to x, those greater than x,
and a singleton set containing x.
The ﬁnal two lines of PARTITION ﬁnish up by swapping the pivot element with
the leftmost element greater than x, thereby moving the pivot into its correct place
in the partitioned array, and then returning the pivot’s new index. The output of
PARTITION now satisﬁes the speciﬁcations given for the divide step. In fact, it
satisﬁes a slightly stronger condition: after line 2 of Q UICKSORT, AŒq is strictly
less than every element of AŒq C 1 : : r.
The running time of PARTITION on the subarray AŒp : : r is ‚.n/, where
n D r  p C 1 (see Exercise 7.1-3).
Exercises
7.1-1
Using Figure 7.1 as a model, illustrate the operation of PARTITION on the array
A D h13; 19; 9; 5; 12; 8; 7; 4; 21; 2; 6; 11i.

174

Chapter 7 Quicksort

p

i

j
>x

(a)
≤x
p

>x
i

j

≤x
p

r
x

>x
i

j
≤x

(b)
≤x
p

r
x

r
x

>x
i

≤x

j

r
x

>x

Figure 7.3 The two cases for one iteration of procedure PARTITION. (a) If AŒj  > x, the only
action is to increment j , which maintains the loop invariant. (b) If AŒj   x, index i is incremented,
AŒi and AŒj  are swapped, and then j is incremented. Again, the loop invariant is maintained.

7.1-2
What value of q does PARTITION return when all elements in the array AŒp : : r
have the same value? Modify PARTITION so that q D b.p C r/=2c when all
elements in the array AŒp : : r have the same value.
7.1-3
Give a brief argument that the running time of PARTITION on a subarray of size n
is ‚.n/.
7.1-4
How would you modify Q UICKSORT to sort into nonincreasing order?

7.2

Performance of quicksort
The running time of quicksort depends on whether the partitioning is balanced or
unbalanced, which in turn depends on which elements are used for partitioning.
If the partitioning is balanced, the algorithm runs asymptotically as fast as merge

7.2 Performance of quicksort

175

sort. If the partitioning is unbalanced, however, it can run asymptotically as slowly
as insertion sort. In this section, we shall informally investigate how quicksort
performs under the assumptions of balanced versus unbalanced partitioning.
Worst-case partitioning
The worst-case behavior for quicksort occurs when the partitioning routine produces one subproblem with n  1 elements and one with 0 elements. (We prove
this claim in Section 7.4.1.) Let us assume that this unbalanced partitioning arises
in each recursive call. The partitioning costs ‚.n/ time. Since the recursive call
on an array of size 0 just returns, T .0/ D ‚.1/, and the recurrence for the running
time is
T .n/ D T .n  1/ C T .0/ C ‚.n/
D T .n  1/ C ‚.n/ :
Intuitively, if we sum the costs incurred at each level of the recursion, we get
an arithmetic series (equation (A.2)), which evaluates to ‚.n2 /. Indeed, it is
straightforward to use the substitution method to prove that the recurrence T .n/ D
T .n  1/ C ‚.n/ has the solution T .n/ D ‚.n2 /. (See Exercise 7.2-1.)
Thus, if the partitioning is maximally unbalanced at every recursive level of the
algorithm, the running time is ‚.n2 /. Therefore the worst-case running time of
quicksort is no better than that of insertion sort. Moreover, the ‚.n2 / running time
occurs when the input array is already completely sorted—a common situation in
which insertion sort runs in O.n/ time.
Best-case partitioning
In the most even possible split, PARTITION produces two subproblems, each of
size no more than n=2, since one is of size bn=2c and one of size dn=2e  1. In this
case, quicksort runs much faster. The recurrence for the running time is then
T .n/ D 2T .n=2/ C ‚.n/ ;
where we tolerate the sloppiness from ignoring the ﬂoor and ceiling and from subtracting 1. By case 2 of the master theorem (Theorem 4.1), this recurrence has the
solution T .n/ D ‚.n lg n/. By equally balancing the two sides of the partition at
every level of the recursion, we get an asymptotically faster algorithm.
Balanced partitioning
The average-case running time of quicksort is much closer to the best case than to
the worst case, as the analyses in Section 7.4 will show. The key to understand-

176

Chapter 7 Quicksort

n

1
10

log10 n

1
100

n

cn

9
10

n

9
100

n

9
100

n

81
100

n

log10=9 n
1

cn

81
1000

n

n

729
1000

cn

n

cn

 cn

1

 cn
O.n lg n/

Figure 7.4 A recursion tree for Q UICKSORT in which PARTITION always produces a 9-to-1 split,
yielding a running time of O.n lg n/. Nodes show subproblem sizes, with per-level costs on the right.
The per-level costs include the constant c implicit in the ‚.n/ term.

ing why is to understand how the balance of the partitioning is reﬂected in the
recurrence that describes the running time.
Suppose, for example, that the partitioning algorithm always produces a 9-to-1
proportional split, which at ﬁrst blush seems quite unbalanced. We then obtain the
recurrence
T .n/ D T .9n=10/ C T .n=10/ C cn ;
on the running time of quicksort, where we have explicitly included the constant c
hidden in the ‚.n/ term. Figure 7.4 shows the recursion tree for this recurrence.
Notice that every level of the tree has cost cn, until the recursion reaches a boundary condition at depth log10 n D ‚.lg n/, and then the levels have cost at most cn.
The recursion terminates at depth log10=9 n D ‚.lg n/. The total cost of quicksort is therefore O.n lg n/. Thus, with a 9-to-1 proportional split at every level of
recursion, which intuitively seems quite unbalanced, quicksort runs in O.n lg n/
time—asymptotically the same as if the split were right down the middle. Indeed,
even a 99-to-1 split yields an O.n lg n/ running time. In fact, any split of constant
proportionality yields a recursion tree of depth ‚.lg n/, where the cost at each level
is O.n/. The running time is therefore O.n lg n/ whenever the split has constant
proportionality.

7.2 Performance of quicksort

177

n
Θ(n)
0

Θ(n)

n

n–1
(n–1)/2
(n–1)/2 – 1

(n–1)/2

(n–1)/2

(a)

(b)

Figure 7.5 (a) Two levels of a recursion tree for quicksort. The partitioning at the root costs n
and produces a “bad” split: two subarrays of sizes 0 and n  1. The partitioning of the subarray of
size n  1 costs n  1 and produces a “good” split: subarrays of size .n  1/=2  1 and .n  1/=2.
(b) A single level of a recursion tree that is very well balanced. In both parts, the partitioning cost for
the subproblems shown with elliptical shading is ‚.n/. Yet the subproblems remaining to be solved
in (a), shown with square shading, are no larger than the corresponding subproblems remaining to be
solved in (b).

Intuition for the average case
To develop a clear notion of the randomized behavior of quicksort, we must make
an assumption about how frequently we expect to encounter the various inputs.
The behavior of quicksort depends on the relative ordering of the values in the
array elements given as the input, and not by the particular values in the array. As
in our probabilistic analysis of the hiring problem in Section 5.2, we will assume
for now that all permutations of the input numbers are equally likely.
When we run quicksort on a random input array, the partitioning is highly unlikely to happen in the same way at every level, as our informal analysis has assumed. We expect that some of the splits will be reasonably well balanced and
that some will be fairly unbalanced. For example, Exercise 7.2-6 asks you to show
that about 80 percent of the time PARTITION produces a split that is more balanced
than 9 to 1, and about 20 percent of the time it produces a split that is less balanced
than 9 to 1.
In the average case, PARTITION produces a mix of “good” and “bad” splits. In a
recursion tree for an average-case execution of PARTITION, the good and bad splits
are distributed randomly throughout the tree. Suppose, for the sake of intuition,
that the good and bad splits alternate levels in the tree, and that the good splits
are best-case splits and the bad splits are worst-case splits. Figure 7.5(a) shows
the splits at two consecutive levels in the recursion tree. At the root of the tree,
the cost is n for partitioning, and the subarrays produced have sizes n  1 and 0:
the worst case. At the next level, the subarray of size n  1 undergoes best-case
partitioning into subarrays of size .n  1/=2  1 and .n  1/=2. Let’s assume that
the boundary-condition cost is 1 for the subarray of size 0.

178

Chapter 7 Quicksort

The combination of the bad split followed by the good split produces three subarrays of sizes 0, .n  1/=2  1, and .n  1/=2 at a combined partitioning cost
of ‚.n/ C ‚.n  1/ D ‚.n/. Certainly, this situation is no worse than that in
Figure 7.5(b), namely a single level of partitioning that produces two subarrays of
size .n  1/=2, at a cost of ‚.n/. Yet this latter situation is balanced! Intuitively,
the ‚.n  1/ cost of the bad split can be absorbed into the ‚.n/ cost of the good
split, and the resulting split is good. Thus, the running time of quicksort, when levels alternate between good and bad splits, is like the running time for good splits
alone: still O.n lg n/, but with a slightly larger constant hidden by the O-notation.
We shall give a rigorous analysis of the expected running time of a randomized
version of quicksort in Section 7.4.2.
Exercises
7.2-1
Use the substitution method to prove that the recurrence T .n/ D T .n  1/ C ‚.n/
has the solution T .n/ D ‚.n2 /, as claimed at the beginning of Section 7.2.
7.2-2
What is the running time of Q UICKSORT when all elements of array A have the
same value?
7.2-3
Show that the running time of Q UICKSORT is ‚.n2 / when the array A contains
distinct elements and is sorted in decreasing order.
7.2-4
Banks often record transactions on an account in order of the times of the transactions, but many people like to receive their bank statements with checks listed in
order by check number. People usually write checks in order by check number, and
merchants usually cash them with reasonable dispatch. The problem of converting
time-of-transaction ordering to check-number ordering is therefore the problem of
sorting almost-sorted input. Argue that the procedure I NSERTION -S ORT would
tend to beat the procedure Q UICKSORT on this problem.
7.2-5
Suppose that the splits at every level of quicksort are in the proportion 1  ˛ to ˛,
where 0 < ˛  1=2 is a constant. Show that the minimum depth of a leaf in the recursion tree is approximately  lg n= lg ˛ and the maximum depth is approximately
 lg n= lg.1  ˛/. (Don’t worry about integer round-off.)

7.3 A randomized version of quicksort

179

7.2-6 ?
Argue that for any constant 0 < ˛  1=2, the probability is approximately 1  2˛
that on a random input array, PARTITION produces a split more balanced than 1˛
to ˛.

7.3 A randomized version of quicksort
In exploring the average-case behavior of quicksort, we have made an assumption
that all permutations of the input numbers are equally likely. In an engineering
situation, however, we cannot always expect this assumption to hold. (See Exercise 7.2-4.) As we saw in Section 5.3, we can sometimes add randomization to an
algorithm in order to obtain good expected performance over all inputs. Many people regard the resulting randomized version of quicksort as the sorting algorithm
of choice for large enough inputs.
In Section 5.3, we randomized our algorithm by explicitly permuting the input. We could do so for quicksort also, but a different randomization technique,
called random sampling, yields a simpler analysis. Instead of always using AŒr
as the pivot, we will select a randomly chosen element from the subarray AŒp : : r.
We do so by ﬁrst exchanging element AŒr with an element chosen at random
from AŒp : : r. By randomly sampling the range p; : : : ; r, we ensure that the pivot
element x D AŒr is equally likely to be any of the r  p C 1 elements in the
subarray. Because we randomly choose the pivot element, we expect the split of
the input array to be reasonably well balanced on average.
The changes to PARTITION and Q UICKSORT are small. In the new partition
procedure, we simply implement the swap before actually partitioning:
R ANDOMIZED -PARTITION .A; p; r/
1 i D R ANDOM .p; r/
2 exchange AŒr with AŒi
3 return PARTITION .A; p; r/
The new quicksort calls R ANDOMIZED -PARTITION in place of PARTITION:
R ANDOMIZED -Q UICKSORT .A; p; r/
1 if p < r
2
q D R ANDOMIZED -PARTITION .A; p; r/
3
R ANDOMIZED -Q UICKSORT .A; p; q  1/
4
R ANDOMIZED -Q UICKSORT .A; q C 1; r/
We analyze this algorithm in the next section.

180

Chapter 7 Quicksort

Exercises
7.3-1
Why do we analyze the expected running time of a randomized algorithm and not
its worst-case running time?
7.3-2
When R ANDOMIZED -Q UICKSORT runs, how many calls are made to the randomnumber generator R ANDOM in the worst case? How about in the best case? Give
your answer in terms of ‚-notation.

7.4

Analysis of quicksort
Section 7.2 gave some intuition for the worst-case behavior of quicksort and for
why we expect it to run quickly. In this section, we analyze the behavior of quicksort more rigorously. We begin with a worst-case analysis, which applies to either
Q UICKSORT or R ANDOMIZED -Q UICKSORT, and conclude with an analysis of the
expected running time of R ANDOMIZED -Q UICKSORT.
7.4.1

Worst-case analysis

We saw in Section 7.2 that a worst-case split at every level of recursion in quicksort
produces a ‚.n2 / running time, which, intuitively, is the worst-case running time
of the algorithm. We now prove this assertion.
Using the substitution method (see Section 4.3), we can show that the running
time of quicksort is O.n2 /. Let T .n/ be the worst-case time for the procedure
Q UICKSORT on an input of size n. We have the recurrence
T .n/ D max .T .q/ C T .n  q  1// C ‚.n/ ;
0qn1

(7.1)

where the parameter q ranges from 0 to n  1 because the procedure PARTITION
produces two subproblems with total size n  1. We guess that T .n/  cn2 for
some constant c. Substituting this guess into recurrence (7.1), we obtain
T .n/ 

max .cq 2 C c.n  q  1/2 / C ‚.n/

0qn1

D c  max .q 2 C .n  q  1/2 / C ‚.n/ :
0qn1

The expression q 2 C .n  q  1/2 achieves a maximum over the parameter’s
range 0  q  n  1 at either endpoint. To verify this claim, note that the second
derivative of the expression with respect to q is positive (see Exercise 7.4-3). This

7.4 Analysis of quicksort

181

observation gives us the bound max0qn1 .q 2 C .n  q  1/2 /  .n  1/2 D
n2  2n C 1. Continuing with our bounding of T .n/, we obtain
T .n/  cn2  c.2n  1/ C ‚.n/
 cn2 ;
since we can pick the constant c large enough so that the c.2n  1/ term dominates the ‚.n/ term. Thus, T .n/ D O.n2 /. We saw in Section 7.2 a speciﬁc
case in which quicksort takes .n2 / time: when partitioning is unbalanced. Alternatively, Exercise 7.4-1 asks you to show that recurrence (7.1) has a solution of
T .n/ D .n2 /. Thus, the (worst-case) running time of quicksort is ‚.n2 /.
7.4.2 Expected running time
We have already seen the intuition behind why the expected running time of
R ANDOMIZED -Q UICKSORT is O.n lg n/: if, in each level of recursion, the split
induced by R ANDOMIZED -PARTITION puts any constant fraction of the elements
on one side of the partition, then the recursion tree has depth ‚.lg n/, and O.n/
work is performed at each level. Even if we add a few new levels with the most unbalanced split possible between these levels, the total time remains O.n lg n/. We
can analyze the expected running time of R ANDOMIZED -Q UICKSORT precisely
by ﬁrst understanding how the partitioning procedure operates and then using this
understanding to derive an O.n lg n/ bound on the expected running time. This
upper bound on the expected running time, combined with the ‚.n lg n/ best-case
bound we saw in Section 7.2, yields a ‚.n lg n/ expected running time. We assume
throughout that the values of the elements being sorted are distinct.
Running time and comparisons
The Q UICKSORT and R ANDOMIZED -Q UICKSORT procedures differ only in how
they select pivot elements; they are the same in all other respects. We can therefore
couch our analysis of R ANDOMIZED -Q UICKSORT by discussing the Q UICKSORT
and PARTITION procedures, but with the assumption that pivot elements are selected randomly from the subarray passed to R ANDOMIZED -PARTITION.
The running time of Q UICKSORT is dominated by the time spent in the PARTI TION procedure. Each time the PARTITION procedure is called, it selects a pivot
element, and this element is never included in any future recursive calls to Q UICK SORT and PARTITION . Thus, there can be at most n calls to PARTITION over the
entire execution of the quicksort algorithm. One call to PARTITION takes O.1/
time plus an amount of time that is proportional to the number of iterations of the
for loop in lines 3–6. Each iteration of this for loop performs a comparison in
line 4, comparing the pivot element to another element of the array A. Therefore,

182

Chapter 7 Quicksort

if we can count the total number of times that line 4 is executed, we can bound the
total time spent in the for loop during the entire execution of Q UICKSORT.
Lemma 7.1
Let X be the number of comparisons performed in line 4 of PARTITION over the
entire execution of Q UICKSORT on an n-element array. Then the running time of
Q UICKSORT is O.n C X /.
Proof By the discussion above, the algorithm makes at most n calls to PARTI TION , each of which does a constant amount of work and then executes the for
loop some number of times. Each iteration of the for loop executes line 4.
Our goal, therefore, is to compute X , the total number of comparisons performed
in all calls to PARTITION. We will not attempt to analyze how many comparisons
are made in each call to PARTITION. Rather, we will derive an overall bound on the
total number of comparisons. To do so, we must understand when the algorithm
compares two elements of the array and when it does not. For ease of analysis, we
rename the elements of the array A as ´1 ; ´2 ; : : : ; ´n , with ´i being the ith smallest
element. We also deﬁne the set Zij D f´i ; ´i C1 ; : : : ; ´j g to be the set of elements
between ´i and ´j , inclusive.
When does the algorithm compare ´i and ´j ? To answer this question, we ﬁrst
observe that each pair of elements is compared at most once. Why? Elements
are compared only to the pivot element and, after a particular call of PARTITION
ﬁnishes, the pivot element used in that call is never again compared to any other
elements.
Our analysis uses indicator random variables (see Section 5.2). We deﬁne
Xij D I f´i is compared to ´j g ;
where we are considering whether the comparison takes place at any time during
the execution of the algorithm, not just during one iteration or one call of PARTI TION . Since each pair is compared at most once, we can easily characterize the
total number of comparisons performed by the algorithm:
XD

n1 X
n
X

Xij :

i D1 j Di C1

Taking expectations of both sides, and then using linearity of expectation and
Lemma 5.1, we obtain
#
" n1 n
X X
Xij
E ŒX  D E
i D1 j Di C1

7.4 Analysis of quicksort

D

n1 X
n
X

183

E ŒXij 

i D1 j Di C1

D

n1
X

n
X

Pr f´i is compared to ´j g :

(7.2)

i D1 j Di C1

It remains to compute Pr f´i is compared to ´j g. Our analysis assumes that the
R ANDOMIZED -PARTITION procedure chooses each pivot randomly and independently.
Let us think about when two items are not compared. Consider an input to
quicksort of the numbers 1 through 10 (in any order), and suppose that the ﬁrst
pivot element is 7. Then the ﬁrst call to PARTITION separates the numbers into two
sets: f1; 2; 3; 4; 5; 6g and f8; 9; 10g. In doing so, the pivot element 7 is compared
to all other elements, but no number from the ﬁrst set (e.g., 2) is or ever will be
compared to any number from the second set (e.g., 9).
In general, because we assume that element values are distinct, once a pivot x
is chosen with ´i < x < ´j , we know that ´i and ´j cannot be compared at any
subsequent time. If, on the other hand, ´i is chosen as a pivot before any other item
in Zij , then ´i will be compared to each item in Zij , except for itself. Similarly,
if ´j is chosen as a pivot before any other item in Zij , then ´j will be compared to
each item in Zij , except for itself. In our example, the values 7 and 9 are compared
because 7 is the ﬁrst item from Z7;9 to be chosen as a pivot. In contrast, 2 and 9 will
never be compared because the ﬁrst pivot element chosen from Z2;9 is 7. Thus, ´i
and ´j are compared if and only if the ﬁrst element to be chosen as a pivot from Zij
is either ´i or ´j .
We now compute the probability that this event occurs. Prior to the point at
which an element from Zij has been chosen as a pivot, the whole set Zij is together
in the same partition. Therefore, any element of Zij is equally likely to be the ﬁrst
one chosen as a pivot. Because the set Zij has j i C1 elements, and because pivots
are chosen randomly and independently, the probability that any given element is
the ﬁrst one chosen as a pivot is 1=.j  i C 1/. Thus, we have
Pr f´i is compared to ´j g D Pr f´i or ´j is ﬁrst pivot chosen from Zij g
D Pr f´i is ﬁrst pivot chosen from Zij g
C Pr f´j is ﬁrst pivot chosen from Zij g
1
1
C
D
j i C1
j i C1
2
:
D
j i C1

(7.3)

184

Chapter 7 Quicksort

The second line follows because the two events are mutually exclusive. Combining
equations (7.2) and (7.3), we get that
E ŒX  D

n1 X
n
X

2
:
j i C1
i D1 j Di C1

We can evaluate this sum using a change of variables (k D j  i) and the bound
on the harmonic series in equation (A.7):
E ŒX  D

D

n1 X
n
X

2
j i C1
i D1 j Di C1

n1 X
ni
X
i D1 kD1

2
kC1

n1 X
n
X
2
<
k
i D1
kD1

D

n1
X

O.lg n/

i D1

D O.n lg n/ :

(7.4)

Thus we conclude that, using R ANDOMIZED -PARTITION, the expected running
time of quicksort is O.n lg n/ when element values are distinct.
Exercises
7.4-1
Show that in the recurrence
T .n/ D max .T .q/ C T .n  q  1// C ‚.n/ ;
0qn1

T .n/ D .n2 /.
7.4-2
Show that quicksort’s best-case running time is .n lg n/.
7.4-3
Show that the expression q 2 C .n  q  1/2 achieves a maximum over q D
0; 1; : : : ; n  1 when q D 0 or q D n  1.
7.4-4
Show that R ANDOMIZED -Q UICKSORT’s expected running time is .n lg n/.

Problems for Chapter 7

185

7.4-5
We can improve the running time of quicksort in practice by taking advantage of the
fast running time of insertion sort when its input is “nearly” sorted. Upon calling
quicksort on a subarray with fewer than k elements, let it simply return without
sorting the subarray. After the top-level call to quicksort returns, run insertion sort
on the entire array to ﬁnish the sorting process. Argue that this sorting algorithm
runs in O.nk C n lg.n=k// expected time. How should we pick k, both in theory
and in practice?
7.4-6 ?
Consider modifying the PARTITION procedure by randomly picking three elements
from array A and partitioning about their median (the middle value of the three
elements). Approximate the probability of getting at worst an ˛-to-.1  ˛/ split, as
a function of ˛ in the range 0 < ˛ < 1.

Problems
7-1 Hoare partition correctness
The version of PARTITION given in this chapter is not the original partitioning
algorithm. Here is the original partition algorithm, which is due to C. A. R. Hoare:
H OARE -PARTITION .A; p; r/
1 x D AŒp
2 i D p1
3 j D r C1
4 while TRUE
5
repeat
6
j D j 1
7
until AŒj   x
8
repeat
9
i D i C1
10
until AŒi  x
11
if i < j
12
exchange AŒi with AŒj 
13
else return j
a. Demonstrate the operation of H OARE -PARTITION on the array A D h13; 19; 9;
5; 12; 8; 7; 4; 11; 2; 6; 21i, showing the values of the array and auxiliary values
after each iteration of the while loop in lines 4–13.

186

Chapter 7 Quicksort

The next three questions ask you to give a careful argument that the procedure
H OARE -PARTITION is correct. Assuming that the subarray AŒp : : r contains at
least two elements, prove the following:
b. The indices i and j are such that we never access an element of A outside the
subarray AŒp : : r.
c. When H OARE -PARTITION terminates, it returns a value j such that p  j < r.
d. Every element of AŒp : : j  is less than or equal to every element of AŒj C1 : : r
when H OARE -PARTITION terminates.
The PARTITION procedure in Section 7.1 separates the pivot value (originally
in AŒr) from the two partitions it forms. The H OARE -PARTITION procedure, on
the other hand, always places the pivot value (originally in AŒp) into one of the
two partitions AŒp : : j  and AŒj C 1 : : r. Since p  j < r, this split is always
nontrivial.
e. Rewrite the Q UICKSORT procedure to use H OARE -PARTITION.
7-2 Quicksort with equal element values
The analysis of the expected running time of randomized quicksort in Section 7.4.2
assumes that all element values are distinct. In this problem, we examine what
happens when they are not.
a. Suppose that all element values are equal. What would be randomized quicksort’s running time in this case?
b. The PARTITION procedure returns an index q such that each element of
AŒp : : q  1 is less than or equal to AŒq and each element of AŒq C 1 : : r
is greater than AŒq. Modify the PARTITION procedure to produce a procedure
PARTITION 0 .A; p; r/, which permutes the elements of AŒp : : r and returns two
indices q and t, where p  q  t  r, such that




all elements of AŒq : : t are equal,
each element of AŒp : : q  1 is less than AŒq, and
each element of AŒt C 1 : : r is greater than AŒq.

Like PARTITION, your PARTITION 0 procedure should take ‚.r  p/ time.
c. Modify the R ANDOMIZED -Q UICKSORT procedure to call PARTITION 0 , and
name the new procedure R ANDOMIZED -Q UICKSORT 0 . Then modify the
Q UICKSORT procedure to produce a procedure Q UICKSORT 0 .p; r/ that calls

Problems for Chapter 7

187

R ANDOMIZED -PARTITION 0 and recurses only on partitions of elements not
known to be equal to each other.
d. Using Q UICKSORT 0 , how would you adjust the analysis in Section 7.4.2 to
avoid the assumption that all elements are distinct?
7-3 Alternative quicksort analysis
An alternative analysis of the running time of randomized quicksort focuses on
the expected running time of each individual recursive call to R ANDOMIZED Q UICKSORT, rather than on the number of comparisons performed.
a. Argue that, given an array of size n, the probability that any particular element
is chosen as the pivot is 1=n. Use this to deﬁne indicator random variables
Xi D I fith smallest element is chosen as the pivotg. What is E ŒXi ?
b. Let T .n/ be a random variable denoting the running time of quicksort on an
array of size n. Argue that
#
" n
X
Xq .T .q  1/ C T .n  q/ C ‚.n// :
(7.5)
E ŒT .n/ D E
qD1

c. Show that we can rewrite equation (7.5) as
2X
E ŒT .q/ C ‚.n/ :
n qD2
n1

E ŒT .n/ D

(7.6)

d. Show that
n1
X
kD2

1
1
k lg k  n2 lg n  n2 :
2
8

(7.7)

(Hint: Split the summation into two parts, one for k D 2; 3; : : : ; dn=2e  1 and
one for k D dn=2e ; : : : ; n  1.)
e. Using the bound from equation (7.7), show that the recurrence in equation (7.6)
has the solution E ŒT .n/ D ‚.n lg n/. (Hint: Show, by substitution, that
E ŒT .n/  an lg n for sufﬁciently large n and for some positive constant a.)

188

Chapter 7 Quicksort

7-4 Stack depth for quicksort
The Q UICKSORT algorithm of Section 7.1 contains two recursive calls to itself.
After Q UICKSORT calls PARTITION, it recursively sorts the left subarray and then
it recursively sorts the right subarray. The second recursive call in Q UICKSORT
is not really necessary; we can avoid it by using an iterative control structure.
This technique, called tail recursion, is provided automatically by good compilers.
Consider the following version of quicksort, which simulates tail recursion:
TAIL -R ECURSIVE -Q UICKSORT .A; p; r/
1 while p < r
2
// Partition and sort left subarray.
3
q D PARTITION .A; p; r/
4
TAIL -R ECURSIVE -Q UICKSORT .A; p; q  1/
5
p D qC1
a. Argue that TAIL -R ECURSIVE -Q UICKSORT .A; 1; A:length/ correctly sorts the
array A.
Compilers usually execute recursive procedures by using a stack that contains pertinent information, including the parameter values, for each recursive call. The
information for the most recent call is at the top of the stack, and the information
for the initial call is at the bottom. Upon calling a procedure, its information is
pushed onto the stack; when it terminates, its information is popped. Since we
assume that array parameters are represented by pointers, the information for each
procedure call on the stack requires O.1/ stack space. The stack depth is the maximum amount of stack space used at any time during a computation.
b. Describe a scenario in which TAIL -R ECURSIVE -Q UICKSORT’s stack depth is
‚.n/ on an n-element input array.
c. Modify the code for TAIL -R ECURSIVE -Q UICKSORT so that the worst-case
stack depth is ‚.lg n/. Maintain the O.n lg n/ expected running time of the
algorithm.
7-5 Median-of-3 partition
One way to improve the R ANDOMIZED -Q UICKSORT procedure is to partition
around a pivot that is chosen more carefully than by picking a random element
from the subarray. One common approach is the median-of-3 method: choose
the pivot as the median (middle element) of a set of 3 elements randomly selected
from the subarray. (See Exercise 7.4-6.) For this problem, let us assume that the
elements in the input array AŒ1 : : n are distinct and that n  3. We denote the

Problems for Chapter 7

189

sorted output array by A0 Œ1 : : n. Using the median-of-3 method to choose the
pivot element x, deﬁne pi D Pr fx D A0 Œig.
a. Give an exact formula for pi as a function of n and i for i D 2; 3; : : : ; n  1.
(Note that p1 D pn D 0.)
b. By what amount have we increased the likelihood of choosing the pivot as
x D A0 Œb.n C 1/=2c, the median of AŒ1 : : n, compared with the ordinary
implementation? Assume that n ! 1, and give the limiting ratio of these
probabilities.
c. If we deﬁne a “good” split to mean choosing the pivot as x D A0 Œi, where
n=3  i  2n=3, by what amount have we increased the likelihood of getting
a good split compared with the ordinary implementation? (Hint: Approximate
the sum by an integral.)
d. Argue that in the .n lg n/ running time of quicksort, the median-of-3 method
affects only the constant factor.
7-6 Fuzzy sorting of intervals
Consider a sorting problem in which we do not know the numbers exactly. Instead, for each number, we know an interval on the real line to which it belongs.
That is, we are given n closed intervals of the form Œai ; bi , where ai  bi . We
wish to fuzzy-sort these intervals, i.e., to produce a permutation hi1 ; i2 ; : : : ; in i of
the intervals such that for j D 1; 2; : : : ; n, there exist cj 2 Œaij ; bij  satisfying
c1  c2      cn .
a. Design a randomized algorithm for fuzzy-sorting n intervals. Your algorithm
should have the general structure of an algorithm that quicksorts the left endpoints (the ai values), but it should take advantage of overlapping intervals to
improve the running time. (As the intervals overlap more and more, the problem of fuzzy-sorting the intervals becomes progressively easier. Your algorithm
should take advantage of such overlapping, to the extent that it exists.)
b. Argue that your algorithm runs in expected time ‚.n lg n/ in general, but runs
in expected time ‚.n/ when all of the intervals overlap (i.e., when there exists a
value x such that x 2 Œai ; bi  for all i). Your algorithm should not be checking
for this case explicitly; rather, its performance should naturally improve as the
amount of overlap increases.

190

Chapter 7 Quicksort

Chapter notes
The quicksort procedure was invented by Hoare [170]; Hoare’s version appears in
Problem 7-1. The PARTITION procedure given in Section 7.1 is due to N. Lomuto.
The analysis in Section 7.4 is due to Avrim Blum. Sedgewick [305] and Bentley [43] provide a good reference on the details of implementation and how they
matter.
McIlroy [248] showed how to engineer a “killer adversary” that produces an
array on which virtually any implementation of quicksort takes ‚.n2 / time. If the
implementation is randomized, the adversary produces the array after seeing the
random choices of the quicksort algorithm.

8

Sorting in Linear Time

We have now introduced several algorithms that can sort n numbers in O.n lg n/
time. Merge sort and heapsort achieve this upper bound in the worst case; quicksort
achieves it on average. Moreover, for each of these algorithms, we can produce a
sequence of n input numbers that causes the algorithm to run in .n lg n/ time.
These algorithms share an interesting property: the sorted order they determine
is based only on comparisons between the input elements. We call such sorting
algorithms comparison sorts. All the sorting algorithms introduced thus far are
comparison sorts.
In Section 8.1, we shall prove that any comparison sort must make .n lg n/
comparisons in the worst case to sort n elements. Thus, merge sort and heapsort
are asymptotically optimal, and no comparison sort exists that is faster by more
than a constant factor.
Sections 8.2, 8.3, and 8.4 examine three sorting algorithms—counting sort, radix
sort, and bucket sort—that run in linear time. Of course, these algorithms use
operations other than comparisons to determine the sorted order. Consequently,
the .n lg n/ lower bound does not apply to them.

8.1 Lower bounds for sorting
In a comparison sort, we use only comparisons between elements to gain order
information about an input sequence ha1 ; a2 ; : : : ; an i. That is, given two elements
ai and aj , we perform one of the tests ai < aj , ai  aj , ai D aj , ai  aj , or
ai > aj to determine their relative order. We may not inspect the values of the
elements or gain order information about them in any other way.
In this section, we assume without loss of generality that all the input elements
are distinct. Given this assumption, comparisons of the form ai D aj are useless,
so we can assume that no comparisons of this form are made. We also note that
the comparisons ai  aj , ai  aj , ai > aj , and ai < aj are all equivalent in that

192

Chapter 8 Sorting in Linear Time

1:2
≤

>

>

≤

2:3

1:3

≤
〈1,2,3〉

〈2,1,3〉

1:3
≤
〈1,3,2〉

>
〈3,1,2〉

>
2:3
≤
〈2,3,1〉

>
〈3,2,1〉

Figure 8.1 The decision tree for insertion sort operating on three elements. An internal node annotated by i:j indicates a comparison between ai and aj . A leaf annotated by the permutation
h.1/; .2/; : : : ; .n/i indicates the ordering a.1/  a.2/      a.n/ . The shaded path
indicates the decisions made when sorting the input sequence ha1 D 6; a2 D 8; a3 D 5i; the
permutation h3; 1; 2i at the leaf indicates that the sorted ordering is a3 D 5  a1 D 6  a2 D 8.
There are 3Š D 6 possible permutations of the input elements, and so the decision tree must have at
least 6 leaves.

they yield identical information about the relative order of ai and aj . We therefore
assume that all comparisons have the form ai  aj .
The decision-tree model
We can view comparison sorts abstractly in terms of decision trees. A decision
tree is a full binary tree that represents the comparisons between elements that
are performed by a particular sorting algorithm operating on an input of a given
size. Control, data movement, and all other aspects of the algorithm are ignored.
Figure 8.1 shows the decision tree corresponding to the insertion sort algorithm
from Section 2.1 operating on an input sequence of three elements.
In a decision tree, we annotate each internal node by i:j for some i and j in the
range 1  i; j  n, where n is the number of elements in the input sequence. We
also annotate each leaf by a permutation h.1/; .2/; : : : ; .n/i. (See Section C.1
for background on permutations.) The execution of the sorting algorithm corresponds to tracing a simple path from the root of the decision tree down to a leaf.
Each internal node indicates a comparison ai  aj . The left subtree then dictates
subsequent comparisons once we know that ai  aj , and the right subtree dictates
subsequent comparisons knowing that ai > aj . When we come to a leaf, the sorting algorithm has established the ordering a.1/  a.2/      a.n/ . Because
any correct sorting algorithm must be able to produce each permutation of its input,
each of the nŠ permutations on n elements must appear as one of the leaves of the
decision tree for a comparison sort to be correct. Furthermore, each of these leaves
must be reachable from the root by a downward path corresponding to an actual

8.1 Lower bounds for sorting

193

execution of the comparison sort. (We shall refer to such leaves as “reachable.”)
Thus, we shall consider only decision trees in which each permutation appears as
a reachable leaf.
A lower bound for the worst case
The length of the longest simple path from the root of a decision tree to any of
its reachable leaves represents the worst-case number of comparisons that the corresponding sorting algorithm performs. Consequently, the worst-case number of
comparisons for a given comparison sort algorithm equals the height of its decision
tree. A lower bound on the heights of all decision trees in which each permutation
appears as a reachable leaf is therefore a lower bound on the running time of any
comparison sort algorithm. The following theorem establishes such a lower bound.
Theorem 8.1
Any comparison sort algorithm requires .n lg n/ comparisons in the worst case.
Proof From the preceding discussion, it sufﬁces to determine the height of a
decision tree in which each permutation appears as a reachable leaf. Consider a
decision tree of height h with l reachable leaves corresponding to a comparison
sort on n elements. Because each of the nŠ permutations of the input appears as
some leaf, we have nŠ  l. Since a binary tree of height h has no more than 2h
leaves, we have
nŠ  l  2h ;
which, by taking logarithms, implies
h  lg.nŠ/
(since the lg function is monotonically increasing)
D .n lg n/ (by equation (3.19)) .
Corollary 8.2
Heapsort and merge sort are asymptotically optimal comparison sorts.
Proof The O.n lg n/ upper bounds on the running times for heapsort and merge
sort match the .n lg n/ worst-case lower bound from Theorem 8.1.
Exercises
8.1-1
What is the smallest possible depth of a leaf in a decision tree for a comparison
sort?

194

Chapter 8 Sorting in Linear Time

8.1-2
Obtain asymptotically tight bounds on lg.nŠ/
Pn without using Stirling’s approximation. Instead, evaluate the summation kD1 lg k using techniques from Section A.2.
8.1-3
Show that there is no comparison sort whose running time is linear for at least half
of the nŠ inputs of length n. What about a fraction of 1=n of the inputs of length n?
What about a fraction 1=2n ?
8.1-4
Suppose that you are given a sequence of n elements to sort. The input sequence
consists of n=k subsequences, each containing k elements. The elements in a given
subsequence are all smaller than the elements in the succeeding subsequence and
larger than the elements in the preceding subsequence. Thus, all that is needed to
sort the whole sequence of length n is to sort the k elements in each of the n=k
subsequences. Show an .n lg k/ lower bound on the number of comparisons
needed to solve this variant of the sorting problem. (Hint: It is not rigorous to
simply combine the lower bounds for the individual subsequences.)

8.2

Counting sort
Counting sort assumes that each of the n input elements is an integer in the range
0 to k, for some integer k. When k D O.n/, the sort runs in ‚.n/ time.
Counting sort determines, for each input element x, the number of elements less
than x. It uses this information to place element x directly into its position in the
output array. For example, if 17 elements are less than x, then x belongs in output
position 18. We must modify this scheme slightly to handle the situation in which
several elements have the same value, since we do not want to put them all in the
same position.
In the code for counting sort, we assume that the input is an array AŒ1 : : n, and
thus A:length D n. We require two other arrays: the array BŒ1 : : n holds the
sorted output, and the array C Œ0 : : k provides temporary working storage.

8.2 Counting sort

1

2

3

4

5

6

7

8

A 2

5

3

0

2

3

0

3

0

1

2

3

4

5

C 2

0

2

3

0

1

195

1
0

1

2

3

4

5

C 2

2

4

7

7

8

1

2

3

4

5

6

7

3

0

8

1

B

2

3

4

5

0

5

6

B

6

7

3

3

1

2

3

4

5

0

1

2

3

4

5

C 1

2

4

6

7

8

C 1

2

4

5

7

8

(e)

4

7

8

3
0

1

2

3

4

5

C 2

2

4

6

7

8

(c)

0

(d)

3

(b)

(a)

B

2

8
1

2

3

4

5

6

7

8

B 0

0

2

2

3

3

3

5

(f)

Figure 8.2 The operation of C OUNTING -S ORT on an input array AŒ1 : : 8, where each element
of A is a nonnegative integer no larger than k D 5. (a) The array A and the auxiliary array C after
line 5. (b) The array C after line 8. (c)–(e) The output array B and the auxiliary array C after one,
two, and three iterations of the loop in lines 10–12, respectively. Only the lightly shaded elements of
array B have been ﬁlled in. (f) The ﬁnal sorted output array B.

C OUNTING -S ORT .A; B; k/
1 let C Œ0 : : k be a new array
2 for i D 0 to k
3
C Œi D 0
4 for j D 1 to A:length
5
C ŒAŒj  D C ŒAŒj  C 1
6 // C Œi now contains the number of elements equal to i.
7 for i D 1 to k
8
C Œi D C Œi C C Œi  1
9 // C Œi now contains the number of elements less than or equal to i.
10 for j D A:length downto 1
11
BŒC ŒAŒj  D AŒj 
12
C ŒAŒj  D C ŒAŒj   1
Figure 8.2 illustrates counting sort. After the for loop of lines 2–3 initializes the
array C to all zeros, the for loop of lines 4–5 inspects each input element. If the
value of an input element is i, we increment C Œi. Thus, after line 5, C Œi holds
the number of input elements equal to i for each integer i D 0; 1; : : : ; k. Lines 7–8
determine for each i D 0; 1; : : : ; k how many input elements are less than or equal
to i by keeping a running sum of the array C .

196

Chapter 8 Sorting in Linear Time

Finally, the for loop of lines 10–12 places each element AŒj  into its correct
sorted position in the output array B. If all n elements are distinct, then when we
ﬁrst enter line 10, for each AŒj , the value C ŒAŒj  is the correct ﬁnal position
of AŒj  in the output array, since there are C ŒAŒj  elements less than or equal
to AŒj . Because the elements might not be distinct, we decrement C ŒAŒj  each
time we place a value AŒj  into the B array. Decrementing C ŒAŒj  causes the
next input element with a value equal to AŒj , if one exists, to go to the position
immediately before AŒj  in the output array.
How much time does counting sort require? The for loop of lines 2–3 takes
time ‚.k/, the for loop of lines 4–5 takes time ‚.n/, the for loop of lines 7–8 takes
time ‚.k/, and the for loop of lines 10–12 takes time ‚.n/. Thus, the overall time
is ‚.k C n/. In practice, we usually use counting sort when we have k D O.n/, in
which case the running time is ‚.n/.
Counting sort beats the lower bound of .n lg n/ proved in Section 8.1 because
it is not a comparison sort. In fact, no comparisons between input elements occur
anywhere in the code. Instead, counting sort uses the actual values of the elements
to index into an array. The .n lg n/ lower bound for sorting does not apply when
we depart from the comparison sort model.
An important property of counting sort is that it is stable: numbers with the same
value appear in the output array in the same order as they do in the input array. That
is, it breaks ties between two numbers by the rule that whichever number appears
ﬁrst in the input array appears ﬁrst in the output array. Normally, the property of
stability is important only when satellite data are carried around with the element
being sorted. Counting sort’s stability is important for another reason: counting
sort is often used as a subroutine in radix sort. As we shall see in the next section,
in order for radix sort to work correctly, counting sort must be stable.
Exercises
8.2-1
Using Figure 8.2 as a model, illustrate the operation of C OUNTING -S ORT on the
array A D h6; 0; 2; 0; 1; 3; 4; 6; 1; 3; 2i.
8.2-2
Prove that C OUNTING -S ORT is stable.
8.2-3
Suppose that we were to rewrite the for loop header in line 10 of the C OUNTING S ORT as
10

for j D 1 to A:length

Show that the algorithm still works properly. Is the modiﬁed algorithm stable?

8.3 Radix sort

197

8.2-4
Describe an algorithm that, given n integers in the range 0 to k, preprocesses its
input and then answers any query about how many of the n integers fall into a
range Œa : : b in O.1/ time. Your algorithm should use ‚.n C k/ preprocessing
time.

8.3 Radix sort
Radix sort is the algorithm used by the card-sorting machines you now ﬁnd only in
computer museums. The cards have 80 columns, and in each column a machine can
punch a hole in one of 12 places. The sorter can be mechanically “programmed”
to examine a given column of each card in a deck and distribute the card into one
of 12 bins depending on which place has been punched. An operator can then
gather the cards bin by bin, so that cards with the ﬁrst place punched are on top of
cards with the second place punched, and so on.
For decimal digits, each column uses only 10 places. (The other two places
are reserved for encoding nonnumeric characters.) A d -digit number would then
occupy a ﬁeld of d columns. Since the card sorter can look at only one column
at a time, the problem of sorting n cards on a d -digit number requires a sorting
algorithm.
Intuitively, you might sort numbers on their most signiﬁcant digit, sort each of
the resulting bins recursively, and then combine the decks in order. Unfortunately,
since the cards in 9 of the 10 bins must be put aside to sort each of the bins, this
procedure generates many intermediate piles of cards that you would have to keep
track of. (See Exercise 8.3-5.)
Radix sort solves the problem of card sorting—counterintuitively—by sorting on
the least signiﬁcant digit ﬁrst. The algorithm then combines the cards into a single
deck, with the cards in the 0 bin preceding the cards in the 1 bin preceding the
cards in the 2 bin, and so on. Then it sorts the entire deck again on the second-least
signiﬁcant digit and recombines the deck in a like manner. The process continues
until the cards have been sorted on all d digits. Remarkably, at that point the cards
are fully sorted on the d -digit number. Thus, only d passes through the deck are
required to sort. Figure 8.3 shows how radix sort operates on a “deck” of seven
3-digit numbers.
In order for radix sort to work correctly, the digit sorts must be stable. The sort
performed by a card sorter is stable, but the operator has to be wary about not
changing the order of the cards as they come out of a bin, even though all the cards
in a bin have the same digit in the chosen column.

198

Chapter 8 Sorting in Linear Time

329
457
657
839
436
720
355

720
355
436
457
657
329
839

720
329
436
839
355
457
657

329
355
436
457
657
720
839

Figure 8.3 The operation of radix sort on a list of seven 3-digit numbers. The leftmost column is
the input. The remaining columns show the list after successive sorts on increasingly signiﬁcant digit
positions. Shading indicates the digit position sorted on to produce each list from the previous one.

In a typical computer, which is a sequential random-access machine, we sometimes use radix sort to sort records of information that are keyed by multiple ﬁelds.
For example, we might wish to sort dates by three keys: year, month, and day. We
could run a sorting algorithm with a comparison function that, given two dates,
compares years, and if there is a tie, compares months, and if another tie occurs,
compares days. Alternatively, we could sort the information three times with a
stable sort: ﬁrst on day, next on month, and ﬁnally on year.
The code for radix sort is straightforward. The following procedure assumes that
each element in the n-element array A has d digits, where digit 1 is the lowest-order
digit and digit d is the highest-order digit.
R ADIX -S ORT .A; d /
1 for i D 1 to d
2
use a stable sort to sort array A on digit i
Lemma 8.3
Given n d -digit numbers in which each digit can take on up to k possible values,
R ADIX -S ORT correctly sorts these numbers in ‚.d.n C k// time if the stable sort
it uses takes ‚.n C k/ time.
Proof The correctness of radix sort follows by induction on the column being
sorted (see Exercise 8.3-3). The analysis of the running time depends on the stable
sort used as the intermediate sorting algorithm. When each digit is in the range 0
to k1 (so that it can take on k possible values), and k is not too large, counting sort
is the obvious choice. Each pass over n d -digit numbers then takes time ‚.n C k/.
There are d passes, and so the total time for radix sort is ‚.d.n C k//.
When d is constant and k D O.n/, we can make radix sort run in linear time.
More generally, we have some ﬂexibility in how to break each key into digits.

8.3 Radix sort

199

Lemma 8.4
Given n b-bit numbers and any positive integer r  b, R ADIX -S ORT correctly sorts
these numbers in ‚..b=r/.n C 2r // time if the stable sort it uses takes ‚.n C k/
time for inputs in the range 0 to k.
Proof For a value r  b, we view each key as having d D db=re digits of r bits
each. Each digit is an integer in the range 0 to 2r  1, so that we can use counting
sort with k D 2r  1. (For example, we can view a 32-bit word as having four 8-bit
digits, so that b D 32, r D 8, k D 2r  1 D 255, and d D b=r D 4.) Each pass of
counting sort takes time ‚.n C k/ D ‚.n C 2r / and there are d passes, for a total
running time of ‚.d.n C 2r // D ‚..b=r/.n C 2r //.
For given values of n and b, we wish to choose the value of r, with r  b,
that minimizes the expression .b=r/.n C 2r /. If b < blg nc, then for any value
of r  b, we have that .n C 2r / D ‚.n/. Thus, choosing r D b yields a running
time of .b=b/.n C 2b / D ‚.n/, which is asymptotically optimal. If b  blg nc,
then choosing r D blg nc gives the best time to within a constant factor, which
we can see as follows. Choosing r D blg nc yields a running time of ‚.bn= lg n/.
As we increase r above blg nc, the 2r term in the numerator increases faster than
the r term in the denominator, and so increasing r above blg nc yields a running
time of .bn= lg n/. If instead we were to decrease r below blg nc, then the b=r
term increases and the n C 2r term remains at ‚.n/.
Is radix sort preferable to a comparison-based sorting algorithm, such as quicksort? If b D O.lg n/, as is often the case, and we choose r  lg n, then radix sort’s
running time is ‚.n/, which appears to be better than quicksort’s expected running
time of ‚.n lg n/. The constant factors hidden in the ‚-notation differ, however.
Although radix sort may make fewer passes than quicksort over the n keys, each
pass of radix sort may take signiﬁcantly longer. Which sorting algorithm we prefer
depends on the characteristics of the implementations, of the underlying machine
(e.g., quicksort often uses hardware caches more effectively than radix sort), and
of the input data. Moreover, the version of radix sort that uses counting sort as the
intermediate stable sort does not sort in place, which many of the ‚.n lg n/-time
comparison sorts do. Thus, when primary memory storage is at a premium, we
might prefer an in-place algorithm such as quicksort.
Exercises
8.3-1
Using Figure 8.3 as a model, illustrate the operation of R ADIX -S ORT on the following list of English words: COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB,
BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX.

200

Chapter 8 Sorting in Linear Time

8.3-2
Which of the following sorting algorithms are stable: insertion sort, merge sort,
heapsort, and quicksort? Give a simple scheme that makes any sorting algorithm
stable. How much additional time and space does your scheme entail?
8.3-3
Use induction to prove that radix sort works. Where does your proof need the
assumption that the intermediate sort is stable?
8.3-4
Show how to sort n integers in the range 0 to n3  1 in O.n/ time.
8.3-5 ?
In the ﬁrst card-sorting algorithm in this section, exactly how many sorting passes
are needed to sort d -digit decimal numbers in the worst case? How many piles of
cards would an operator need to keep track of in the worst case?

8.4

Bucket sort
Bucket sort assumes that the input is drawn from a uniform distribution and has an
average-case running time of O.n/. Like counting sort, bucket sort is fast because
it assumes something about the input. Whereas counting sort assumes that the input
consists of integers in a small range, bucket sort assumes that the input is generated
by a random process that distributes elements uniformly and independently over
the interval Œ0; 1/. (See Section C.2 for a deﬁnition of uniform distribution.)
Bucket sort divides the interval Œ0; 1/ into n equal-sized subintervals, or buckets,
and then distributes the n input numbers into the buckets. Since the inputs are uniformly and independently distributed over Œ0; 1/, we do not expect many numbers
to fall into each bucket. To produce the output, we simply sort the numbers in each
bucket and then go through the buckets in order, listing the elements in each.
Our code for bucket sort assumes that the input is an n-element array A and
that each element AŒi in the array satisﬁes 0  AŒi < 1. The code requires an
auxiliary array BŒ0 : : n  1 of linked lists (buckets) and assumes that there is a
mechanism for maintaining such lists. (Section 10.2 describes how to implement
basic operations on linked lists.)

8.4 Bucket sort

1
2
3
4
5
6
7
8
9
10

A
.78
.17
.39
.26
.72
.94
.21
.12
.23
.68
(a)

201

B
0
1
2
3

.12
.21
.39

.17
.23

.26

4
5
6
7

.68
.72

.78

8
9

.94
(b)

Figure 8.4 The operation of B UCKET-S ORT for n D 10. (a) The input array AŒ1 : : 10. (b) The
array BŒ0 : : 9 of sorted lists (buckets) after line 8 of the algorithm. Bucket i holds values in the
half-open interval Œi=10; .i C 1/=10/. The sorted output consists of a concatenation in order of the
lists BŒ0; BŒ1; : : : ; BŒ9.

B UCKET-S ORT .A/
1 let BŒ0 : : n  1 be a new array
2 n D A:length
3 for i D 0 to n  1
4
make BŒi an empty list
5 for i D 1 to n
6
insert AŒi into list BŒbnAŒic
7 for i D 0 to n  1
8
sort list BŒi with insertion sort
9 concatenate the lists BŒ0; BŒ1; : : : ; BŒn  1 together in order
Figure 8.4 shows the operation of bucket sort on an input array of 10 numbers.
To see that this algorithm works, consider two elements AŒi and AŒj . Assume
without loss of generality that AŒi  AŒj . Since bnAŒic  bnAŒj c, either
element AŒi goes into the same bucket as AŒj  or it goes into a bucket with a lower
index. If AŒi and AŒj  go into the same bucket, then the for loop of lines 7–8 puts
them into the proper order. If AŒi and AŒj  go into different buckets, then line 9
puts them into the proper order. Therefore, bucket sort works correctly.
To analyze the running time, observe that all lines except line 8 take O.n/ time
in the worst case. We need to analyze the total time taken by the n calls to insertion
sort in line 8.

202

Chapter 8 Sorting in Linear Time

To analyze the cost of the calls to insertion sort, let ni be the random variable
denoting the number of elements placed in bucket BŒi. Since insertion sort runs
in quadratic time (see Section 2.2), the running time of bucket sort is
T .n/ D ‚.n/ C

n1
X

O.n2i / :

i D0

We now analyze the average-case running time of bucket sort, by computing the
expected value of the running time, where we take the expectation over the input
distribution. Taking expectations of both sides and using linearity of expectation,
we have
#
"
n1
X
O.n2i /
E ŒT .n/ D E ‚.n/ C
i D0

D ‚.n/ C

n1
X



E O.n2i /

(by linearity of expectation)

 
O E n2i

(by equation (C.22)) .

i D0

D ‚.n/ C

n1
X

(8.1)

i D0

We claim that
 
E n2i D 2  1=n

(8.2)

for i D 0; 1; : : : ; n  1. It is no surprise that each bucket i has the same value of
E Œn2i , since each value in the input array A is equally likely to fall in any bucket.
To prove equation (8.2), we deﬁne indicator random variables
Xij D I fAŒj  falls in bucket i g
for i D 0; 1; : : : ; n  1 and j D 1; 2; : : : ; n. Thus,
ni D

n
X

Xij :

j D1

To compute E Œn2i , we expand the square and regroup terms:

8.4 Bucket sort

 
E n2i
D E

203

"

n
X

!2 #
Xij

j D1

D E

" n n
XX

#
Xij Xi k

j D1 kD1

2 n
X
X
Xij2 C
D E4
j D1

D

X

Xij Xi k 5

1j n 1kn
k¤j

n
X
X
 
E Xij2 C
j D1

3

X

E ŒXij Xi k  ;

(8.3)

1j n 1kn
k¤j

where the last line follows by linearity of expectation. We evaluate the two summations separately. Indicator random variable Xij is 1 with probability 1=n and 0
otherwise, and therefore


 2
1
2 1
2
E Xij D 1  C 0  1 
n
n
1
:
D
n
When k ¤ j , the variables Xij and Xi k are independent, and hence
E ŒXij Xi k  D E ŒXij  E ŒXi k 
1 1

D
n n
1
:
D
n2
Substituting these two expected values in equation (8.3), we obtain
n
X X 1
X
 
1
C
D
E n2i
n 1j n
n2
j D1
1kn
k¤j

1
1
C n.n  1/  2
n
n
n1
D 1C
n
1
D 2 ;
n
which proves equation (8.2).
D n

204

Chapter 8 Sorting in Linear Time

Using this expected value in equation (8.1), we conclude that the average-case
running time for bucket sort is ‚.n/ C n  O.2  1=n/ D ‚.n/.
Even if the input is not drawn from a uniform distribution, bucket sort may still
run in linear time. As long as the input has the property that the sum of the squares
of the bucket sizes is linear in the total number of elements, equation (8.1) tells us
that bucket sort will run in linear time.
Exercises
8.4-1
Using Figure 8.4 as a model, illustrate the operation of B UCKET-S ORT on the array
A D h:79; :13; :16; :64; :39; :20; :89; :53; :71; :42i.
8.4-2
Explain why the worst-case running time for bucket sort is ‚.n2 /. What simple
change to the algorithm preserves its linear average-case running time and makes
its worst-case running time O.n lg n/?
8.4-3
Let X be a random variable that is equal to the number of heads in two ﬂips of a
fair coin. What is E ŒX 2 ? What is E2 ŒX ?
8.4-4 ?
We are given n points in the unit circle, pi D .xi ; yi /, such that 0 < xi2 C yi2  1
for i D 1; 2; : : : ; n. Suppose that the points are uniformly distributed; that is, the
probability of ﬁnding a point in any region of the circle is proportional to the area
of that region. Design an algorithm withp
an average-case running time of ‚.n/ to
sort the n points by their distances di D xi2 C yi2 from the origin. (Hint: Design
the bucket sizes in B UCKET-S ORT to reﬂect the uniform distribution of the points
in the unit circle.)
8.4-5 ?
A probability distribution function P .x/ for a random variable X is deﬁned
by P .x/ D Pr fX  xg. Suppose that we draw a list of n random variables
X1 ; X2 ; : : : ; Xn from a continuous probability distribution function P that is computable in O.1/ time. Give an algorithm that sorts these numbers in linear averagecase time.

Problems for Chapter 8

205

Problems
8-1 Probabilistic lower bounds on comparison sorting
In this problem, we prove a probabilistic .n lg n/ lower bound on the running time
of any deterministic or randomized comparison sort on n distinct input elements.
We begin by examining a deterministic comparison sort A with decision tree TA .
We assume that every permutation of A’s inputs is equally likely.
a. Suppose that each leaf of TA is labeled with the probability that it is reached
given a random input. Prove that exactly nŠ leaves are labeled 1=nŠ and that the
rest are labeled 0.
b. Let D.T / denote the external path length of a decision tree T ; that is, D.T /
is the sum of the depths of all the leaves of T . Let T be a decision tree with
k > 1 leaves, and let LT and RT be the left and right subtrees of T . Show that
D.T / D D.LT/ C D.RT/ C k.
c. Let d.k/ be the minimum value of D.T / over all decision trees T with k > 1
leaves. Show that d.k/ D min1i k1 fd.i/ C d.k  i/ C kg. (Hint: Consider
a decision tree T with k leaves that achieves the minimum. Let i0 be the number
of leaves in LT and k  i0 the number of leaves in RT.)
d. Prove that for a given value of k > 1 and i in the range 1  i  k  1, the
function i lg i C .k  i/ lg.k  i/ is minimized at i D k=2. Conclude that
d.k/ D .k lg k/.
e. Prove that D.TA / D .nŠ lg.nŠ//, and conclude that the average-case time to
sort n elements is .n lg n/.
Now, consider a randomized comparison sort B. We can extend the decisiontree model to handle randomization by incorporating two kinds of nodes: ordinary
comparison nodes and “randomization” nodes. A randomization node models a
random choice of the form R ANDOM .1; r/ made by algorithm B; the node has r
children, each of which is equally likely to be chosen during an execution of the
algorithm.
f. Show that for any randomized comparison sort B, there exists a deterministic
comparison sort A whose expected number of comparisons is no more than
those made by B.

206

Chapter 8 Sorting in Linear Time

8-2 Sorting in place in linear time
Suppose that we have an array of n data records to sort and that the key of each
record has the value 0 or 1. An algorithm for sorting such a set of records might
possess some subset of the following three desirable characteristics:
1. The algorithm runs in O.n/ time.
2. The algorithm is stable.
3. The algorithm sorts in place, using no more than a constant amount of storage
space in addition to the original array.
a. Give an algorithm that satisﬁes criteria 1 and 2 above.
b. Give an algorithm that satisﬁes criteria 1 and 3 above.
c. Give an algorithm that satisﬁes criteria 2 and 3 above.
d. Can you use any of your sorting algorithms from parts (a)–(c) as the sorting
method used in line 2 of R ADIX -S ORT, so that R ADIX -S ORT sorts n records
with b-bit keys in O.bn/ time? Explain how or why not.
e. Suppose that the n records have keys in the range from 1 to k. Show how to
modify counting sort so that it sorts the records in place in O.n C k/ time. You
may use O.k/ storage outside the input array. Is your algorithm stable? (Hint:
How would you do it for k D 3?)
8-3 Sorting variable-length items
a. You are given an array of integers, where different integers may have different
numbers of digits, but the total number of digits over all the integers in the array
is n. Show how to sort the array in O.n/ time.
b. You are given an array of strings, where different strings may have different
numbers of characters, but the total number of characters over all the strings
is n. Show how to sort the strings in O.n/ time.
(Note that the desired order here is the standard alphabetical order; for example,
a < ab < b.)
8-4 Water jugs
Suppose that you are given n red and n blue water jugs, all of different shapes and
sizes. All red jugs hold different amounts of water, as do the blue ones. Moreover,
for every red jug, there is a blue jug that holds the same amount of water, and vice
versa.

Problems for Chapter 8

207

Your task is to ﬁnd a grouping of the jugs into pairs of red and blue jugs that hold
the same amount of water. To do so, you may perform the following operation: pick
a pair of jugs in which one is red and one is blue, ﬁll the red jug with water, and
then pour the water into the blue jug. This operation will tell you whether the red
or the blue jug can hold more water, or that they have the same volume. Assume
that such a comparison takes one time unit. Your goal is to ﬁnd an algorithm that
makes a minimum number of comparisons to determine the grouping. Remember
that you may not directly compare two red jugs or two blue jugs.
a. Describe a deterministic algorithm that uses ‚.n2 / comparisons to group the
jugs into pairs.
b. Prove a lower bound of .n lg n/ for the number of comparisons that an algorithm solving this problem must make.
c. Give a randomized algorithm whose expected number of comparisons is
O.n lg n/, and prove that this bound is correct. What is the worst-case number of comparisons for your algorithm?
8-5 Average sorting
Suppose that, instead of sorting an array, we just require that the elements increase
on average. More precisely, we call an n-element array A k-sorted if, for all
i D 1; 2; : : : ; n  k, the following holds:
Pi Ck
Pi Ck1
AŒj 
j Di
j Di C1 AŒj 

:
k
k
a. What does it mean for an array to be 1-sorted?
b. Give a permutation of the numbers 1; 2; : : : ; 10 that is 2-sorted, but not sorted.
c. Prove that an n-element array is k-sorted if and only if AŒi  AŒi C k for all
i D 1; 2; : : : ; n  k.
d. Give an algorithm that k-sorts an n-element array in O.n lg.n=k// time.
We can also show a lower bound on the time to produce a k-sorted array, when k
is a constant.
e. Show that we can sort a k-sorted array of length n in O.n lg k/ time. (Hint:
Use the solution to Exercise 6.5-9. )
f. Show that when k is a constant, k-sorting an n-element array requires .n lg n/
time. (Hint: Use the solution to the previous part along with the lower bound
on comparison sorts.)

208

Chapter 8 Sorting in Linear Time

8-6 Lower bound on merging sorted lists
The problem of merging two sorted lists arises frequently. We have seen a procedure for it as the subroutine M ERGE in Section 2.3.1. In this problem, we will
prove a lower bound of 2n  1 on the worst-case number of comparisons required
to merge two sorted lists, each containing n items.
First we will show a lower bound of 2n  o.n/ comparisons by using a decision
tree.
a. Given 2n numbers, compute the number of possible ways to divide them into
two sorted lists, each with n numbers.
b. Using a decision tree and your answer to part (a), show that any algorithm that
correctly merges two sorted lists must perform at least 2n  o.n/ comparisons.
Now we will show a slightly tighter 2n  1 bound.
c. Show that if two elements are consecutive in the sorted order and from different
lists, then they must be compared.
d. Use your answer to the previous part to show a lower bound of 2n  1 comparisons for merging two sorted lists.
8-7 The 0-1 sorting lemma and columnsort
A compare-exchange operation on two array elements AŒi and AŒj , where i < j ,
has the form
C OMPARE -E XCHANGE .A; i; j /
1 if AŒi > AŒj 
2
exchange AŒi with AŒj 
After the compare-exchange operation, we know that AŒi  AŒj .
An oblivious compare-exchange algorithm operates solely by a sequence of
prespeciﬁed compare-exchange operations. The indices of the positions compared
in the sequence must be determined in advance, and although they can depend
on the number of elements being sorted, they cannot depend on the values being
sorted, nor can they depend on the result of any prior compare-exchange operation.
For example, here is insertion sort expressed as an oblivious compare-exchange
algorithm:
I NSERTION -S ORT .A/
1 for j D 2 to A:length
2
for i D j  1 downto 1
3
C OMPARE -E XCHANGE .A; i; i C 1/

Problems for Chapter 8

209

The 0-1 sorting lemma provides a powerful way to prove that an oblivious
compare-exchange algorithm produces a sorted result. It states that if an oblivious compare-exchange algorithm correctly sorts all input sequences consisting of
only 0s and 1s, then it correctly sorts all inputs containing arbitrary values.
You will prove the 0-1 sorting lemma by proving its contrapositive: if an oblivious compare-exchange algorithm fails to sort an input containing arbitrary values,
then it fails to sort some 0-1 input. Assume that an oblivious compare-exchange algorithm X fails to correctly sort the array AŒ1 : : n. Let AŒp be the smallest value
in A that algorithm X puts into the wrong location, and let AŒq be the value that
algorithm X moves to the location into which AŒp should have gone. Deﬁne an
array BŒ1 : : n of 0s and 1s as follows:
(
0 if AŒi  AŒp ;
BŒi D
1 if AŒi > AŒp :
a. Argue that AŒq > AŒp, so that BŒp D 0 and BŒq D 1.
b. To complete the proof of the 0-1 sorting lemma, prove that algorithm X fails to
sort array B correctly.
Now you will use the 0-1 sorting lemma to prove that a particular sorting algorithm works correctly. The algorithm, columnsort, works on a rectangular array
of n elements. The array has r rows and s columns (so that n D rs), subject to
three restrictions:


r must be even,



s must be a divisor of r, and



r  2s 2 .

When columnsort completes, the array is sorted in column-major order: reading
down the columns, from left to right, the elements monotonically increase.
Columnsort operates in eight steps, regardless of the value of n. The odd steps
are all the same: sort each column individually. Each even step is a ﬁxed permutation. Here are the steps:
1. Sort each column.
2. Transpose the array, but reshape it back to r rows and s columns. In other
words, turn the leftmost column into the top r=s rows, in order; turn the next
column into the next r=s rows, in order; and so on.
3. Sort each column.
4. Perform the inverse of the permutation performed in step 2.

210

Chapter 8 Sorting in Linear Time
10
8
12
16
4
18

14
7
1
9
15
3
(a)

5
17
6
11
2
13

1
2
3
5
6
7

4
8
9
10
13
15
(f)

11
12
14
16
17
18

4
8
10
12
16
18

1
2
3

1
3
7
9
14
15
(b)

5
6
7
4
8
9

10
13
15
11
12
14
(g)

2
5
6
11
13
17

4
12
1
9
2
11

16
17
18
1
2
3

8
16
3
14
5
13
(c)

4
5
6
7
8
9

10
11
12
13
14
15
(h)

10
18
7
15
6
17

16
17
18

1
2
4
9
11
12

3
5
8
13
14
16
(d)

6
7
10
15
17
18

1
2
3
4
5
6

7
8
9
10
11
12
(i)

13
14
15
16
17
18

1
3
6
2
5
7

4
8
10
9
13
15
(e)

11
14
17
12
16
18

Figure 8.5 The steps of columnsort. (a) The input array with 6 rows and 3 columns. (b) After
sorting each column in step 1. (c) After transposing and reshaping in step 2. (d) After sorting each
column in step 3. (e) After performing step 4, which inverts the permutation from step 2. (f) After
sorting each column in step 5. (g) After shifting by half a column in step 6. (h) After sorting each
column in step 7. (i) After performing step 8, which inverts the permutation from step 6. The array
is now sorted in column-major order.

5. Sort each column.
6. Shift the top half of each column into the bottom half of the same column, and
shift the bottom half of each column into the top half of the next column to the
right. Leave the top half of the leftmost column empty. Shift the bottom half
of the last column into the top half of a new rightmost column, and leave the
bottom half of this new column empty.
7. Sort each column.
8. Perform the inverse of the permutation performed in step 6.
Figure 8.5 shows an example of the steps of columnsort with r D 6 and s D 3.
(Even though this example violates the requirement that r  2s 2 , it happens to
work.)
c. Argue that we can treat columnsort as an oblivious compare-exchange algorithm, even if we do not know what sorting method the odd steps use.
Although it might seem hard to believe that columnsort actually sorts, you will
use the 0-1 sorting lemma to prove that it does. The 0-1 sorting lemma applies
because we can treat columnsort as an oblivious compare-exchange algorithm. A

Notes for Chapter 8

211

couple of deﬁnitions will help you apply the 0-1 sorting lemma. We say that an area
of an array is clean if we know that it contains either all 0s or all 1s. Otherwise,
the area might contain mixed 0s and 1s, and it is dirty. From here on, assume that
the input array contains only 0s and 1s, and that we can treat it as an array with r
rows and s columns.
d. Prove that after steps 1–3, the array consists of some clean rows of 0s at the top,
some clean rows of 1s at the bottom, and at most s dirty rows between them.
e. Prove that after step 4, the array, read in column-major order, starts with a clean
area of 0s, ends with a clean area of 1s, and has a dirty area of at most s 2
elements in the middle.
f. Prove that steps 5–8 produce a fully sorted 0-1 output. Conclude that columnsort correctly sorts all inputs containing arbitrary values.
g. Now suppose that s does not divide r. Prove that after steps 1–3, the array
consists of some clean rows of 0s at the top, some clean rows of 1s at the
bottom, and at most 2s  1 dirty rows between them. How large must r be,
compared with s, for columnsort to correctly sort when s does not divide r?
h. Suggest a simple change to step 1 that allows us to maintain the requirement
that r  2s 2 even when s does not divide r, and prove that with your change,
columnsort correctly sorts.

Chapter notes
The decision-tree model for studying comparison sorts was introduced by Ford
and Johnson [110]. Knuth’s comprehensive treatise on sorting [211] covers many
variations on the sorting problem, including the information-theoretic lower bound
on the complexity of sorting given here. Ben-Or [39] studied lower bounds for
sorting using generalizations of the decision-tree model.
Knuth credits H. H. Seward with inventing counting sort in 1954, as well as with
the idea of combining counting sort with radix sort. Radix sorting starting with the
least signiﬁcant digit appears to be a folk algorithm widely used by operators of
mechanical card-sorting machines. According to Knuth, the ﬁrst published reference to the method is a 1929 document by L. J. Comrie describing punched-card
equipment. Bucket sorting has been in use since 1956, when the basic idea was
proposed by E. J. Isaac and R. C. Singleton [188].
Munro and Raman [263] give a stable sorting algorithm that performs O.n1C /
comparisons in the worst case, where 0 <   1 is any ﬁxed constant. Although

212

Chapter 8 Sorting in Linear Time

any of the O.n lg n/-time algorithms make fewer comparisons, the algorithm by
Munro and Raman moves data only O.n/ times and operates in place.
The case of sorting n b-bit integers in o.n lg n/ time has been considered by
many researchers. Several positive results have been obtained, each under slightly
different assumptions about the model of computation and the restrictions placed
on the algorithm. All the results assume that the computer memory is divided into
addressable b-bit words. Fredman and Willard [115] introduced the fusion tree data
structure and used it topsort n integers in O.n lg n= lg lg n/ time. This bound was
later improved to O.n lg n/ time by Andersson [16]. These algorithms require
the use of multiplication and several precomputed constants. Andersson, Hagerup,
Nilsson, and Raman [17] have shown how to sort n integers in O.n lg lg n/ time
without using multiplication, but their method requires storage that can be unbounded in terms of n. Using multiplicative hashing, we can reduce the storage
needed to O.n/, but then the O.n lg lg n/ worst-case bound on the running time
becomes an expected-time bound. Generalizing the exponential search trees of
Andersson [16], Thorup [335] gave an O.n.lg lg n/2 /-time sorting algorithm that
does not use multiplication or randomization, and it uses linear space. Combining
these techniques with some new ideas, Han [158] improved the bound for sorting
to O.n lg lg n lg lg lg n/ time. Although these algorithms are important theoretical
breakthroughs, they are all fairly complicated and at the present time seem unlikely
to compete with existing sorting algorithms in practice.
The columnsort algorithm in Problem 8-7 is by Leighton [227].

9

Medians and Order Statistics

The ith order statistic of a set of n elements is the ith smallest element. For
example, the minimum of a set of elements is the ﬁrst order statistic (i D 1),
and the maximum is the nth order statistic (i D n). A median, informally, is
the “halfway point” of the set. When n is odd, the median is unique, occurring at
i D .n C 1/=2. When n is even, there are two medians, occurring at i D n=2 and
i D n=2C1. Thus, regardless of the parity of n, medians occur at i D b.n C 1/=2c
(the lower median) and i D d.n C 1/=2e (the upper median). For simplicity in
this text, however, we consistently use the phrase “the median” to refer to the lower
median.
This chapter addresses the problem of selecting the ith order statistic from a
set of n distinct numbers. We assume for convenience that the set contains distinct numbers, although virtually everything that we do extends to the situation in
which a set contains repeated values. We formally specify the selection problem
as follows:
Input: A set A of n (distinct) numbers and an integer i, with 1  i  n.
Output: The element x 2 A that is larger than exactly i  1 other elements of A.
We can solve the selection problem in O.n lg n/ time, since we can sort the numbers using heapsort or merge sort and then simply index the ith element in the
output array. This chapter presents faster algorithms.
In Section 9.1, we examine the problem of selecting the minimum and maximum of a set of elements. More interesting is the general selection problem, which
we investigate in the subsequent two sections. Section 9.2 analyzes a practical
randomized algorithm that achieves an O.n/ expected running time, assuming distinct elements. Section 9.3 contains an algorithm of more theoretical interest that
achieves the O.n/ running time in the worst case.

214

9.1

Chapter 9 Medians and Order Statistics

Minimum and maximum
How many comparisons are necessary to determine the minimum of a set of n
elements? We can easily obtain an upper bound of n  1 comparisons: examine
each element of the set in turn and keep track of the smallest element seen so
far. In the following procedure, we assume that the set resides in array A, where
A:length D n.
M INIMUM .A/
1 min D AŒ1
2 for i D 2 to A:length
3
if min > AŒi
4
min D AŒi
5 return min
We can, of course, ﬁnd the maximum with n  1 comparisons as well.
Is this the best we can do? Yes, since we can obtain a lower bound of n  1
comparisons for the problem of determining the minimum. Think of any algorithm
that determines the minimum as a tournament among the elements. Each comparison is a match in the tournament in which the smaller of the two elements wins.
Observing that every element except the winner must lose at least one match, we
conclude that n  1 comparisons are necessary to determine the minimum. Hence,
the algorithm M INIMUM is optimal with respect to the number of comparisons
performed.
Simultaneous minimum and maximum
In some applications, we must ﬁnd both the minimum and the maximum of a set
of n elements. For example, a graphics program may need to scale a set of .x; y/
data to ﬁt onto a rectangular display screen or other graphical output device. To
do so, the program must ﬁrst determine the minimum and maximum value of each
coordinate.
At this point, it should be obvious how to determine both the minimum and the
maximum of n elements using ‚.n/ comparisons, which is asymptotically optimal:
simply ﬁnd the minimum and maximum independently, using n  1 comparisons
for each, for a total of 2n  2 comparisons.
In fact, we can ﬁnd both the minimum and the maximum using at most 3 bn=2c
comparisons. We do so by maintaining both the minimum and maximum elements
seen thus far. Rather than processing each element of the input by comparing it
against the current minimum and maximum, at a cost of 2 comparisons per element,

9.2 Selection in expected linear time

215

we process elements in pairs. We compare pairs of elements from the input ﬁrst
with each other, and then we compare the smaller with the current minimum and
the larger to the current maximum, at a cost of 3 comparisons for every 2 elements.
How we set up initial values for the current minimum and maximum depends
on whether n is odd or even. If n is odd, we set both the minimum and maximum
to the value of the ﬁrst element, and then we process the rest of the elements in
pairs. If n is even, we perform 1 comparison on the ﬁrst 2 elements to determine
the initial values of the minimum and maximum, and then process the rest of the
elements in pairs as in the case for odd n.
Let us analyze the total number of comparisons. If n is odd, then we perform
3 bn=2c comparisons. If n is even, we perform 1 initial comparison followed by
3.n  2/=2 comparisons, for a total of 3n=2  2. Thus, in either case, the total
number of comparisons is at most 3 bn=2c.
Exercises
9.1-1
Show that the second smallest of n elements can be found with n C dlg ne  2
comparisons in the worst case. (Hint: Also ﬁnd the smallest element.)
9.1-2 ?
Prove the lower bound of d3n=2e  2 comparisons in the worst case to ﬁnd both
the maximum and minimum of n numbers. (Hint: Consider how many numbers
are potentially either the maximum or minimum, and investigate how a comparison
affects these counts.)

9.2 Selection in expected linear time
The general selection problem appears more difﬁcult than the simple problem of
ﬁnding a minimum. Yet, surprisingly, the asymptotic running time for both problems is the same: ‚.n/. In this section, we present a divide-and-conquer algorithm
for the selection problem. The algorithm R ANDOMIZED -S ELECT is modeled after
the quicksort algorithm of Chapter 7. As in quicksort, we partition the input array
recursively. But unlike quicksort, which recursively processes both sides of the
partition, R ANDOMIZED -S ELECT works on only one side of the partition. This
difference shows up in the analysis: whereas quicksort has an expected running
time of ‚.n lg n/, the expected running time of R ANDOMIZED -S ELECT is ‚.n/,
assuming that the elements are distinct.

216

Chapter 9 Medians and Order Statistics

R ANDOMIZED -S ELECT uses the procedure R ANDOMIZED -PARTITION introduced in Section 7.3. Thus, like R ANDOMIZED -Q UICKSORT, it is a randomized algorithm, since its behavior is determined in part by the output of a random-number
generator. The following code for R ANDOMIZED -S ELECT returns the ith smallest
element of the array AŒp : : r.
R ANDOMIZED -S ELECT .A; p; r; i/
1 if p == r
2
return AŒp
3 q D R ANDOMIZED -PARTITION .A; p; r/
4 k D qpC1
// the pivot value is the answer
5 if i == k
6
return AŒq
7 elseif i < k
8
return R ANDOMIZED -S ELECT .A; p; q  1; i/
9 else return R ANDOMIZED -S ELECT .A; q C 1; r; i  k/
The R ANDOMIZED -S ELECT procedure works as follows. Line 1 checks for the
base case of the recursion, in which the subarray AŒp : : r consists of just one
element. In this case, i must equal 1, and we simply return AŒp in line 2 as the
ith smallest element. Otherwise, the call to R ANDOMIZED -PARTITION in line 3
partitions the array AŒp : : r into two (possibly empty) subarrays AŒp : : q  1
and AŒq C 1 : : r such that each element of AŒp : : q  1 is less than or equal
to AŒq, which in turn is less than each element of AŒq C 1 : : r. As in quicksort,
we will refer to AŒq as the pivot element. Line 4 computes the number k of
elements in the subarray AŒp : : q, that is, the number of elements in the low side
of the partition, plus one for the pivot element. Line 5 then checks whether AŒq is
the ith smallest element. If it is, then line 6 returns AŒq. Otherwise, the algorithm
determines in which of the two subarrays AŒp : : q  1 and AŒq C 1 : : r the ith
smallest element lies. If i < k, then the desired element lies on the low side of
the partition, and line 8 recursively selects it from the subarray. If i > k, however,
then the desired element lies on the high side of the partition. Since we already
know k values that are smaller than the ith smallest element of AŒp : : r—namely,
the elements of AŒp : : q—the desired element is the .i  k/th smallest element
of AŒq C 1 : : r, which line 9 ﬁnds recursively. The code appears to allow recursive
calls to subarrays with 0 elements, but Exercise 9.2-1 asks you to show that this
situation cannot happen.
The worst-case running time for R ANDOMIZED -S ELECT is ‚.n2 /, even to ﬁnd
the minimum, because we could be extremely unlucky and always partition around
the largest remaining element, and partitioning takes ‚.n/ time. We will see that

9.2 Selection in expected linear time

217

the algorithm has a linear expected running time, though, and because it is randomized, no particular input elicits the worst-case behavior.
To analyze the expected running time of R ANDOMIZED -S ELECT, we let the running time on an input array AŒp : : r of n elements be a random variable that we
denote by T .n/, and we obtain an upper bound on E ŒT .n/ as follows. The procedure R ANDOMIZED -PARTITION is equally likely to return any element as the
pivot. Therefore, for each k such that 1  k  n, the subarray AŒp : : q has k elements (all less than or equal to the pivot) with probability 1=n. For k D 1; 2; : : : ; n,
we deﬁne indicator random variables Xk where
Xk D I fthe subarray AŒp : : q has exactly k elementsg ;
and so, assuming that the elements are distinct, we have
E ŒXk  D 1=n :

(9.1)

When we call R ANDOMIZED -S ELECT and choose AŒq as the pivot element, we
do not know, a priori, if we will terminate immediately with the correct answer,
recurse on the subarray AŒp : : q  1, or recurse on the subarray AŒq C 1 : : r.
This decision depends on where the ith smallest element falls relative to AŒq.
Assuming that T .n/ is monotonically increasing, we can upper-bound the time
needed for the recursive call by the time needed for the recursive call on the largest
possible input. In other words, to obtain an upper bound, we assume that the ith
element is always on the side of the partition with the greater number of elements.
For a given call of R ANDOMIZED -S ELECT, the indicator random variable Xk has
the value 1 for exactly one value of k, and it is 0 for all other k. When Xk D 1, the
two subarrays on which we might recurse have sizes k  1 and n  k. Hence, we
have the recurrence
T .n/ 

n
X

Xk  .T .max.k  1; n  k// C O.n//

kD1

D

n
X
kD1

Xk  T .max.k  1; n  k// C O.n/ :

218

Chapter 9 Medians and Order Statistics

Taking expected values, we have
E ŒT .n/
#
" n
X
Xk  T .max.k  1; n  k// C O.n/
 E
kD1

D
D
D

n
X
kD1
n
X
kD1
n
X
kD1

E ŒXk  T .max.k  1; n  k// C O.n/

(by linearity of expectation)

E ŒXk   E ŒT .max.k  1; n  k// C O.n/ (by equation (C.24))
1
 E ŒT .max.k  1; n  k// C O.n/
n

(by equation (9.1)) .

In order to apply equation (C.24), we rely on Xk and T .max.k  1; n  k// being
independent random variables. Exercise 9.2-2 asks you to justify this assertion.
Let us consider the expression max.k  1; n  k/. We have
(
k  1 if k > dn=2e ;
max.k  1; n  k/ D
n  k if k  dn=2e :
If n is even, each term from T .dn=2e/ up to T .n  1/ appears exactly twice in
the summation, and if n is odd, all these terms appear twice and T .bn=2c/ appears
once. Thus, we have
n1
2 X
E ŒT .k/ C O.n/ :
E ŒT .n/ 
n
kDbn=2c

We show that E ŒT .n/ D O.n/ by substitution. Assume that E ŒT .n/  cn for
some constant c that satisﬁes the initial conditions of the recurrence. We assume
that T .n/ D O.1/ for n less than some constant; we shall pick this constant later.
We also pick a constant a such that the function described by the O.n/ term above
(which describes the non-recursive component of the running time of the algorithm) is bounded from above by an for all n > 0. Using this inductive hypothesis,
we have
E ŒT .n/ 

n1
2 X
ck C an
n
kDbn=2c

D

2c
n

n1
X
kD1

X

bn=2c1

k

kD1

!
k C an

9.2 Selection in expected linear time

219



2c .n  1/n .bn=2c  1/ bn=2c

C an
n
2
2


2c .n  1/n .n=2  2/.n=2  1/

C an

n
2
2


2c n2  n n2 =4  3n=2 C 2

C an
D
n
2
2
 2

n
c 3n
C  2 C an
D
n
4
2


1 2
3n
C 
C an
D c
4
2 n
3cn c
C C an

4 2

cn c
  an :
D cn 
4
2
In order to complete the proof, we need to show that for sufﬁciently large n, this
last expression is at most cn or, equivalently, that cn=4  c=2  an  0. If we
add c=2 to both sides and factor out n, we get n.c=4  a/  c=2. As long as we
choose the constant c so that c=4  a > 0, i.e., c > 4a, we can divide both sides
by c=4  a, giving
D

n

2c
c=2
D
:
c=4  a
c  4a

Thus, if we assume that T .n/ D O.1/ for n < 2c=.c 4a/, then E ŒT .n/ D O.n/.
We conclude that we can ﬁnd any order statistic, and in particular the median, in
expected linear time, assuming that the elements are distinct.
Exercises
9.2-1
Show that R ANDOMIZED -S ELECT never makes a recursive call to a 0-length array.
9.2-2
Argue that the indicator random variable Xk and the value T .max.k  1; n  k//
are independent.
9.2-3
Write an iterative version of R ANDOMIZED -S ELECT.

220

Chapter 9 Medians and Order Statistics

9.2-4
Suppose we use R ANDOMIZED -S ELECT to select the minimum element of the
array A D h3; 2; 9; 0; 7; 5; 4; 8; 6; 1i. Describe a sequence of partitions that results
in a worst-case performance of R ANDOMIZED -S ELECT.

9.3

Selection in worst-case linear time
We now examine a selection algorithm whose running time is O.n/ in the worst
case. Like R ANDOMIZED -S ELECT, the algorithm S ELECT ﬁnds the desired element by recursively partitioning the input array. Here, however, we guarantee a
good split upon partitioning the array. S ELECT uses the deterministic partitioning
algorithm PARTITION from quicksort (see Section 7.1), but modiﬁed to take the
element to partition around as an input parameter.
The S ELECT algorithm determines the ith smallest of an input array of n > 1
distinct elements by executing the following steps. (If n D 1, then S ELECT merely
returns its only input value as the ith smallest.)
1. Divide the n elements of the input array into bn=5c groups of 5 elements each
and at most one group made up of the remaining n mod 5 elements.
2. Find the median of each of the dn=5e groups by ﬁrst insertion-sorting the elements of each group (of which there are at most 5) and then picking the median
from the sorted list of group elements.
3. Use S ELECT recursively to ﬁnd the median x of the dn=5e medians found in
step 2. (If there are an even number of medians, then by our convention, x is
the lower median.)
4. Partition the input array around the median-of-medians x using the modiﬁed
version of PARTITION. Let k be one more than the number of elements on the
low side of the partition, so that x is the kth smallest element and there are nk
elements on the high side of the partition.
5. If i D k, then return x. Otherwise, use S ELECT recursively to ﬁnd the ith
smallest element on the low side if i < k, or the .i  k/th smallest element on
the high side if i > k.
To analyze the running time of S ELECT, we ﬁrst determine a lower bound on the
number of elements that are greater than the partitioning element x. Figure 9.1
helps us to visualize this bookkeeping. At least half of the medians found in

9.3 Selection in worst-case linear time

221

x

Figure 9.1 Analysis of the algorithm S ELECT . The n elements are represented by small circles,
and each group of 5 elements occupies a column. The medians of the groups are whitened, and the
median-of-medians x is labeled. (When ﬁnding the median of an even number of elements, we use
the lower median.) Arrows go from larger elements to smaller, from which we can see that 3 out
of every full group of 5 elements to the right of x are greater than x, and 3 out of every group of 5
elements to the left of x are less than x. The elements known to be greater than x appear on a shaded
background.

step 2 are greater than or equal to the median-of-medians x.1 Thus, at least half
of the dn=5e groups contribute at least 3 elements that are greater than x, except
for the one group that has fewer than 5 elements if 5 does not divide n exactly, and
the one group containing x itself. Discounting these two groups, it follows that the
number of elements greater than x is at least

 l m
3n
1 n
2 
6:
3
2 5
10
Similarly, at least 3n=10  6 elements are less than x. Thus, in the worst case,
step 5 calls S ELECT recursively on at most 7n=10 C 6 elements.
We can now develop a recurrence for the worst-case running time T .n/ of the
algorithm S ELECT. Steps 1, 2, and 4 take O.n/ time. (Step 2 consists of O.n/
calls of insertion sort on sets of size O.1/.) Step 3 takes time T .dn=5e/, and step 5
takes time at most T .7n=10 C 6/, assuming that T is monotonically increasing.
We make the assumption, which seems unmotivated at ﬁrst, that any input of fewer
than 140 elements requires O.1/ time; the origin of the magic constant 140 will be
clear shortly. We can therefore obtain the recurrence

1 Because

of our assumption that the numbers are distinct, all medians except x are either greater
than or less than x.

222

Chapter 9 Medians and Order Statistics

(
T .n/ 

O.1/
if n < 140 ;
T .dn=5e/ C T .7n=10 C 6/ C O.n/ if n  140 :

We show that the running time is linear by substitution. More speciﬁcally, we will
show that T .n/  cn for some suitably large constant c and all n > 0. We begin by
assuming that T .n/  cn for some suitably large constant c and all n < 140; this
assumption holds if c is large enough. We also pick a constant a such that the function described by the O.n/ term above (which describes the non-recursive component of the running time of the algorithm) is bounded above by an for all n > 0.
Substituting this inductive hypothesis into the right-hand side of the recurrence
yields
T .n/ 

D
D

c dn=5e C c.7n=10 C 6/ C an
cn=5 C c C 7cn=10 C 6c C an
9cn=10 C 7c C an
cn C .cn=10 C 7c C an/ ;

which is at most cn if
cn=10 C 7c C an  0 :

(9.2)

Inequality (9.2) is equivalent to the inequality c  10a.n=.n  70// when n > 70.
Because we assume that n  140, we have n=.n  70/  2, and so choosing c  20a will satisfy inequality (9.2). (Note that there is nothing special about
the constant 140; we could replace it by any integer strictly greater than 70 and
then choose c accordingly.) The worst-case running time of S ELECT is therefore
linear.
As in a comparison sort (see Section 8.1), S ELECT and R ANDOMIZED -S ELECT
determine information about the relative order of elements only by comparing elements. Recall from Chapter 8 that sorting requires .n lg n/ time in the comparison model, even on average (see Problem 8-1). The linear-time sorting algorithms
in Chapter 8 make assumptions about the input. In contrast, the linear-time selection algorithms in this chapter do not require any assumptions about the input.
They are not subject to the .n lg n/ lower bound because they manage to solve
the selection problem without sorting. Thus, solving the selection problem by sorting and indexing, as presented in the introduction to this chapter, is asymptotically
inefﬁcient.

9.3 Selection in worst-case linear time

223

Exercises
9.3-1
In the algorithm S ELECT, the input elements are divided into groups of 5. Will
the algorithm work in linear time if they are divided into groups of 7? Argue that
S ELECT does not run in linear time if groups of 3 are used.
9.3-2
Analyze S ELECT to show that if n  140, then at least dn=4e elements are greater
than the median-of-medians x and at least dn=4e elements are less than x.
9.3-3
Show how quicksort can be made to run in O.n lg n/ time in the worst case, assuming that all elements are distinct.
9.3-4 ?
Suppose that an algorithm uses only comparisons to ﬁnd the ith smallest element
in a set of n elements. Show that it can also ﬁnd the i  1 smaller elements and
the n  i larger elements without performing any additional comparisons.
9.3-5
Suppose that you have a “black-box” worst-case linear-time median subroutine.
Give a simple, linear-time algorithm that solves the selection problem for an arbitrary order statistic.
9.3-6
The kth quantiles of an n-element set are the k  1 order statistics that divide the
sorted set into k equal-sized sets (to within 1). Give an O.n lg k/-time algorithm
to list the kth quantiles of a set.
9.3-7
Describe an O.n/-time algorithm that, given a set S of n distinct numbers and
a positive integer k  n, determines the k numbers in S that are closest to the
median of S.
9.3-8
Let X Œ1 : : n and Y Œ1 : : n be two arrays, each containing n numbers already in
sorted order. Give an O.lg n/-time algorithm to ﬁnd the median of all 2n elements
in arrays X and Y .
9.3-9
Professor Olay is consulting for an oil company, which is planning a large pipeline
running east to west through an oil ﬁeld of n wells. The company wants to connect

224

Chapter 9 Medians and Order Statistics

Figure 9.2 Professor Olay needs to determine the position of the east-west oil pipeline that minimizes the total length of the north-south spurs.

a spur pipeline from each well directly to the main pipeline along a shortest route
(either north or south), as shown in Figure 9.2. Given the x- and y-coordinates of
the wells, how should the professor pick the optimal location of the main pipeline,
which would be the one that minimizes the total length of the spurs? Show how to
determine the optimal location in linear time.

Problems
9-1 Largest i numbers in sorted order
Given a set of n numbers, we wish to ﬁnd the i largest in sorted order using a
comparison-based algorithm. Find the algorithm that implements each of the following methods with the best asymptotic worst-case running time, and analyze the
running times of the algorithms in terms of n and i.
a. Sort the numbers, and list the i largest.
b. Build a max-priority queue from the numbers, and call E XTRACT-M AX i times.
c. Use an order-statistic algorithm to ﬁnd the ith largest number, partition around
that number, and sort the i largest numbers.

Problems for Chapter 9

225

9-2 Weighted median
For nPdistinct elements x1 ; x2 ; : : : ; xn with positive weights w1 ; w2 ; : : : ; wn such
n
that i D1 wi D 1, the weighted (lower) median is the element xk satisfying
X
1
wi <
2
x <x
i

k

and
X
xi >xk

wi 

1
:
2

For example, if the elements are 0:1; 0:35; 0:05; 0:1; 0:15; 0:05; 0:2 and each element equals its weight (that is, wi D xi for i D 1; 2; : : : ; 7), then the median is 0:1,
but the weighted median is 0:2.
a. Argue that the median of x1 ; x2 ; : : : ; xn is the weighted median of the xi with
weights wi D 1=n for i D 1; 2; : : : ; n.
b. Show how to compute the weighted median of n elements in O.n lg n/ worstcase time using sorting.
c. Show how to compute the weighted median in ‚.n/ worst-case time using a
linear-time median algorithm such as S ELECT from Section 9.3.
The post-ofﬁce location problem is deﬁned as follows. We are given n points
ﬁnd a point p
p1 ; p2 ; : : : ; pn with associated weights w1 ; w2 ; : : : ; wn . We wish
Pto
n
(not necessarily one of the input points) that minimizes the sum i D1 wi d.p; pi /,
where d.a; b/ is the distance between points a and b.
d. Argue that the weighted median is a best solution for the 1-dimensional postofﬁce location problem, in which points are simply real numbers and the distance between points a and b is d.a; b/ D ja  bj.
e. Find the best solution for the 2-dimensional post-ofﬁce location problem, in
which the points are .x; y/ coordinate pairs and the distance between points
a D .x1 ; y1 / and b D .x2 ; y2 / is the Manhattan distance given by d.a; b/ D
jx1  x2 j C jy1  y2 j.
9-3 Small order statistics
We showed that the worst-case number T .n/ of comparisons used by S ELECT
to select the ith order statistic from n numbers satisﬁes T .n/ D ‚.n/, but the
constant hidden by the ‚-notation is rather large. When i is small relative to n, we
can implement a different procedure that uses S ELECT as a subroutine but makes
fewer comparisons in the worst case.

226

Chapter 9 Medians and Order Statistics

a. Describe an algorithm that uses Ui .n/ comparisons to ﬁnd the ith smallest of n
elements, where
(
T .n/
if i  n=2 ;
Ui .n/ D
bn=2c C Ui .dn=2e/ C T .2i/ otherwise :
(Hint: Begin with bn=2c disjoint pairwise comparisons, and recurse on the set
containing the smaller element from each pair.)
b. Show that, if i < n=2, then Ui .n/ D n C O.T .2i/ lg.n=i//.
c. Show that if i is a constant less than n=2, then Ui .n/ D n C O.lg n/.
d. Show that if i D n=k for k  2, then Ui .n/ D n C O.T .2n=k/ lg k/.
9-4 Alternative analysis of randomized selection
In this problem, we use indicator random variables to analyze the R ANDOMIZED S ELECT procedure in a manner akin to our analysis of R ANDOMIZED -Q UICKSORT
in Section 7.4.2.
As in the quicksort analysis, we assume that all elements are distinct, and we
rename the elements of the input array A as ´1 ; ´2 ; : : : ; ´n , where ´i is the ith
smallest element. Thus, the call R ANDOMIZED -S ELECT .A; 1; n; k/ returns ´k .
For 1  i < j  n, let
Xijk D I f ´i is compared with ´j sometime during the execution of the algorithm
to ﬁnd ´k g :
a. Give an exact expression for E ŒXijk . (Hint: Your expression may have different values, depending on the values of i, j , and k.)
b. Let Xk denote the total number of comparisons between elements of array A
when ﬁnding ´k . Show that
E ŒXk   2

n
k X
X
i D1 j Dk

n
k2
X
j k1 X ki 1
1
C
C
j i C1
j  k C 1 i D1 k  i C 1

!
:

j DkC1

c. Show that E ŒXk   4n.
d. Conclude that, assuming all elements of array A are distinct, R ANDOMIZED S ELECT runs in expected time O.n/.

Notes for Chapter 9

227

Chapter notes
The worst-case linear-time median-ﬁnding algorithm was devised by Blum, Floyd,
Pratt, Rivest, and Tarjan [50]. The fast randomized version is due to Hoare [169].
Floyd and Rivest [108] have developed an improved randomized version that partitions around an element recursively selected from a small sample of the elements.
It is still unknown exactly how many comparisons are needed to determine the
median. Bent and John [41] gave a lower bound of 2n comparisons for median
ﬁnding, and Schönhage, Paterson, and Pippenger [302] gave an upper bound of 3n.
Dor and Zwick have improved on both of these bounds. Their upper bound [93]
is slightly less than 2:95n, and their lower bound [94] is .2 C /n, for a small
positive constant , thereby improving slightly on related work by Dor et al. [92].
Paterson [272] describes some of these results along with other related work.

III

Data Structures

Introduction
Sets are as fundamental to computer science as they are to mathematics. Whereas
mathematical sets are unchanging, the sets manipulated by algorithms can grow,
shrink, or otherwise change over time. We call such sets dynamic. The next ﬁve
chapters present some basic techniques for representing ﬁnite dynamic sets and
manipulating them on a computer.
Algorithms may require several different types of operations to be performed on
sets. For example, many algorithms need only the ability to insert elements into,
delete elements from, and test membership in a set. We call a dynamic set that
supports these operations a dictionary. Other algorithms require more complicated
operations. For example, min-priority queues, which Chapter 6 introduced in the
context of the heap data structure, support the operations of inserting an element
into and extracting the smallest element from a set. The best way to implement a
dynamic set depends upon the operations that must be supported.
Elements of a dynamic set
In a typical implementation of a dynamic set, each element is represented by an
object whose attributes can be examined and manipulated if we have a pointer to
the object. (Section 10.3 discusses the implementation of objects and pointers in
programming environments that do not contain them as basic data types.) Some
kinds of dynamic sets assume that one of the object’s attributes is an identifying
key. If the keys are all different, we can think of the dynamic set as being a set
of key values. The object may contain satellite data, which are carried around in
other object attributes but are otherwise unused by the set implementation. It may

230

Part III Data Structures

also have attributes that are manipulated by the set operations; these attributes may
contain data or pointers to other objects in the set.
Some dynamic sets presuppose that the keys are drawn from a totally ordered
set, such as the real numbers, or the set of all words under the usual alphabetic
ordering. A total ordering allows us to deﬁne the minimum element of the set, for
example, or to speak of the next element larger than a given element in a set.
Operations on dynamic sets
Operations on a dynamic set can be grouped into two categories: queries, which
simply return information about the set, and modifying operations, which change
the set. Here is a list of typical operations. Any speciﬁc application will usually
require only a few of these to be implemented.
S EARCH .S; k/
A query that, given a set S and a key value k, returns a pointer x to an element
in S such that x:key D k, or NIL if no such element belongs to S.
I NSERT .S; x/
A modifying operation that augments the set S with the element pointed to
by x. We usually assume that any attributes in element x needed by the set
implementation have already been initialized.
D ELETE .S; x/
A modifying operation that, given a pointer x to an element in the set S, removes x from S. (Note that this operation takes a pointer to an element x, not
a key value.)
M INIMUM .S/
A query on a totally ordered set S that returns a pointer to the element of S
with the smallest key.
M AXIMUM .S/
A query on a totally ordered set S that returns a pointer to the element of S
with the largest key.
S UCCESSOR .S; x/
A query that, given an element x whose key is from a totally ordered set S,
returns a pointer to the next larger element in S, or NIL if x is the maximum
element.
P REDECESSOR .S; x/
A query that, given an element x whose key is from a totally ordered set S,
returns a pointer to the next smaller element in S, or NIL if x is the minimum
element.

Part III

Data Structures

231

In some situations, we can extend the queries S UCCESSOR and P REDECESSOR
so that they apply to sets with nondistinct keys. For a set on n keys, the normal
presumption is that a call to M INIMUM followed by n  1 calls to S UCCESSOR
enumerates the elements in the set in sorted order.
We usually measure the time taken to execute a set operation in terms of the size
of the set. For example, Chapter 13 describes a data structure that can support any
of the operations listed above on a set of size n in time O.lg n/.
Overview of Part III
Chapters 10–14 describe several data structures that we can use to implement
dynamic sets; we shall use many of these later to construct efﬁcient algorithms
for a variety of problems. We already saw another important data structure—the
heap—in Chapter 6.
Chapter 10 presents the essentials of working with simple data structures such
as stacks, queues, linked lists, and rooted trees. It also shows how to implement
objects and pointers in programming environments that do not support them as
primitives. If you have taken an introductory programming course, then much of
this material should be familiar to you.
Chapter 11 introduces hash tables, which support the dictionary operations I N SERT, D ELETE, and S EARCH . In the worst case, hashing requires ‚.n/ time to perform a S EARCH operation, but the expected time for hash-table operations is O.1/.
The analysis of hashing relies on probability, but most of the chapter requires no
background in the subject.
Binary search trees, which are covered in Chapter 12, support all the dynamicset operations listed above. In the worst case, each operation takes ‚.n/ time on a
tree with n elements, but on a randomly built binary search tree, the expected time
for each operation is O.lg n/. Binary search trees serve as the basis for many other
data structures.
Chapter 13 introduces red-black trees, which are a variant of binary search trees.
Unlike ordinary binary search trees, red-black trees are guaranteed to perform well:
operations take O.lg n/ time in the worst case. A red-black tree is a balanced search
tree; Chapter 18 in Part V presents another kind of balanced search tree, called a
B-tree. Although the mechanics of red-black trees are somewhat intricate, you can
glean most of their properties from the chapter without studying the mechanics in
detail. Nevertheless, you probably will ﬁnd walking through the code to be quite
instructive.
In Chapter 14, we show how to augment red-black trees to support operations
other than the basic ones listed above. First, we augment them so that we can
dynamically maintain order statistics for a set of keys. Then, we augment them in
a different way to maintain intervals of real numbers.

10

Elementary Data Structures

In this chapter, we examine the representation of dynamic sets by simple data structures that use pointers. Although we can construct many complex data structures
using pointers, we present only the rudimentary ones: stacks, queues, linked lists,
and rooted trees. We also show ways to synthesize objects and pointers from arrays.

10.1 Stacks and queues
Stacks and queues are dynamic sets in which the element removed from the set
by the D ELETE operation is prespeciﬁed. In a stack, the element deleted from
the set is the one most recently inserted: the stack implements a last-in, ﬁrst-out,
or LIFO, policy. Similarly, in a queue, the element deleted is always the one that
has been in the set for the longest time: the queue implements a ﬁrst-in, ﬁrst-out,
or FIFO, policy. There are several efﬁcient ways to implement stacks and queues
on a computer. In this section we show how to use a simple array to implement
each.
Stacks
The I NSERT operation on a stack is often called P USH, and the D ELETE operation, which does not take an element argument, is often called P OP. These names
are allusions to physical stacks, such as the spring-loaded stacks of plates used
in cafeterias. The order in which plates are popped from the stack is the reverse
of the order in which they were pushed onto the stack, since only the top plate is
accessible.
As Figure 10.1 shows, we can implement a stack of at most n elements with
an array SŒ1 : : n. The array has an attribute S:top that indexes the most recently

10.1 Stacks and queues

1

2

3

4

S 15 6

2

9

5

6

233

7

1

2

3

4

S 15 6

2

9 17 3

S:top D 4
(a)

5

6

7

S:top D 6
(b)

1

2

3

4

5

6

S 15 6

2

9 17 3

7

S:top D 5
(c)

Figure 10.1 An array implementation of a stack S. Stack elements appear only in the lightly shaded
positions. (a) Stack S has 4 elements. The top element is 9. (b) Stack S after the calls P USH.S; 17/
and P USH.S; 3/. (c) Stack S after the call P OP.S/ has returned the element 3, which is the one most
recently pushed. Although element 3 still appears in the array, it is no longer in the stack; the top is
element 17.

inserted element. The stack consists of elements SŒ1 : : S:top, where SŒ1 is the
element at the bottom of the stack and SŒS:top is the element at the top.
When S:top D 0, the stack contains no elements and is empty. We can test to
see whether the stack is empty by query operation S TACK -E MPTY. If we attempt
to pop an empty stack, we say the stack underﬂows, which is normally an error.
If S:top exceeds n, the stack overﬂows. (In our pseudocode implementation, we
don’t worry about stack overﬂow.)
We can implement each of the stack operations with just a few lines of code:
S TACK -E MPTY .S/
1 if S:top == 0
2
return TRUE
3 else return FALSE
P USH .S; x/
1 S:top D S:top C 1
2 SŒS:top D x
P OP.S/
1 if S TACK -E MPTY .S/
2
error “underﬂow”
3 else S:top D S:top  1
4
return SŒS:top C 1
Figure 10.1 shows the effects of the modifying operations P USH and P OP. Each of
the three stack operations takes O.1/ time.

234

Chapter 10 Elementary Data Structures

1

(a)

2

3

4

5

6

Q

7

8

9

10 11 12

15 6

9

8

Q:head D 7

(b)

1

2

Q 3

5

3

4

5

(c)

2

Q 3

5

3

4

Q:tail D 3

7

Q:tail D 12

8

9

10 11 12

15 6

9

8

8

9

10 11 12

15 6

9

8

4 17

Q:head D 7

Q:tail D 3
1

6

4

5

6

7

4 17

Q:head D 8

Figure 10.2 A queue implemented using an array QŒ1 : : 12. Queue elements appear only in the
lightly shaded positions. (a) The queue has 5 elements, in locations QŒ7 : : 11. (b) The conﬁguration
of the queue after the calls E NQUEUE.Q; 17/, E NQUEUE.Q; 3/, and E NQUEUE.Q; 5/. (c) The
conﬁguration of the queue after the call D EQUEUE.Q/ returns the key value 15 formerly at the
head of the queue. The new head has key 6.

Queues
We call the I NSERT operation on a queue E NQUEUE, and we call the D ELETE
operation D EQUEUE; like the stack operation P OP, D EQUEUE takes no element argument. The FIFO property of a queue causes it to operate like a line of customers
waiting to pay a cashier. The queue has a head and a tail. When an element is enqueued, it takes its place at the tail of the queue, just as a newly arriving customer
takes a place at the end of the line. The element dequeued is always the one at
the head of the queue, like the customer at the head of the line who has waited the
longest.
Figure 10.2 shows one way to implement a queue of at most n  1 elements
using an array QŒ1 : : n. The queue has an attribute Q:head that indexes, or points
to, its head. The attribute Q:tail indexes the next location at which a newly arriving element will be inserted into the queue. The elements in the queue reside in
locations Q:head; Q:head C 1; : : : ; Q:tail  1, where we “wrap around” in the
sense that location 1 immediately follows location n in a circular order. When
Q:head D Q:tail, the queue is empty. Initially, we have Q:head D Q:tail D 1.
If we attempt to dequeue an element from an empty queue, the queue underﬂows.

10.1 Stacks and queues

235

When Q:head D Q:tail C 1, the queue is full, and if we attempt to enqueue an
element, then the queue overﬂows.
In our procedures E NQUEUE and D EQUEUE, we have omitted the error checking
for underﬂow and overﬂow. (Exercise 10.1-4 asks you to supply code that checks
for these two error conditions.) The pseudocode assumes that n D Q:length.
E NQUEUE .Q; x/
1 QŒQ:tail D x
2 if Q:tail == Q:length
3
Q:tail D 1
4 else Q:tail D Q:tail C 1
D EQUEUE .Q/
1 x D QŒQ:head
2 if Q:head == Q:length
3
Q:head D 1
4 else Q:head D Q:head C 1
5 return x
Figure 10.2 shows the effects of the E NQUEUE and D EQUEUE operations. Each
operation takes O.1/ time.
Exercises
10.1-1
Using Figure 10.1 as a model, illustrate the result of each operation in the sequence
P USH .S; 4/, P USH .S; 1/, P USH .S; 3/, P OP.S/, P USH .S; 8/, and P OP.S/ on an
initially empty stack S stored in array SŒ1 : : 6.
10.1-2
Explain how to implement two stacks in one array AŒ1 : : n in such a way that
neither stack overﬂows unless the total number of elements in both stacks together
is n. The P USH and P OP operations should run in O.1/ time.
10.1-3
Using Figure 10.2 as a model, illustrate the result of each operation in the
sequence E NQUEUE .Q; 4/, E NQUEUE .Q; 1/, E NQUEUE .Q; 3/, D EQUEUE .Q/,
E NQUEUE .Q; 8/, and D EQUEUE .Q/ on an initially empty queue Q stored in
array QŒ1 : : 6.
10.1-4
Rewrite E NQUEUE and D EQUEUE to detect underﬂow and overﬂow of a queue.

236

Chapter 10 Elementary Data Structures

10.1-5
Whereas a stack allows insertion and deletion of elements at only one end, and a
queue allows insertion at one end and deletion at the other end, a deque (doubleended queue) allows insertion and deletion at both ends. Write four O.1/-time
procedures to insert elements into and delete elements from both ends of a deque
implemented by an array.
10.1-6
Show how to implement a queue using two stacks. Analyze the running time of the
queue operations.
10.1-7
Show how to implement a stack using two queues. Analyze the running time of the
stack operations.

10.2 Linked lists
A linked list is a data structure in which the objects are arranged in a linear order.
Unlike an array, however, in which the linear order is determined by the array
indices, the order in a linked list is determined by a pointer in each object. Linked
lists provide a simple, ﬂexible representation for dynamic sets, supporting (though
not necessarily efﬁciently) all the operations listed on page 230.
As shown in Figure 10.3, each element of a doubly linked list L is an object with
an attribute key and two other pointer attributes: next and pre. The object may
also contain other satellite data. Given an element x in the list, x:next points to its
successor in the linked list, and x:pre points to its predecessor. If x:pre D NIL,
the element x has no predecessor and is therefore the ﬁrst element, or head, of
the list. If x:next D NIL , the element x has no successor and is therefore the last
element, or tail, of the list. An attribute L:head points to the ﬁrst element of the
list. If L:head D NIL , the list is empty.
A list may have one of several forms. It may be either singly linked or doubly
linked, it may be sorted or not, and it may be circular or not. If a list is singly
linked, we omit the pre pointer in each element. If a list is sorted, the linear order
of the list corresponds to the linear order of keys stored in elements of the list; the
minimum element is then the head of the list, and the maximum element is the
tail. If the list is unsorted, the elements can appear in any order. In a circular list,
the pre pointer of the head of the list points to the tail, and the next pointer of
the tail of the list points to the head. We can think of a circular list as a ring of

10.2 Linked lists

237

prev

key

next

(a)

L:head

9

16

4

1

(b)

L:head

25

9

16

4

(c)

L:head

25

9

16

1

1

Figure 10.3 (a) A doubly linked list L representing the dynamic set f1; 4; 9; 16g. Each element in
the list is an object with attributes for the key and pointers (shown by arrows) to the next and previous
objects. The next attribute of the tail and the pre attribute of the head are NIL , indicated by a diagonal
slash. The attribute L: head points to the head. (b) Following the execution of L IST-I NSERT.L; x/,
where x: key D 25, the linked list has a new object with key 25 as the new head. This new object
points to the old head with key 9. (c) The result of the subsequent call L IST-D ELETE.L; x/, where x
points to the object with key 4.

elements. In the remainder of this section, we assume that the lists with which we
are working are unsorted and doubly linked.
Searching a linked list
The procedure L IST-S EARCH .L; k/ ﬁnds the ﬁrst element with key k in list L
by a simple linear search, returning a pointer to this element. If no object with
key k appears in the list, then the procedure returns NIL. For the linked list in
Figure 10.3(a), the call L IST-S EARCH .L; 4/ returns a pointer to the third element,
and the call L IST-S EARCH .L; 7/ returns NIL.
L IST-S EARCH .L; k/
1 x D L:head
2 while x ¤ NIL and x:key ¤ k
3
x D x:next
4 return x
To search a list of n objects, the L IST-S EARCH procedure takes ‚.n/ time in the
worst case, since it may have to search the entire list.
Inserting into a linked list
Given an element x whose key attribute has already been set, the L IST-I NSERT
procedure “splices” x onto the front of the linked list, as shown in Figure 10.3(b).

238

Chapter 10 Elementary Data Structures

L IST-I NSERT .L; x/
1 x:next D L:head
2 if L:head ¤ NIL
3
L:head:pre D x
4 L:head D x
5 x:pre D NIL
(Recall that our attribute notation can cascade, so that L:head:pre denotes the
pre attribute of the object that L:head points to.) The running time for L ISTI NSERT on a list of n elements is O.1/.
Deleting from a linked list
The procedure L IST-D ELETE removes an element x from a linked list L. It must
be given a pointer to x, and it then “splices” x out of the list by updating pointers.
If we wish to delete an element with a given key, we must ﬁrst call L IST-S EARCH
to retrieve a pointer to the element.
L IST-D ELETE .L; x/
1 if x:pre ¤ NIL
2
x:pre:next D x:next
3 else L:head D x:next
4 if x:next ¤ NIL
5
x:next:pre D x:pre
Figure 10.3(c) shows how an element is deleted from a linked list. L IST-D ELETE
runs in O.1/ time, but if we wish to delete an element with a given key, ‚.n/ time
is required in the worst case because we must ﬁrst call L IST-S EARCH to ﬁnd the
element.
Sentinels
The code for L IST-D ELETE would be simpler if we could ignore the boundary
conditions at the head and tail of the list:
L IST-D ELETE0 .L; x/
1 x:pre:next D x:next
2 x:next:pre D x:pre
A sentinel is a dummy object that allows us to simplify boundary conditions. For
example, suppose that we provide with list L an object L:nil that represents NIL

10.2 Linked lists

239

(a)

L:nil

(b)

L:nil

9

16

4

1

(c)

L:nil

25

9

16

4

(d)

L:nil

25

9

16

4

1

Figure 10.4 A circular, doubly linked list with a sentinel. The sentinel L: nil appears between the
head and tail. The attribute L: head is no longer needed, since we can access the head of the list
by L: nil: next. (a) An empty list. (b) The linked list from Figure 10.3(a), with key 9 at the head and
key 1 at the tail. (c) The list after executing L IST-I NSERT0 .L; x/, where x: key D 25. The new object
becomes the head of the list. (d) The list after deleting the object with key 1. The new tail is the
object with key 4.

but has all the attributes of the other objects in the list. Wherever we have a reference to NIL in list code, we replace it by a reference to the sentinel L:nil. As
shown in Figure 10.4, this change turns a regular doubly linked list into a circular, doubly linked list with a sentinel, in which the sentinel L:nil lies between the
head and tail. The attribute L:nil:next points to the head of the list, and L:nil:pre
points to the tail. Similarly, both the next attribute of the tail and the pre attribute of the head point to L:nil. Since L:nil:next points to the head, we can
eliminate the attribute L:head altogether, replacing references to it by references
to L:nil:next. Figure 10.4(a) shows that an empty list consists of just the sentinel,
and both L:nil:next and L:nil:pre point to L:nil.
The code for L IST-S EARCH remains the same as before, but with the references
to NIL and L:head changed as speciﬁed above:
L IST-S EARCH0 .L; k/
1 x D L:nil:next
2 while x ¤ L:nil and x:key ¤ k
3
x D x:next
4 return x
We use the two-line procedure L IST-D ELETE 0 from before to delete an element
from the list. The following procedure inserts an element into the list:

240

Chapter 10 Elementary Data Structures

L IST-I NSERT0 .L; x/
1 x:next D L:nil:next
2 L:nil:next:pre D x
3 L:nil:next D x
4 x:pre D L:nil
Figure 10.4 shows the effects of L IST-I NSERT 0 and L IST-D ELETE 0 on a sample list.
Sentinels rarely reduce the asymptotic time bounds of data structure operations,
but they can reduce constant factors. The gain from using sentinels within loops
is usually a matter of clarity of code rather than speed; the linked list code, for
example, becomes simpler when we use sentinels, but we save only O.1/ time in
the L IST-I NSERT 0 and L IST-D ELETE 0 procedures. In other situations, however, the
use of sentinels helps to tighten the code in a loop, thus reducing the coefﬁcient of,
say, n or n2 in the running time.
We should use sentinels judiciously. When there are many small lists, the extra
storage used by their sentinels can represent signiﬁcant wasted memory. In this
book, we use sentinels only when they truly simplify the code.
Exercises
10.2-1
Can you implement the dynamic-set operation I NSERT on a singly linked list
in O.1/ time? How about D ELETE?
10.2-2
Implement a stack using a singly linked list L. The operations P USH and P OP
should still take O.1/ time.
10.2-3
Implement a queue by a singly linked list L. The operations E NQUEUE and D E QUEUE should still take O.1/ time.
10.2-4
As written, each loop iteration in the L IST-S EARCH 0 procedure requires two tests:
one for x ¤ L:nil and one for x:key ¤ k. Show how to eliminate the test for
x ¤ L:nil in each iteration.
10.2-5
Implement the dictionary operations I NSERT, D ELETE, and S EARCH using singly
linked, circular lists. What are the running times of your procedures?

10.3 Implementing pointers and objects

241

10.2-6
The dynamic-set operation U NION takes two disjoint sets S1 and S2 as input, and
it returns a set S D S1 [ S2 consisting of all the elements of S1 and S2 . The
sets S1 and S2 are usually destroyed by the operation. Show how to support U NION
in O.1/ time using a suitable list data structure.
10.2-7
Give a ‚.n/-time nonrecursive procedure that reverses a singly linked list of n
elements. The procedure should use no more than constant storage beyond that
needed for the list itself.
10.2-8 ?
Explain how to implement doubly linked lists using only one pointer value x:np per
item instead of the usual two (next and pre). Assume that all pointer values can be
interpreted as k-bit integers, and deﬁne x:np to be x:np D x:next XOR x:pre,
the k-bit “exclusive-or” of x:next and x:pre. (The value NIL is represented by 0.)
Be sure to describe what information you need to access the head of the list. Show
how to implement the S EARCH, I NSERT, and D ELETE operations on such a list.
Also show how to reverse such a list in O.1/ time.

10.3 Implementing pointers and objects
How do we implement pointers and objects in languages that do not provide them?
In this section, we shall see two ways of implementing linked data structures without an explicit pointer data type. We shall synthesize objects and pointers from
arrays and array indices.
A multiple-array representation of objects
We can represent a collection of objects that have the same attributes by using an
array for each attribute. As an example, Figure 10.5 shows how we can implement
the linked list of Figure 10.3(a) with three arrays. The array key holds the values
of the keys currently in the dynamic set, and the pointers reside in the arrays next
and pre. For a given array index x, the array entries keyŒx, nextŒx, and preŒx
represent an object in the linked list. Under this interpretation, a pointer x is simply
a common index into the key, next, and pre arrays.
In Figure 10.3(a), the object with key 4 follows the object with key 16 in the
linked list. In Figure 10.5, key 4 appears in keyŒ2, and key 16 appears in keyŒ5,
and so nextŒ5 D 2 and preŒ2 D 5. Although the constant NIL appears in the next

242

Chapter 10 Elementary Data Structures

L

7
next
key
prev

1

2

3
4
5

3

1
2

4

5

2
16
7

6

7

8

5
9

Figure 10.5 The linked list of Figure 10.3(a) represented by the arrays key, next, and pre. Each
vertical slice of the arrays represents a single object. Stored pointers correspond to the array indices
shown at the top; the arrows show how to interpret them. Lightly shaded object positions contain list
elements. The variable L keeps the index of the head.

attribute of the tail and the pre attribute of the head, we usually use an integer
(such as 0 or 1) that cannot possibly represent an actual index into the arrays. A
variable L holds the index of the head of the list.
A single-array representation of objects
The words in a computer memory are typically addressed by integers from 0
to M  1, where M is a suitably large integer. In many programming languages,
an object occupies a contiguous set of locations in the computer memory. A pointer
is simply the address of the ﬁrst memory location of the object, and we can address
other memory locations within the object by adding an offset to the pointer.
We can use the same strategy for implementing objects in programming environments that do not provide explicit pointer data types. For example, Figure 10.6
shows how to use a single array A to store the linked list from Figures 10.3(a)
and 10.5. An object occupies a contiguous subarray AŒj : : k. Each attribute of
the object corresponds to an offset in the range from 0 to k  j , and a pointer to
the object is the index j . In Figure 10.6, the offsets corresponding to key, next, and
pre are 0, 1, and 2, respectively. To read the value of i:pre, given a pointer i, we
add the value i of the pointer to the offset 2, thus reading AŒi C 2.
The single-array representation is ﬂexible in that it permits objects of different
lengths to be stored in the same array. The problem of managing such a heterogeneous collection of objects is more difﬁcult than the problem of managing a homogeneous collection, where all objects have the same attributes. Since most of the
data structures we shall consider are composed of homogeneous elements, it will
be sufﬁcient for our purposes to use the multiple-array representation of objects.

10.3 Implementing pointers and objects

L

1

19
A

2

3

4

5

6

7

4

7 13 1

8

9

4

243

10 11 12 13 14 15 16 17 18 19 20 21 22 23 24

16 4 19

9 13

key prev
next

Figure 10.6 The linked list of Figures 10.3(a) and 10.5 represented in a single array A. Each list
element is an object that occupies a contiguous subarray of length 3 within the array. The three
attributes key, next, and pre correspond to the offsets 0, 1, and 2, respectively, within each object.
A pointer to an object is the index of the ﬁrst element of the object. Objects containing list elements
are lightly shaded, and arrows show the list ordering.

Allocating and freeing objects
To insert a key into a dynamic set represented by a doubly linked list, we must allocate a pointer to a currently unused object in the linked-list representation. Thus,
it is useful to manage the storage of objects not currently used in the linked-list
representation so that one can be allocated. In some systems, a garbage collector is responsible for determining which objects are unused. Many applications,
however, are simple enough that they can bear responsibility for returning an unused object to a storage manager. We shall now explore the problem of allocating
and freeing (or deallocating) homogeneous objects using the example of a doubly
linked list represented by multiple arrays.
Suppose that the arrays in the multiple-array representation have length m and
that at some moment the dynamic set contains n  m elements. Then n objects
represent elements currently in the dynamic set, and the remaining mn objects are
free; the free objects are available to represent elements inserted into the dynamic
set in the future.
We keep the free objects in a singly linked list, which we call the free list. The
free list uses only the next array, which stores the next pointers within the list.
The head of the free list is held in the global variable free. When the dynamic
set represented by linked list L is nonempty, the free list may be intertwined with
list L, as shown in Figure 10.7. Note that each object in the representation is either
in list L or in the free list, but not in both.
The free list acts like a stack: the next object allocated is the last one freed. We
can use a list implementation of the stack operations P USH and P OP to implement
the procedures for allocating and freeing objects, respectively. We assume that the
global variable free used in the following procedures points to the ﬁrst element of
the free list.

244

Chapter 10 Elementary Data Structures

free

4

L

7

1

2

3
4
5

next
key
prev

3

4

8
1
2

5

6

7

8

2 1
16
7

5
9

6

(a)

free

5

L

4

1

next
key
prev

4

free

8

L

4

1

next
key
prev

2

3

4

5

6

7

8

3
4
5

7 2 1
1 25 16
2
7

5
9

6

4

(b)

2

3

5

6

7

8

3
4
7

7 8
1 25
2

1

2
9
4

6

(c)

Figure 10.7 The effect of the A LLOCATE -O BJECT and F REE -O BJECT procedures. (a) The list
of Figure 10.5 (lightly shaded) and a free list (heavily shaded). Arrows show the free-list structure.
(b) The result of calling A LLOCATE -O BJECT./ (which returns index 4), setting keyŒ4 to 25, and
calling L IST-I NSERT.L; 4/. The new free-list head is object 8, which had been nextŒ4 on the free
list. (c) After executing L IST-D ELETE.L; 5/, we call F REE -O BJECT.5/. Object 5 becomes the new
free-list head, with object 8 following it on the free list.

A LLOCATE -O BJECT ./
1 if free == NIL
2
error “out of space”
3 else x D free
4
free D x:next
5
return x
F REE -O BJECT .x/
1 x:next D free
2 free D x
The free list initially contains all n unallocated objects. Once the free list has been
exhausted, running the A LLOCATE -O BJECT procedure signals an error. We can
even service several linked lists with just a single free list. Figure 10.8 shows two
linked lists and a free list intertwined through key, next, and pre arrays.
The two procedures run in O.1/ time, which makes them quite practical. We
can modify them to work for any homogeneous collection of objects by letting any
one of the attributes in the object act like a next attribute in the free list.

10.3 Implementing pointers and objects

free 10
L2 9
L1 3

1

2

3

4

5

6

245

7

next 5
6 8
2 1
key k1 k2 k3
k5 k6 k7
prev 7 6
1 3 9

8

9

10

7

4

k9

Figure 10.8 Two linked lists, L1 (lightly shaded) and L2 (heavily shaded), and a free list (darkened) intertwined.

Exercises
10.3-1
Draw a picture of the sequence h13; 4; 8; 19; 5; 11i stored as a doubly linked list
using the multiple-array representation. Do the same for the single-array representation.
10.3-2
Write the procedures A LLOCATE -O BJECT and F REE -O BJECT for a homogeneous
collection of objects implemented by the single-array representation.
10.3-3
Why don’t we need to set or reset the pre attributes of objects in the implementation of the A LLOCATE -O BJECT and F REE -O BJECT procedures?
10.3-4
It is often desirable to keep all elements of a doubly linked list compact in storage,
using, for example, the ﬁrst m index locations in the multiple-array representation.
(This is the case in a paged, virtual-memory computing environment.) Explain
how to implement the procedures A LLOCATE -O BJECT and F REE -O BJECT so that
the representation is compact. Assume that there are no pointers to elements of the
linked list outside the list itself. (Hint: Use the array implementation of a stack.)
10.3-5
Let L be a doubly linked list of length n stored in arrays key, pre, and next of
length m. Suppose that these arrays are managed by A LLOCATE -O BJECT and
F REE -O BJECT procedures that keep a doubly linked free list F . Suppose further
that of the m items, exactly n are on list L and m  n are on the free list. Write
a procedure C OMPACTIFY-L IST .L; F / that, given the list L and the free list F ,
moves the items in L so that they occupy array positions 1; 2; : : : ; n and adjusts the
free list F so that it remains correct, occupying array positions n C1; n C2; : : : ; m.
The running time of your procedure should be ‚.n/, and it should use only a
constant amount of extra space. Argue that your procedure is correct.

246

Chapter 10 Elementary Data Structures

10.4 Representing rooted trees
The methods for representing lists given in the previous section extend to any homogeneous data structure. In this section, we look speciﬁcally at the problem of
representing rooted trees by linked data structures. We ﬁrst look at binary trees,
and then we present a method for rooted trees in which nodes can have an arbitrary
number of children.
We represent each node of a tree by an object. As with linked lists, we assume
that each node contains a key attribute. The remaining attributes of interest are
pointers to other nodes, and they vary according to the type of tree.
Binary trees
Figure 10.9 shows how we use the attributes p, left, and right to store pointers to
the parent, left child, and right child of each node in a binary tree T . If x:p D NIL,
then x is the root. If node x has no left child, then x:left D NIL , and similarly for
the right child. The root of the entire tree T is pointed to by the attribute T:root. If
T:root D NIL, then the tree is empty.
Rooted trees with unbounded branching
We can extend the scheme for representing a binary tree to any class of trees in
which the number of children of each node is at most some constant k: we replace
the left and right attributes by child 1 ; child 2 ; : : : ; child k . This scheme no longer
works when the number of children of a node is unbounded, since we do not know
how many attributes (arrays in the multiple-array representation) to allocate in advance. Moreover, even if the number of children k is bounded by a large constant
but most nodes have a small number of children, we may waste a lot of memory.
Fortunately, there is a clever scheme to represent trees with arbitrary numbers of
children. It has the advantage of using only O.n/ space for any n-node rooted tree.
The left-child, right-sibling representation appears in Figure 10.10. As before,
each node contains a parent pointer p, and T:root points to the root of tree T .
Instead of having a pointer to each of its children, however, each node x has only
two pointers:
1. x:left-child points to the leftmost child of node x, and
2. x:right-sibling points to the sibling of x immediately to its right.
If node x has no children, then x:left-child D NIL, and if node x is the rightmost
child of its parent, then x:right-sibling D NIL.

10.4 Representing rooted trees

247

T:root

Figure 10.9 The representation of a binary tree T . Each node x has the attributes x: p (top), x: left
(lower left), and x: right (lower right). The key attributes are not shown.

T:root

Figure 10.10 The left-child, right-sibling representation of a tree T . Each node x has attributes x: p
(top), x: left-child (lower left), and x: right-sibling (lower right). The key attributes are not shown.

248

Chapter 10 Elementary Data Structures

Other tree representations
We sometimes represent rooted trees in other ways. In Chapter 6, for example,
we represented a heap, which is based on a complete binary tree, by a single array
plus the index of the last node in the heap. The trees that appear in Chapter 21 are
traversed only toward the root, and so only the parent pointers are present; there
are no pointers to children. Many other schemes are possible. Which scheme is
best depends on the application.
Exercises
10.4-1
Draw the binary tree rooted at index 6 that is represented by the following attributes:
index
1
2
3
4
5
6
7
8
9
10

key
12
15
4
10
2
18
7
14
21
5

left
7
8
10
5

right
3

NIL

NIL

NIL
NIL

9

1

4

NIL

NIL

6

2

NIL

NIL

NIL

NIL

10.4-2
Write an O.n/-time recursive procedure that, given an n-node binary tree, prints
out the key of each node in the tree.
10.4-3
Write an O.n/-time nonrecursive procedure that, given an n-node binary tree,
prints out the key of each node in the tree. Use a stack as an auxiliary data structure.
10.4-4
Write an O.n/-time procedure that prints all the keys of an arbitrary rooted tree
with n nodes, where the tree is stored using the left-child, right-sibling representation.
10.4-5 ?
Write an O.n/-time nonrecursive procedure that, given an n-node binary tree,
prints out the key of each node. Use no more than constant extra space outside

Problems for Chapter 10

249

of the tree itself and do not modify the tree, even temporarily, during the procedure.
10.4-6 ?
The left-child, right-sibling representation of an arbitrary rooted tree uses three
pointers in each node: left-child, right-sibling, and parent. From any node, its
parent can be reached and identiﬁed in constant time and all its children can be
reached and identiﬁed in time linear in the number of children. Show how to use
only two pointers and one boolean value in each node so that the parent of a node
or all of its children can be reached and identiﬁed in time linear in the number of
children.

Problems
10-1 Comparisons among lists
For each of the four types of lists in the following table, what is the asymptotic
worst-case running time for each dynamic-set operation listed?
unsorted,
singly
linked
S EARCH .L; k/
I NSERT .L; x/
D ELETE .L; x/
S UCCESSOR .L; x/
P REDECESSOR .L; x/
M INIMUM .L/
M AXIMUM .L/

sorted,
singly
linked

unsorted,
doubly
linked

sorted,
doubly
linked

250

Chapter 10 Elementary Data Structures

10-2 Mergeable heaps using linked lists
A mergeable heap supports the following operations: M AKE -H EAP (which creates
an empty mergeable heap), I NSERT, M INIMUM, E XTRACT-M IN, and U NION.1
Show how to implement mergeable heaps using linked lists in each of the following
cases. Try to make each operation as efﬁcient as possible. Analyze the running
time of each operation in terms of the size of the dynamic set(s) being operated on.
a. Lists are sorted.
b. Lists are unsorted.
c. Lists are unsorted, and dynamic sets to be merged are disjoint.
10-3 Searching a sorted compact list
Exercise 10.3-4 asked how we might maintain an n-element list compactly in the
ﬁrst n positions of an array. We shall assume that all keys are distinct and that the
compact list is also sorted, that is, keyŒi < keyŒnextŒi for all i D 1; 2; : : : ; n such
that nextŒi ¤ NIL . We will also assume that we have a variable L that contains
the index of the ﬁrst element on the list. Under these assumptions, you will show
p
that we can use the following randomized algorithm to search the list in O. n/
expected time.
C OMPACT-L IST-S EARCH .L; n; k/
1 i DL
2 while i ¤ NIL and keyŒi < k
3
j D R ANDOM.1; n/
4
if keyŒi < keyŒj  and keyŒj   k
5
i Dj
6
if keyŒi == k
7
return i
8
i D nextŒi
9 if i == NIL or keyŒi > k
10
return NIL
11 else return i
If we ignore lines 3–7 of the procedure, we have an ordinary algorithm for
searching a sorted linked list, in which index i points to each position of the list in

1 Because we have deﬁned a mergeable heap to support M INIMUM and E XTRACT-M IN , we can also
refer to it as a mergeable min-heap. Alternatively, if it supported M AXIMUM and E XTRACT-M AX,
it would be a mergeable max-heap.

Problems for Chapter 10

251

turn. The search terminates once the index i “falls off” the end of the list or once
keyŒi  k. In the latter case, if keyŒi D k, clearly we have found a key with the
value k. If, however, keyŒi > k, then we will never ﬁnd a key with the value k,
and so terminating the search was the right thing to do.
Lines 3–7 attempt to skip ahead to a randomly chosen position j . Such a skip
beneﬁts us if keyŒj  is larger than keyŒi and no larger than k; in such a case, j
marks a position in the list that i would have to reach during an ordinary list search.
Because the list is compact, we know that any choice of j between 1 and n indexes
some object in the list rather than a slot on the free list.
Instead of analyzing the performance of C OMPACT-L IST-S EARCH directly, we
shall analyze a related algorithm, C OMPACT-L IST-S EARCH 0 , which executes two
separate loops. This algorithm takes an additional parameter t which determines
an upper bound on the number of iterations of the ﬁrst loop.
C OMPACT-L IST-S EARCH0 .L; n; k; t/
1 i DL
2 for q D 1 to t
3
j D R ANDOM.1; n/
4
if keyŒi < keyŒj  and keyŒj   k
5
i Dj
6
if keyŒi == k
7
return i
8 while i ¤ NIL and keyŒi < k
9
i D nextŒi
10 if i == NIL or keyŒi > k
11
return NIL
12 else return i
To compare the execution of the algorithms C OMPACT-L IST-S EARCH .L; n; k/
and C OMPACT-L IST-S EARCH 0 .L; n; k; t/, assume that the sequence of integers returned by the calls of R ANDOM.1; n/ is the same for both algorithms.
a. Suppose that C OMPACT-L IST-S EARCH .L; n; k/ takes t iterations of the while
loop of lines 2–8. Argue that C OMPACT-L IST-S EARCH 0 .L; n; k; t/ returns the
same answer and that the total number of iterations of both the for and while
loops within C OMPACT-L IST-S EARCH 0 is at least t.
In the call C OMPACT-L IST-S EARCH 0 .L; n; k; t/, let X t be the random variable that
describes the distance in the linked list (that is, through the chain of next pointers)
from position i to the desired key k after t iterations of the for loop of lines 2–7
have occurred.

252

Chapter 10 Elementary Data Structures

b. Argue that the expected running time of C OMPACT-L IST-S EARCH 0 .L; n; k; t/
is O.t C E ŒX t /.
Pn
c. Show that E ŒX t   rD1 .1  r=n/t . (Hint: Use equation (C.25).)
d. Show that

Pn1
rD0

r t  nt C1 =.t C 1/.

e. Prove that E ŒX t   n=.t C 1/.
f. Show that C OMPACT-L IST-S EARCH 0 .L; n; k; t/ runs in O.t C n=t/ expected
time.
p
g. Conclude that C OMPACT-L IST-S EARCH runs in O. n/ expected time.
h. Why do we assume that all keys are distinct in C OMPACT-L IST-S EARCH? Argue that random skips do not necessarily help asymptotically when the list contains repeated key values.

Chapter notes
Aho, Hopcroft, and Ullman [6] and Knuth [209] are excellent references for elementary data structures. Many other texts cover both basic data structures and their
implementation in a particular programming language. Examples of these types of
textbooks include Goodrich and Tamassia [147], Main [241], Shaffer [311], and
Weiss [352, 353, 354]. Gonnet [145] provides experimental data on the performance of many data-structure operations.
The origin of stacks and queues as data structures in computer science is unclear, since corresponding notions already existed in mathematics and paper-based
business practices before the introduction of digital computers. Knuth [209] cites
A. M. Turing for the development of stacks for subroutine linkage in 1947.
Pointer-based data structures also seem to be a folk invention. According to
Knuth, pointers were apparently used in early computers with drum memories. The
A-1 language developed by G. M. Hopper in 1951 represented algebraic formulas
as binary trees. Knuth credits the IPL-II language, developed in 1956 by A. Newell,
J. C. Shaw, and H. A. Simon, for recognizing the importance and promoting the
use of pointers. Their IPL-III language, developed in 1957, included explicit stack
operations.

11

Hash Tables

Many applications require a dynamic set that supports only the dictionary operations I NSERT, S EARCH, and D ELETE. For example, a compiler that translates a
programming language maintains a symbol table, in which the keys of elements
are arbitrary character strings corresponding to identiﬁers in the language. A hash
table is an effective data structure for implementing dictionaries. Although searching for an element in a hash table can take as long as searching for an element in a
linked list—‚.n/ time in the worst case—in practice, hashing performs extremely
well. Under reasonable assumptions, the average time to search for an element in
a hash table is O.1/.
A hash table generalizes the simpler notion of an ordinary array. Directly addressing into an ordinary array makes effective use of our ability to examine an
arbitrary position in an array in O.1/ time. Section 11.1 discusses direct addressing in more detail. We can take advantage of direct addressing when we can afford
to allocate an array that has one position for every possible key.
When the number of keys actually stored is small relative to the total number of
possible keys, hash tables become an effective alternative to directly addressing an
array, since a hash table typically uses an array of size proportional to the number
of keys actually stored. Instead of using the key as an array index directly, the array
index is computed from the key. Section 11.2 presents the main ideas, focusing on
“chaining” as a way to handle “collisions,” in which more than one key maps to the
same array index. Section 11.3 describes how we can compute array indices from
keys using hash functions. We present and analyze several variations on the basic
theme. Section 11.4 looks at “open addressing,” which is another way to deal with
collisions. The bottom line is that hashing is an extremely effective and practical
technique: the basic dictionary operations require only O.1/ time on the average.
Section 11.5 explains how “perfect hashing” can support searches in O.1/ worstcase time, when the set of keys being stored is static (that is, when the set of keys
never changes once stored).

254

Chapter 11 Hash Tables

11.1 Direct-address tables
Direct addressing is a simple technique that works well when the universe U of
keys is reasonably small. Suppose that an application needs a dynamic set in which
each element has a key drawn from the universe U D f0; 1; : : : ; m  1g, where m
is not too large. We shall assume that no two elements have the same key.
To represent the dynamic set, we use an array, or direct-address table, denoted
by T Œ0 : : m  1, in which each position, or slot, corresponds to a key in the universe U . Figure 11.1 illustrates the approach; slot k points to an element in the set
with key k. If the set contains no element with key k, then T Œk D NIL.
The dictionary operations are trivial to implement:
D IRECT-A DDRESS -S EARCH .T; k/
1 return T Œk
D IRECT-A DDRESS -I NSERT .T; x/
1 T Œx:key D x
D IRECT-A DDRESS -D ELETE .T; x/
1 T Œx:key D NIL
Each of these operations takes only O.1/ time.
T
0

9

U
(universe of keys)
0
6
7
4

1
K
(actual
keys)

2
3

3

key

satellite data

2
3

4
5

2
5

1

5

6

8

7
8

8

9

Figure 11.1 How to implement a dynamic set by a direct-address table T . Each key in the universe
U D f0; 1; : : : ; 9g corresponds to an index in the table. The set K D f2; 3; 5; 8g of actual keys
determines the slots in the table that contain pointers to elements. The other slots, heavily shaded,
contain NIL .

11.1 Direct-address tables

255

For some applications, the direct-address table itself can hold the elements in the
dynamic set. That is, rather than storing an element’s key and satellite data in an
object external to the direct-address table, with a pointer from a slot in the table to
the object, we can store the object in the slot itself, thus saving space. We would
use a special key within an object to indicate an empty slot. Moreover, it is often
unnecessary to store the key of the object, since if we have the index of an object
in the table, we have its key. If keys are not stored, however, we must have some
way to tell whether the slot is empty.
Exercises
11.1-1
Suppose that a dynamic set S is represented by a direct-address table T of length m.
Describe a procedure that ﬁnds the maximum element of S. What is the worst-case
performance of your procedure?
11.1-2
A bit vector is simply an array of bits (0s and 1s). A bit vector of length m takes
much less space than an array of m pointers. Describe how to use a bit vector
to represent a dynamic set of distinct elements with no satellite data. Dictionary
operations should run in O.1/ time.
11.1-3
Suggest how to implement a direct-address table in which the keys of stored elements do not need to be distinct and the elements can have satellite data. All
three dictionary operations (I NSERT, D ELETE, and S EARCH) should run in O.1/
time. (Don’t forget that D ELETE takes as an argument a pointer to an object to be
deleted, not a key.)
11.1-4 ?
We wish to implement a dictionary by using direct addressing on a huge array. At
the start, the array entries may contain garbage, and initializing the entire array
is impractical because of its size. Describe a scheme for implementing a directaddress dictionary on a huge array. Each stored object should use O.1/ space;
the operations S EARCH, I NSERT, and D ELETE should take O.1/ time each; and
initializing the data structure should take O.1/ time. (Hint: Use an additional array,
treated somewhat like a stack whose size is the number of keys actually stored in
the dictionary, to help determine whether a given entry in the huge array is valid or
not.)

256

Chapter 11 Hash Tables

11.2 Hash tables
The downside of direct addressing is obvious: if the universe U is large, storing
a table T of size jU j may be impractical, or even impossible, given the memory
available on a typical computer. Furthermore, the set K of keys actually stored
may be so small relative to U that most of the space allocated for T would be
wasted.
When the set K of keys stored in a dictionary is much smaller than the universe U of all possible keys, a hash table requires much less storage than a directaddress table. Speciﬁcally, we can reduce the storage requirement to ‚.jKj/ while
we maintain the beneﬁt that searching for an element in the hash table still requires
only O.1/ time. The catch is that this bound is for the average-case time, whereas
for direct addressing it holds for the worst-case time.
With direct addressing, an element with key k is stored in slot k. With hashing,
this element is stored in slot h.k/; that is, we use a hash function h to compute the
slot from the key k. Here, h maps the universe U of keys into the slots of a hash
table T Œ0 : : m  1:
h W U ! f0; 1; : : : ; m  1g ;
where the size m of the hash table is typically much less than jU j. We say that an
element with key k hashes to slot h.k/; we also say that h.k/ is the hash value of
key k. Figure 11.2 illustrates the basic idea. The hash function reduces the range
of array indices and hence the size of the array. Instead of a size of jU j, the array
can have size m.
T
0
U
(universe of keys)
k1
K
(actual
keys)

k4
k2

k5
k3

h(k1)
h(k4)
h(k2) = h(k5)
h(k3)
m–1

Figure 11.2 Using a hash function h to map keys to hash-table slots. Because keys k2 and k5 map
to the same slot, they collide.

11.2 Hash tables

257

T
U
(universe of keys)

k1

k4

k5

k2

k3
k8

k6

k1
K
(actual
keys)

k4

k5
k7

k2
k6

k8

k3

k7

Figure 11.3 Collision resolution by chaining. Each hash-table slot T Œj  contains a linked list of
all the keys whose hash value is j . For example, h.k1 / D h.k4 / and h.k5 / D h.k7 / D h.k2 /.
The linked list can be either singly or doubly linked; we show it as doubly linked because deletion is
faster that way.

There is one hitch: two keys may hash to the same slot. We call this situation
a collision. Fortunately, we have effective techniques for resolving the conﬂict
created by collisions.
Of course, the ideal solution would be to avoid collisions altogether. We might
try to achieve this goal by choosing a suitable hash function h. One idea is to
make h appear to be “random,” thus avoiding collisions or at least minimizing
their number. The very term “to hash,” evoking images of random mixing and
chopping, captures the spirit of this approach. (Of course, a hash function h must be
deterministic in that a given input k should always produce the same output h.k/.)
Because jU j > m, however, there must be at least two keys that have the same hash
value; avoiding collisions altogether is therefore impossible. Thus, while a welldesigned, “random”-looking hash function can minimize the number of collisions,
we still need a method for resolving the collisions that do occur.
The remainder of this section presents the simplest collision resolution technique, called chaining. Section 11.4 introduces an alternative method for resolving
collisions, called open addressing.
Collision resolution by chaining
In chaining, we place all the elements that hash to the same slot into the same
linked list, as Figure 11.3 shows. Slot j contains a pointer to the head of the list of
all stored elements that hash to j ; if there are no such elements, slot j contains NIL.

258

Chapter 11 Hash Tables

The dictionary operations on a hash table T are easy to implement when collisions are resolved by chaining:
C HAINED -H ASH -I NSERT .T; x/
1 insert x at the head of list T Œh.x:key/
C HAINED -H ASH -S EARCH .T; k/
1 search for an element with key k in list T Œh.k/
C HAINED -H ASH -D ELETE .T; x/
1 delete x from the list T Œh.x:key/
The worst-case running time for insertion is O.1/. The insertion procedure is fast
in part because it assumes that the element x being inserted is not already present in
the table; if necessary, we can check this assumption (at additional cost) by searching for an element whose key is x:key before we insert. For searching, the worstcase running time is proportional to the length of the list; we shall analyze this
operation more closely below. We can delete an element in O.1/ time if the lists
are doubly linked, as Figure 11.3 depicts. (Note that C HAINED -H ASH -D ELETE
takes as input an element x and not its key k, so that we don’t have to search for x
ﬁrst. If the hash table supports deletion, then its linked lists should be doubly linked
so that we can delete an item quickly. If the lists were only singly linked, then to
delete element x, we would ﬁrst have to ﬁnd x in the list T Œh.x:key/ so that we
could update the next attribute of x’s predecessor. With singly linked lists, both
deletion and searching would have the same asymptotic running times.)
Analysis of hashing with chaining
How well does hashing with chaining perform? In particular, how long does it take
to search for an element with a given key?
Given a hash table T with m slots that stores n elements, we deﬁne the load
factor ˛ for T as n=m, that is, the average number of elements stored in a chain.
Our analysis will be in terms of ˛, which can be less than, equal to, or greater
than 1.
The worst-case behavior of hashing with chaining is terrible: all n keys hash
to the same slot, creating a list of length n. The worst-case time for searching is
thus ‚.n/ plus the time to compute the hash function—no better than if we used
one linked list for all the elements. Clearly, we do not use hash tables for their
worst-case performance. (Perfect hashing, described in Section 11.5, does provide
good worst-case performance when the set of keys is static, however.)
The average-case performance of hashing depends on how well the hash function h distributes the set of keys to be stored among the m slots, on the average.

11.2 Hash tables

259

Section 11.3 discusses these issues, but for now we shall assume that any given
element is equally likely to hash into any of the m slots, independently of where
any other element has hashed to. We call this the assumption of simple uniform
hashing.
For j D 0; 1; : : : ; m  1, let us denote the length of the list T Œj  by nj , so that
n D n0 C n1 C    C nm1 ;

(11.1)

and the expected value of nj is E Œnj  D ˛ D n=m.
We assume that O.1/ time sufﬁces to compute the hash value h.k/, so that
the time required to search for an element with key k depends linearly on the
length nh.k/ of the list T Œh.k/. Setting aside the O.1/ time required to compute
the hash function and to access slot h.k/, let us consider the expected number of
elements examined by the search algorithm, that is, the number of elements in the
list T Œh.k/ that the algorithm checks to see whether any have a key equal to k. We
shall consider two cases. In the ﬁrst, the search is unsuccessful: no element in the
table has key k. In the second, the search successfully ﬁnds an element with key k.
Theorem 11.1
In a hash table in which collisions are resolved by chaining, an unsuccessful search
takes average-case time ‚.1C˛/, under the assumption of simple uniform hashing.

Proof Under the assumption of simple uniform hashing, any key k not already
stored in the table is equally likely to hash to any of the m slots. The expected time
to search unsuccessfully for a key k is the expected time to search to the end of
list T Œh.k/, which has expected length E Œnh.k/  D ˛. Thus, the expected number
of elements examined in an unsuccessful search is ˛, and the total time required
(including the time for computing h.k/) is ‚.1 C ˛/.
The situation for a successful search is slightly different, since each list is not
equally likely to be searched. Instead, the probability that a list is searched is proportional to the number of elements it contains. Nonetheless, the expected search
time still turns out to be ‚.1 C ˛/.
Theorem 11.2
In a hash table in which collisions are resolved by chaining, a successful search
takes average-case time ‚.1C˛/, under the assumption of simple uniform hashing.

Proof We assume that the element being searched for is equally likely to be any
of the n elements stored in the table. The number of elements examined during a
successful search for an element x is one more than the number of elements that

260

Chapter 11 Hash Tables

appear before x in x’s list. Because new elements are placed at the front of the
list, elements before x in the list were all inserted after x was inserted. To ﬁnd
the expected number of elements examined, we take the average, over the n elements x in the table, of 1 plus the expected number of elements added to x’s list
after x was added to the list. Let xi denote the ith element inserted into the table, for i D 1; 2; : : : ; n, and let ki D xi :key. For keys ki and kj , we deﬁne the
indicator random variable Xij D I fh.ki / D h.kj /g. Under the assumption of simple uniform hashing, we have Pr fh.ki / D h.kj /g D 1=m, and so by Lemma 5.1,
E ŒXij  D 1=m. Thus, the expected number of elements examined in a successful
search is
!#
" n
n
X
1X
Xij
1C
E
n i D1
j Di C1
!
n
n
X
1X
E ŒXij 
(by linearity of expectation)
1C
D
n i D1
j Di C1
!
n
n
X
1
1X
1C
D
n i D1
m
j Di C1
1 X
.n  i/
D 1C
nm i D1
n

!
n
n
X
1 X
n
i
D 1C
nm i D1
i D1


n.n C 1/
1
2
n 
(by equation (A.1))
D 1C
nm
2
n1
D 1C
2m
˛
˛
:
D 1C 
2 2n
Thus, the total time required for a successful search (including the time for computing the hash function) is ‚.2 C ˛=2  ˛=2n/ D ‚.1 C ˛/.
What does this analysis mean? If the number of hash-table slots is at least proportional to the number of elements in the table, we have n D O.m/ and, consequently, ˛ D n=m D O.m/=m D O.1/. Thus, searching takes constant time
on average. Since insertion takes O.1/ worst-case time and deletion takes O.1/
worst-case time when the lists are doubly linked, we can support all dictionary
operations in O.1/ time on average.

11.2 Hash tables

261

Exercises
11.2-1
Suppose we use a hash function h to hash n distinct keys into an array T of
length m. Assuming simple uniform hashing, what is the expected number of
collisions? More precisely, what is the expected cardinality of ffk; lg W k ¤ l and
h.k/ D h.l/g?
11.2-2
Demonstrate what happens when we insert the keys 5; 28; 19; 15; 20; 33; 12; 17; 10
into a hash table with collisions resolved by chaining. Let the table have 9 slots,
and let the hash function be h.k/ D k mod 9.
11.2-3
Professor Marley hypothesizes that he can obtain substantial performance gains by
modifying the chaining scheme to keep each list in sorted order. How does the professor’s modiﬁcation affect the running time for successful searches, unsuccessful
searches, insertions, and deletions?
11.2-4
Suggest how to allocate and deallocate storage for elements within the hash table
itself by linking all unused slots into a free list. Assume that one slot can store
a ﬂag and either one element plus a pointer or two pointers. All dictionary and
free-list operations should run in O.1/ expected time. Does the free list need to be
doubly linked, or does a singly linked free list sufﬁce?
11.2-5
Suppose that we are storing a set of n keys into a hash table of size m. Show that if
the keys are drawn from a universe U with jU j > nm, then U has a subset of size n
consisting of keys that all hash to the same slot, so that the worst-case searching
time for hashing with chaining is ‚.n/.
11.2-6
Suppose we have stored n keys in a hash table of size m, with collisions resolved by
chaining, and that we know the length of each chain, including the length L of the
longest chain. Describe a procedure that selects a key uniformly at random from
among the keys in the hash table and returns it in expected time O.L  .1 C 1=˛//.

262

Chapter 11 Hash Tables

11.3 Hash functions
In this section, we discuss some issues regarding the design of good hash functions
and then present three schemes for their creation. Two of the schemes, hashing by
division and hashing by multiplication, are heuristic in nature, whereas the third
scheme, universal hashing, uses randomization to provide provably good performance.
What makes a good hash function?
A good hash function satisﬁes (approximately) the assumption of simple uniform
hashing: each key is equally likely to hash to any of the m slots, independently of
where any other key has hashed to. Unfortunately, we typically have no way to
check this condition, since we rarely know the probability distribution from which
the keys are drawn. Moreover, the keys might not be drawn independently.
Occasionally we do know the distribution. For example, if we know that the
keys are random real numbers k independently and uniformly distributed in the
range 0  k < 1, then the hash function
h.k/ D bkmc
satisﬁes the condition of simple uniform hashing.
In practice, we can often employ heuristic techniques to create a hash function
that performs well. Qualitative information about the distribution of keys may be
useful in this design process. For example, consider a compiler’s symbol table, in
which the keys are character strings representing identiﬁers in a program. Closely
related symbols, such as pt and pts, often occur in the same program. A good
hash function would minimize the chance that such variants hash to the same slot.
A good approach derives the hash value in a way that we expect to be independent of any patterns that might exist in the data. For example, the “division method”
(discussed in Section 11.3.1) computes the hash value as the remainder when the
key is divided by a speciﬁed prime number. This method frequently gives good
results, assuming that we choose a prime number that is unrelated to any patterns
in the distribution of keys.
Finally, we note that some applications of hash functions might require stronger
properties than are provided by simple uniform hashing. For example, we might
want keys that are “close” in some sense to yield hash values that are far apart.
(This property is especially desirable when we are using linear probing, deﬁned in
Section 11.4.) Universal hashing, described in Section 11.3.3, often provides the
desired properties.

11.3 Hash functions

263

Interpreting keys as natural numbers
Most hash functions assume that the universe of keys is the set N D f0; 1; 2; : : :g
of natural numbers. Thus, if the keys are not natural numbers, we ﬁnd a way to
interpret them as natural numbers. For example, we can interpret a character string
as an integer expressed in suitable radix notation. Thus, we might interpret the
identiﬁer pt as the pair of decimal integers .112; 116/, since p D 112 and t D 116
in the ASCII character set; then, expressed as a radix-128 integer, pt becomes
.112  128/ C 116 D 14452. In the context of a given application, we can usually
devise some such method for interpreting each key as a (possibly large) natural
number. In what follows, we assume that the keys are natural numbers.
11.3.1

The division method

In the division method for creating hash functions, we map a key k into one of m
slots by taking the remainder of k divided by m. That is, the hash function is
h.k/ D k mod m :
For example, if the hash table has size m D 12 and the key is k D 100, then
h.k/ D 4. Since it requires only a single division operation, hashing by division is
quite fast.
When using the division method, we usually avoid certain values of m. For
example, m should not be a power of 2, since if m D 2p , then h.k/ is just the p
lowest-order bits of k. Unless we know that all low-order p-bit patterns are equally
likely, we are better off designing the hash function to depend on all the bits of the
key. As Exercise 11.3-3 asks you to show, choosing m D 2p  1 when k is a
character string interpreted in radix 2p may be a poor choice, because permuting
the characters of k does not change its hash value.
A prime not too close to an exact power of 2 is often a good choice for m. For
example, suppose we wish to allocate a hash table, with collisions resolved by
chaining, to hold roughly n D 2000 character strings, where a character has 8 bits.
We don’t mind examining an average of 3 elements in an unsuccessful search, and
so we allocate a hash table of size m D 701. We could choose m D 701 because
it is a prime near 2000=3 but not near any power of 2. Treating each key k as an
integer, our hash function would be
h.k/ D k mod 701 :
11.3.2

The multiplication method

The multiplication method for creating hash functions operates in two steps. First,
we multiply the key k by a constant A in the range 0 < A < 1 and extract the

264

Chapter 11 Hash Tables

w bits
k
×

s D A  2w

r1

r0
extract p bits
h.k/

Figure 11.4 The multiplication method of hashing. The w-bit representation of the key k is multiplied by the w-bit value s D A  2w . The p highest-order bits of the lower w-bit half of the product
form the desired hash value h.k/.

fractional part of kA. Then, we multiply this value by m and take the ﬂoor of the
result. In short, the hash function is
h.k/ D bm .kA mod 1/c ;
where “kA mod 1” means the fractional part of kA, that is, kA  bkAc.
An advantage of the multiplication method is that the value of m is not critical.
We typically choose it to be a power of 2 (m D 2p for some integer p), since we
can then easily implement the function on most computers as follows. Suppose
that the word size of the machine is w bits and that k ﬁts into a single word. We
restrict A to be a fraction of the form s=2w , where s is an integer in the range
0 < s < 2w . Referring to Figure 11.4, we ﬁrst multiply k by the w-bit integer
s D A  2w . The result is a 2w-bit value r1 2w C r0 , where r1 is the high-order word
of the product and r0 is the low-order word of the product. The desired p-bit hash
value consists of the p most signiﬁcant bits of r0 .
Although this method works with any value of the constant A, it works better
with some values than with others. The optimal choice depends on the characteristics of the data being hashed. Knuth [211] suggests that
p
(11.2)
A  . 5  1/=2 D 0:6180339887 : : :
is likely to work reasonably well.
As an example, suppose we have k D 123456, p D 14, m D 214 D 16384,
and w D 32. Adapting Knuth’spsuggestion, we choose A to be the fraction of the
form s=232 that is closest to . 5  1/=2, so that A D 2654435769=232 . Then
k  s D 327706022297664 D .76300  232 / C 17612864, and so r1 D 76300
and r0 D 17612864. The 14 most signiﬁcant bits of r0 yield the value h.k/ D 67.

11.3 Hash functions

?

11.3.3

265

Universal hashing

If a malicious adversary chooses the keys to be hashed by some ﬁxed hash function,
then the adversary can choose n keys that all hash to the same slot, yielding an average retrieval time of ‚.n/. Any ﬁxed hash function is vulnerable to such terrible
worst-case behavior; the only effective way to improve the situation is to choose
the hash function randomly in a way that is independent of the keys that are actually
going to be stored. This approach, called universal hashing, can yield provably
good performance on average, no matter which keys the adversary chooses.
In universal hashing, at the beginning of execution we select the hash function
at random from a carefully designed class of functions. As in the case of quicksort, randomization guarantees that no single input will always evoke worst-case
behavior. Because we randomly select the hash function, the algorithm can behave differently on each execution, even for the same input, guaranteeing good
average-case performance for any input. Returning to the example of a compiler’s
symbol table, we ﬁnd that the programmer’s choice of identiﬁers cannot now cause
consistently poor hashing performance. Poor performance occurs only when the
compiler chooses a random hash function that causes the set of identiﬁers to hash
poorly, but the probability of this situation occurring is small and is the same for
any set of identiﬁers of the same size.
Let H be a ﬁnite collection of hash functions that map a given universe U of
keys into the range f0; 1; : : : ; m  1g. Such a collection is said to be universal
if for each pair of distinct keys k; l 2 U , the number of hash functions h 2 H
for which h.k/ D h.l/ is at most jH j =m. In other words, with a hash function
randomly chosen from H , the chance of a collision between distinct keys k and l
is no more than the chance 1=m of a collision if h.k/ and h.l/ were randomly and
independently chosen from the set f0; 1; : : : ; m  1g.
The following theorem shows that a universal class of hash functions gives good
average-case behavior. Recall that ni denotes the length of list T Œi.
Theorem 11.3
Suppose that a hash function h is chosen randomly from a universal collection of
hash functions and has been used to hash n keys into a table T of size m, using chaining to resolve collisions. If key k is not in the table, then the expected
length E Œnh.k/  of the list that key k hashes to is at most the load factor ˛ D n=m.
If key k is in the table, then the expected length E Œnh.k/  of the list containing key k
is at most 1 C ˛.
Proof We note that the expectations here are over the choice of the hash function and do not depend on any assumptions about the distribution of the keys.
For each pair k and l of distinct keys, deﬁne the indicator random variable

266

Chapter 11 Hash Tables

Xkl D I fh.k/ D h.l/g. Since by the deﬁnition of a universal collection of hash
functions, a single pair of keys collides with probability at most 1=m, we have
Pr fh.k/ D h.l/g  1=m. By Lemma 5.1, therefore, we have E ŒXkl   1=m.
Next we deﬁne, for each key k, the random variable Yk that equals the number
of keys other than k that hash to the same slot as k, so that
X
Xkl :
Yk D
l2T
l¤k

Thus we have

2X

E ŒYk  D E4
D

l2T
l¤k

X

3
Xkl 5

E ŒXkl 

(by linearity of expectation)

l2T
l¤k



X 1
:
m
l2T
l¤k

The remainder of the proof depends on whether key k is in table T .


If k 62 T , then nh.k/ D Yk and jfl W l 2 T and l ¤ kgj D n. Thus E Œnh.k/  D
E ŒYk   n=m D ˛.



If k 2 T , then because key k appears in list T Œh.k/ and the count Yk does not
include key k, we have nh.k/ D Yk C 1 and jfl W l 2 T and l ¤ kgj D n  1.
Thus E Œnh.k/  D E ŒYk  C 1  .n  1/=m C 1 D 1 C ˛  1=m < 1 C ˛.

The following corollary says universal hashing provides the desired payoff: it
has now become impossible for an adversary to pick a sequence of operations that
forces the worst-case running time. By cleverly randomizing the choice of hash
function at run time, we guarantee that we can process every sequence of operations
with a good average-case running time.
Corollary 11.4
Using universal hashing and collision resolution by chaining in an initially empty
table with m slots, it takes expected time ‚.n/ to handle any sequence of n I NSERT,
S EARCH, and D ELETE operations containing O.m/ I NSERT operations.
Proof Since the number of insertions is O.m/, we have n D O.m/ and so
˛ D O.1/. The I NSERT and D ELETE operations take constant time and, by Theorem 11.3, the expected time for each S EARCH operation is O.1/. By linearity of

11.3 Hash functions

267

expectation, therefore, the expected time for the entire sequence of n operations
is O.n/. Since each operation takes .1/ time, the ‚.n/ bound follows.
Designing a universal class of hash functions
It is quite easy to design a universal class of hash functions, as a little number
theory will help us prove. You may wish to consult Chapter 31 ﬁrst if you are
unfamiliar with number theory.
We begin by choosing a prime number p large enough so that every possible
key k is in the range 0 to p  1, inclusive. Let Zp denote the set f0; 1; : : : ; p  1g,
and let Zp denote the set f1; 2; : : : ; p  1g. Since p is prime, we can solve equations modulo p with the methods given in Chapter 31. Because we assume that the
size of the universe of keys is greater than the number of slots in the hash table, we
have p > m.
We now deﬁne the hash function hab for any a 2 Zp and any b 2 Zp using a
linear transformation followed by reductions modulo p and then modulo m:
hab .k/ D ..ak C b/ mod p/ mod m :

(11.3)

For example, with p D 17 and m D 6, we have h3;4 .8/ D 5. The family of all
such hash functions is
˚
(11.4)
Hpm D hab W a 2 Zp and b 2 Zp :
Each hash function hab maps Zp to Zm . This class of hash functions has the nice
property that the size m of the output range is arbitrary—not necessarily prime—a
feature which we shall use in Section 11.5. Since we have p  1 choices for a
and p choices for b, the collection Hpm contains p.p  1/ hash functions.
Theorem 11.5
The class Hpm of hash functions deﬁned by equations (11.3) and (11.4) is universal.
Proof Consider two distinct keys k and l from Zp , so that k ¤ l. For a given
hash function hab we let
r D .ak C b/ mod p ;
s D .al C b/ mod p :
We ﬁrst note that r ¤ s. Why? Observe that
r  s  a.k  l/ .mod p/ :
It follows that r ¤ s because p is prime and both a and .k  l/ are nonzero
modulo p, and so their product must also be nonzero modulo p by Theorem 31.6.
Therefore, when computing any hab 2 Hpm , distinct inputs k and l map to distinct

268

Chapter 11 Hash Tables

values r and s modulo p; there are no collisions yet at the “mod p level.” Moreover,
each of the possible p.p1/ choices for the pair .a; b/ with a ¤ 0 yields a different
resulting pair .r; s/ with r ¤ s, since we can solve for a and b given r and s:
a D .r  s/..k  l/1 mod p/ mod p ;
b D .r  ak/ mod p ;
where ..k  l/1 mod p/ denotes the unique multiplicative inverse, modulo p,
of k  l. Since there are only p.p  1/ possible pairs .r; s/ with r ¤ s, there
is a one-to-one correspondence between pairs .a; b/ with a ¤ 0 and pairs .r; s/
with r ¤ s. Thus, for any given pair of inputs k and l, if we pick .a; b/ uniformly
at random from Zp Zp , the resulting pair .r; s/ is equally likely to be any pair of
distinct values modulo p.
Therefore, the probability that distinct keys k and l collide is equal to the probability that r  s .mod m/ when r and s are randomly chosen as distinct values
modulo p. For a given value of r, of the p  1 possible remaining values for s, the
number of values s such that s ¤ r and s  r .mod m/ is at most
dp=me  1  ..p C m  1/=m/  1 (by inequality (3.6))
D .p  1/=m :
The probability that s collides with r when reduced modulo m is at most
..p  1/=m/=.p  1/ D 1=m.
Therefore, for any pair of distinct values k; l 2 Zp ,
Pr fhab .k/ D hab .l/g  1=m ;
so that Hpm is indeed universal.

Exercises
11.3-1
Suppose we wish to search a linked list of length n, where each element contains
a key k along with a hash value h.k/. Each key is a long character string. How
might we take advantage of the hash values when searching the list for an element
with a given key?
11.3-2
Suppose that we hash a string of r characters into m slots by treating it as a
radix-128 number and then using the division method. We can easily represent
the number m as a 32-bit computer word, but the string of r characters, treated as
a radix-128 number, takes many words. How can we apply the division method to
compute the hash value of the character string without using more than a constant
number of words of storage outside the string itself?

11.4 Open addressing

269

11.3-3
Consider a version of the division method in which h.k/ D k mod m, where
m D 2p  1 and k is a character string interpreted in radix 2p . Show that if we
can derive string x from string y by permuting its characters, then x and y hash to
the same value. Give an example of an application in which this property would be
undesirable in a hash function.
11.3-4
Consider a hash table of sizepm D 1000 and a corresponding hash function h.k/ D
bm .kA mod 1/c for A D . 5  1/=2. Compute the locations to which the keys
61, 62, 63, 64, and 65 are mapped.
11.3-5 ?
Deﬁne a family H of hash functions from a ﬁnite set U to a ﬁnite set B to be
-universal if for all pairs of distinct elements k and l in U ,
Pr fh.k/ D h.l/g   ;
where the probability is over the choice of the hash function h drawn at random
from the family H . Show that an -universal family of hash functions must have


1
1

:
jBj jU j

11.3-6 ?
Let U be the set of n-tuples of values drawn from Zp , and let B D Zp , where p
is prime. Deﬁne the hash function hb W U ! B for b 2 Zp on an input n-tuple
ha0 ; a1 ; : : : ; an1 i from U as
!
n1
X
aj b j mod p ;
hb .ha0 ; a1 ; : : : ; an1 i/ D
j D0

and let H D fhb W b 2 Zp g. Argue that H is ..n  1/=p/-universal according to
the deﬁnition of -universal in Exercise 11.3-5. (Hint: See Exercise 31.4-4.)

11.4 Open addressing
In open addressing, all elements occupy the hash table itself. That is, each table
entry contains either an element of the dynamic set or NIL. When searching for
an element, we systematically examine table slots until either we ﬁnd the desired
element or we have ascertained that the element is not in the table. No lists and

270

Chapter 11 Hash Tables

no elements are stored outside the table, unlike in chaining. Thus, in open addressing, the hash table can “ﬁll up” so that no further insertions can be made; one
consequence is that the load factor ˛ can never exceed 1.
Of course, we could store the linked lists for chaining inside the hash table, in
the otherwise unused hash-table slots (see Exercise 11.2-4), but the advantage of
open addressing is that it avoids pointers altogether. Instead of following pointers,
we compute the sequence of slots to be examined. The extra memory freed by not
storing pointers provides the hash table with a larger number of slots for the same
amount of memory, potentially yielding fewer collisions and faster retrieval.
To perform insertion using open addressing, we successively examine, or probe,
the hash table until we ﬁnd an empty slot in which to put the key. Instead of being
ﬁxed in the order 0; 1; : : : ; m  1 (which requires ‚.n/ search time), the sequence
of positions probed depends upon the key being inserted. To determine which slots
to probe, we extend the hash function to include the probe number (starting from 0)
as a second input. Thus, the hash function becomes
hWU

f0; 1; : : : ; m  1g ! f0; 1; : : : ; m  1g :

With open addressing, we require that for every key k, the probe sequence
hh.k; 0/; h.k; 1/; : : : ; h.k; m  1/i
be a permutation of h0; 1; : : : ; m1i, so that every hash-table position is eventually
considered as a slot for a new key as the table ﬁlls up. In the following pseudocode,
we assume that the elements in the hash table T are keys with no satellite information; the key k is identical to the element containing key k. Each slot contains
either a key or NIL (if the slot is empty). The H ASH -I NSERT procedure takes as
input a hash table T and a key k. It either returns the slot number where it stores
key k or ﬂags an error because the hash table is already full.
H ASH -I NSERT .T; k/
1 i D0
2 repeat
3
j D h.k; i/
4
if T Œj  == NIL
5
T Œj  D k
6
return j
7
else i D i C 1
8 until i == m
9 error “hash table overﬂow”
The algorithm for searching for key k probes the same sequence of slots that the
insertion algorithm examined when key k was inserted. Therefore, the search can

11.4 Open addressing

271

terminate (unsuccessfully) when it ﬁnds an empty slot, since k would have been
inserted there and not later in its probe sequence. (This argument assumes that keys
are not deleted from the hash table.) The procedure H ASH -S EARCH takes as input
a hash table T and a key k, returning j if it ﬁnds that slot j contains key k, or NIL
if key k is not present in table T .
H ASH -S EARCH .T; k/
1 i D0
2 repeat
3
j D h.k; i/
4
if T Œj  == k
5
return j
6
i D i C1
7 until T Œj  == NIL or i == m
8 return NIL
Deletion from an open-address hash table is difﬁcult. When we delete a key
from slot i, we cannot simply mark that slot as empty by storing NIL in it. If
we did, we might be unable to retrieve any key k during whose insertion we had
probed slot i and found it occupied. We can solve this problem by marking the
slot, storing in it the special value DELETED instead of NIL. We would then modify
the procedure H ASH -I NSERT to treat such a slot as if it were empty so that we can
insert a new key there. We do not need to modify H ASH -S EARCH, since it will pass
over DELETED values while searching. When we use the special value DELETED,
however, search times no longer depend on the load factor ˛, and for this reason
chaining is more commonly selected as a collision resolution technique when keys
must be deleted.
In our analysis, we assume uniform hashing: the probe sequence of each key
is equally likely to be any of the mŠ permutations of h0; 1; : : : ; m  1i. Uniform hashing generalizes the notion of simple uniform hashing deﬁned earlier to a
hash function that produces not just a single number, but a whole probe sequence.
True uniform hashing is difﬁcult to implement, however, and in practice suitable
approximations (such as double hashing, deﬁned below) are used.
We will examine three commonly used techniques to compute the probe sequences required for open addressing: linear probing, quadratic probing, and double hashing. These techniques all guarantee that hh.k; 0/; h.k; 1/; : : : ; h.k; m  1/i
is a permutation of h0; 1; : : : ; m  1i for each key k. None of these techniques fulﬁlls the assumption of uniform hashing, however, since none of them is capable of
generating more than m2 different probe sequences (instead of the mŠ that uniform
hashing requires). Double hashing has the greatest number of probe sequences and,
as one might expect, seems to give the best results.

272

Chapter 11 Hash Tables

Linear probing
Given an ordinary hash function h0 W U ! f0; 1; : : : ; m  1g, which we refer to as
an auxiliary hash function, the method of linear probing uses the hash function
h.k; i/ D .h0 .k/ C i/ mod m
for i D 0; 1; : : : ; m  1. Given key k, we ﬁrst probe T Œh0 .k/, i.e., the slot given
by the auxiliary hash function. We next probe slot T Œh0 .k/ C 1, and so on up to
slot T Œm  1. Then we wrap around to slots T Œ0; T Œ1; : : : until we ﬁnally probe
slot T Œh0 .k/  1. Because the initial probe determines the entire probe sequence,
there are only m distinct probe sequences.
Linear probing is easy to implement, but it suffers from a problem known as
primary clustering. Long runs of occupied slots build up, increasing the average
search time. Clusters arise because an empty slot preceded by i full slots gets ﬁlled
next with probability .i C 1/=m. Long runs of occupied slots tend to get longer,
and the average search time increases.
Quadratic probing
Quadratic probing uses a hash function of the form
h.k; i/ D .h0 .k/ C c1 i C c2 i 2 / mod m ;

(11.5)

where h0 is an auxiliary hash function, c1 and c2 are positive auxiliary constants,
and i D 0; 1; : : : ; m  1. The initial position probed is T Œh0 .k/; later positions
probed are offset by amounts that depend in a quadratic manner on the probe number i. This method works much better than linear probing, but to make full use of
the hash table, the values of c1 , c2 , and m are constrained. Problem 11-3 shows
one way to select these parameters. Also, if two keys have the same initial probe
position, then their probe sequences are the same, since h.k1 ; 0/ D h.k2 ; 0/ implies h.k1 ; i/ D h.k2 ; i/. This property leads to a milder form of clustering, called
secondary clustering. As in linear probing, the initial probe determines the entire
sequence, and so only m distinct probe sequences are used.
Double hashing
Double hashing offers one of the best methods available for open addressing because the permutations produced have many of the characteristics of randomly
chosen permutations. Double hashing uses a hash function of the form
h.k; i/ D .h1 .k/ C ih2 .k// mod m ;
where both h1 and h2 are auxiliary hash functions. The initial probe goes to position T Œh1 .k/; successive probe positions are offset from previous positions by the

11.4 Open addressing

0
1
2
3
4
5
6
7
8
9
10
11
12

273

79

69
98
72
14
50

Figure 11.5 Insertion by double hashing. Here we have a hash table of size 13 with h1 .k/ D
k mod 13 and h2 .k/ D 1 C .k mod 11/. Since 14  1 .mod 13/ and 14  3 .mod 11/, we insert
the key 14 into empty slot 9, after examining slots 1 and 5 and ﬁnding them to be occupied.

amount h2 .k/, modulo m. Thus, unlike the case of linear or quadratic probing, the
probe sequence here depends in two ways upon the key k, since the initial probe
position, the offset, or both, may vary. Figure 11.5 gives an example of insertion
by double hashing.
The value h2 .k/ must be relatively prime to the hash-table size m for the entire
hash table to be searched. (See Exercise 11.4-4.) A convenient way to ensure this
condition is to let m be a power of 2 and to design h2 so that it always produces an
odd number. Another way is to let m be prime and to design h2 so that it always
returns a positive integer less than m. For example, we could choose m prime and
let
h1 .k/ D k mod m ;
h2 .k/ D 1 C .k mod m0 / ;
where m0 is chosen to be slightly less than m (say, m  1). For example, if
k D 123456, m D 701, and m0 D 700, we have h1 .k/ D 80 and h2 .k/ D 257, so
that we ﬁrst probe position 80, and then we examine every 257th slot (modulo m)
until we ﬁnd the key or have examined every slot.
When m is prime or a power of 2, double hashing improves over linear or quadratic probing in that ‚.m2 / probe sequences are used, rather than ‚.m/, since
each possible .h1 .k/; h2 .k// pair yields a distinct probe sequence. As a result, for

274

Chapter 11 Hash Tables

such values of m, the performance of double hashing appears to be very close to
the performance of the “ideal” scheme of uniform hashing.
Although values of m other than primes or powers of 2 could in principle be
used with double hashing, in practice it becomes more difﬁcult to efﬁciently generate h2 .k/ in a way that ensures that it is relatively prime to m, in part because the
relative density .m/=m of such numbers may be small (see equation (31.24)).
Analysis of open-address hashing
As in our analysis of chaining, we express our analysis of open addressing in terms
of the load factor ˛ D n=m of the hash table. Of course, with open addressing, at
most one element occupies each slot, and thus n  m, which implies ˛  1.
We assume that we are using uniform hashing. In this idealized scheme, the
probe sequence hh.k; 0/; h.k; 1/; : : : ; h.k; m  1/i used to insert or search for
each key k is equally likely to be any permutation of h0; 1; : : : ; m  1i. Of course,
a given key has a unique ﬁxed probe sequence associated with it; what we mean
here is that, considering the probability distribution on the space of keys and the
operation of the hash function on the keys, each possible probe sequence is equally
likely.
We now analyze the expected number of probes for hashing with open addressing under the assumption of uniform hashing, beginning with an analysis of the
number of probes made in an unsuccessful search.
Theorem 11.6
Given an open-address hash table with load factor ˛ D n=m < 1, the expected
number of probes in an unsuccessful search is at most 1=.1˛/, assuming uniform
hashing.
Proof In an unsuccessful search, every probe but the last accesses an occupied
slot that does not contain the desired key, and the last slot probed is empty. Let us
deﬁne the random variable X to be the number of probes made in an unsuccessful
search, and let us also deﬁne the event Ai , for i D 1; 2; : : :, to be the event that
an ith probe occurs and it is to an occupied slot. Then the event fX  ig is the
intersection of events A1 \ A2 \    \ Ai 1 . We will bound Pr fX  ig by bounding
Pr fA1 \ A2 \    \ Ai 1 g. By Exercise C.2-5,
Pr fA1 \ A2 \    \ Ai 1 g D Pr fA1 g  Pr fA2 j A1 g  Pr fA3 j A1 \ A2 g   
Pr fAi 1 j A1 \ A2 \    \ Ai 2 g :
Since there are n elements and m slots, Pr fA1 g D n=m. For j > 1, the probability
that there is a j th probe and it is to an occupied slot, given that the ﬁrst j  1
probes were to occupied slots, is .n  j C 1/=.m  j C 1/. This probability follows

11.4 Open addressing

275

because we would be ﬁnding one of the remaining .n  .j  1// elements in one
of the .m  .j  1// unexamined slots, and by the assumption of uniform hashing,
the probability is the ratio of these quantities. Observing that n < m implies that
.n  j /=.m  j /  n=m for all j such that 0  j < m, we have for all i such that
1  i  m,
ni C2
n n1 n2



m m1 m2
mi C2
 n i 1

m
D ˛ i 1 :

Pr fX  ig D

Now, we use equation (C.25) to bound the expected number of probes:
E ŒX  D

D

1
X
i D1
1
X
i D1
1
X

Pr fX  ig
˛ i 1
˛i

i D0

D

1
:
1˛

This bound of 1=.1  ˛/ D 1 C ˛ C ˛ 2 C ˛ 3 C    has an intuitive interpretation.
We always make the ﬁrst probe. With probability approximately ˛, the ﬁrst probe
ﬁnds an occupied slot, so that we need to probe a second time. With probability
approximately ˛ 2 , the ﬁrst two slots are occupied so that we make a third probe,
and so on.
If ˛ is a constant, Theorem 11.6 predicts that an unsuccessful search runs in O.1/
time. For example, if the hash table is half full, the average number of probes in an
unsuccessful search is at most 1=.1  :5/ D 2. If it is 90 percent full, the average
number of probes is at most 1=.1  :9/ D 10.
Theorem 11.6 gives us the performance of the H ASH -I NSERT procedure almost
immediately.
Corollary 11.7
Inserting an element into an open-address hash table with load factor ˛ requires at
most 1=.1  ˛/ probes on average, assuming uniform hashing.

276

Chapter 11 Hash Tables

Proof An element is inserted only if there is room in the table, and thus ˛ < 1.
Inserting a key requires an unsuccessful search followed by placing the key into the
ﬁrst empty slot found. Thus, the expected number of probes is at most 1=.1˛/.
We have to do a little more work to compute the expected number of probes for
a successful search.
Theorem 11.8
Given an open-address hash table with load factor ˛ < 1, the expected number of
probes in a successful search is at most
1
1
ln
;
˛ 1˛
assuming uniform hashing and assuming that each key in the table is equally likely
to be searched for.
Proof A search for a key k reproduces the same probe sequence as when the
element with key k was inserted. By Corollary 11.7, if k was the .i C 1/st key
inserted into the hash table, the expected number of probes made in a search for k
is at most 1=.1  i=m/ D m=.m  i/. Averaging over all n keys in the hash table
gives us the expected number of probes in a successful search:
1X m
n i D0 m  i

D

mX 1
n i D0 m  i

D

1
˛

n1

n1


D
D

m
X
kDmnC1

1
k

Z
1 m
.1=x/ dx (by inequality (A.12))
˛ mn
m
1
ln
˛ mn
1
1
ln
:
˛ 1˛

If the hash table is half full, the expected number of probes in a successful search
is less than 1:387. If the hash table is 90 percent full, the expected number of probes
is less than 2:559.

11.5 Perfect hashing

277

Exercises
11.4-1
Consider inserting the keys 10; 22; 31; 4; 15; 28; 17; 88; 59 into a hash table of
length m D 11 using open addressing with the auxiliary hash function h0 .k/ D k.
Illustrate the result of inserting these keys using linear probing, using quadratic
probing with c1 D 1 and c2 D 3, and using double hashing with h1 .k/ D k and
h2 .k/ D 1 C .k mod .m  1//.
11.4-2
Write pseudocode for H ASH -D ELETE as outlined in the text, and modify H ASH I NSERT to handle the special value DELETED.
11.4-3
Consider an open-address hash table with uniform hashing. Give upper bounds
on the expected number of probes in an unsuccessful search and on the expected
number of probes in a successful search when the load factor is 3=4 and when it
is 7=8.
11.4-4 ?
Suppose that we use double hashing to resolve collisions—that is, we use the hash
function h.k; i/ D .h1 .k/ C ih2 .k// mod m. Show that if m and h2 .k/ have
greatest common divisor d  1 for some key k, then an unsuccessful search for
key k examines .1=d /th of the hash table before returning to slot h1 .k/. Thus,
when d D 1, so that m and h2 .k/ are relatively prime, the search may examine the
entire hash table. (Hint: See Chapter 31.)
11.4-5 ?
Consider an open-address hash table with a load factor ˛. Find the nonzero value ˛
for which the expected number of probes in an unsuccessful search equals twice
the expected number of probes in a successful search. Use the upper bounds given
by Theorems 11.6 and 11.8 for these expected numbers of probes.

? 11.5 Perfect hashing
Although hashing is often a good choice for its excellent average-case performance, hashing can also provide excellent worst-case performance when the set of
keys is static: once the keys are stored in the table, the set of keys never changes.
Some applications naturally have static sets of keys: consider the set of reserved
words in a programming language, or the set of ﬁle names on a CD-ROM. We

278

Chapter 11 Hash Tables

T
0
1
2

S
m0 a0 b0 0
1 0 0 10
m2 a2 b2
9 10 18

60 72

3

0

4

S5

5
6
7
8

S2

0

1

2

3

4

75
5

6

7

8

m5 a5 b5
1 0 0 70
m7 a7 b7
16 23 88

S7

0

40 52 22
0

1

2

3

4

5

6

7

8

9

37
10

11

12

13

14

15

Figure 11.6 Using perfect hashing to store the set K D f10; 22; 37; 40; 52; 60; 70; 72; 75g. The
outer hash function is h.k/ D ..ak C b/ mod p/ mod m, where a D 3, b D 42, p D 101, and
m D 9. For example, h.75/ D 2, and so key 75 hashes to slot 2 of table T . A secondary hash
table Sj stores all keys hashing to slot j . The size of hash table Sj is mj D nj2 , and the associated
hash function is hj .k/ D ..aj k C bj / mod p/ mod mj . Since h2 .75/ D 7, key 75 is stored in slot 7
of secondary hash table S2 . No collisions occur in any of the secondary hash tables, and so searching
takes constant time in the worst case.

call a hashing technique perfect hashing if O.1/ memory accesses are required to
perform a search in the worst case.
To create a perfect hashing scheme, we use two levels of hashing, with universal
hashing at each level. Figure 11.6 illustrates the approach.
The ﬁrst level is essentially the same as for hashing with chaining: we hash
the n keys into m slots using a hash function h carefully selected from a family of
universal hash functions.
Instead of making a linked list of the keys hashing to slot j , however, we use a
small secondary hash table Sj with an associated hash function hj . By choosing
the hash functions hj carefully, we can guarantee that there are no collisions at the
secondary level.
In order to guarantee that there are no collisions at the secondary level, however,
we will need to let the size mj of hash table Sj be the square of the number nj of
keys hashing to slot j . Although you might think that the quadratic dependence
of mj on nj may seem likely to cause the overall storage requirement to be excessive, we shall show that by choosing the ﬁrst-level hash function well, we can limit
the expected total amount of space used to O.n/.
We use hash functions chosen from the universal classes of hash functions of
Section 11.3.3. The ﬁrst-level hash function comes from the class Hpm , where as
in Section 11.3.3, p is a prime number greater than any key value. Those keys

11.5 Perfect hashing

279

hashing to slot j are re-hashed into a secondary hash table Sj of size mj using a
hash function hj chosen from the class Hp;mj .1
We shall proceed in two steps. First, we shall determine how to ensure that
the secondary tables have no collisions. Second, we shall show that the expected
amount of memory used overall—for the primary hash table and all the secondary
hash tables—is O.n/.
Theorem 11.9
Suppose that we store n keys in a hash table of size m D n2 using a hash function h
randomly chosen from a universal class of hash functions. Then, the probability is
less than 1=2 that there are any collisions.
Proof There are n2 pairs of keys that may collide; each pair collides with probability 1=m if h is chosen at random from a universal family H of hash functions.
Let X be a random variable that counts the number of collisions. When m D n2 ,
the expected number of collisions is
!
n
1
E ŒX  D
 2
n
2
n2  n 1
 2
2
n
< 1=2 :

D

(This analysis is similar to the analysis of the birthday paradox in Section 5.4.1.)
Applying Markov’s inequality (C.30), Pr fX  tg  E ŒX  =t, with t D 1, completes the proof.
In the situation described in Theorem 11.9, where m D n2 , it follows that a hash
function h chosen at random from H is more likely than not to have no collisions.
Given the set K of n keys to be hashed (remember that K is static), it is thus easy
to ﬁnd a collision-free hash function h with a few random trials.
When n is large, however, a hash table of size m D n2 is excessive. Therefore,
we adopt the two-level hashing approach, and we use the approach of Theorem 11.9
only to hash the entries within each slot. We use an outer, or ﬁrst-level, hash
function h to hash the keys into m D n slots. Then, if nj keys hash to slot j , we
use a secondary hash table Sj of size mj D nj2 to provide collision-free constanttime lookup.

1 When n D m D 1, we don’t really need a hash function for slot j ; when we choose a hash
j
j
function hab .k/ D ..ak C b/ mod p/ mod mj for such a slot, we just use a D b D 0.

280

Chapter 11 Hash Tables

We now turn to the issue of ensuring that the overall memory used is O.n/.
Since the size mj of the j th secondary hash table grows quadratically with the
number nj of keys stored, we run the risk that the overall amount of storage could
be excessive.
If the ﬁrst-level table size is m D n, then the amount of memory used is O.n/
for the primary hash table, for the storage of the sizes mj of the secondary hash
tables, and for the storage of the parameters aj and bj deﬁning the secondary hash
functions hj drawn from the class Hp;mj of Section 11.3.3 (except when nj D 1
and we use a D b D 0). The following theorem and a corollary provide a bound on
the expected combined sizes of all the secondary hash tables. A second corollary
bounds the probability that the combined size of all the secondary hash tables is
superlinear (actually, that it equals or exceeds 4n).
Theorem 11.10
Suppose that we store n keys in a hash table of size m D n using a hash function h
randomly chosen from a universal class of hash functions. Then, we have
"m1 #
X
nj2 < 2n ;
E
j D0

where nj is the number of keys hashing to slot j .
Proof We start with the following identity, which holds for any nonnegative integer a:
!
a
:
(11.6)
a2 D a C 2
2
We have
"m1 #
X
nj2
E
j D0

!!#
nj
(by equation (11.6))
nj C 2
D E
2
j D0
!#
"m1
"m1 #
X
X nj
(by linearity of expectation)
nj C 2 E
D E
2
j D0
j D0
!#
"m1
X nj
(by equation (11.1))
D E Œn C 2 E
2
j D0
"m1
X

11.5 Perfect hashing

281

!#
"m1
X nj
D n C 2E
2
j D0

(since n is not a random variable) .

Pm1
To evaluate the summation j D0 n2j , we observe that it is just the total number
of pairs of keys in the hash table that collide. By the properties of universal hashing,
the expected value of this summation is at most
!
n.n  1/
n 1
D
2m
2 m
D

n1
;
2

since m D n. Thus,
"m1 #
X
n1
nj2
 nC2
E
2
j D0
D 2n  1
< 2n :
Corollary 11.11
Suppose that we store n keys in a hash table of size m D n using a hash function h randomly chosen from a universal class of hash functions, and we set the
size of each secondary hash table to mj D nj2 for j D 0; 1; : : : ; m  1. Then,
the expected amount of storage required for all secondary hash tables in a perfect
hashing scheme is less than 2n.
Proof Since mj D nj2 for j D 0; 1; : : : ; m  1, Theorem 11.10 gives
"m1 #
"m1 #
X
X
mj
nj2
D E
E
j D0

j D0

< 2n ;

(11.7)

which completes the proof.
Corollary 11.12
Suppose that we store n keys in a hash table of size m D n using a hash function h
randomly chosen from a universal class of hash functions, and we set the size
of each secondary hash table to mj D nj2 for j D 0; 1; : : : ; m  1. Then, the
probability is less than 1=2 that the total storage used for secondary hash tables
equals or exceeds 4n.

282

Chapter 11 Hash Tables

Proof Again we apply Markov’s inequality
Pm1 (C.30), Pr fX  tg  E ŒX  =t, this
time to inequality (11.7), with X D j D0 mj and t D 4n:
)
(m1
Pm1 
X
E
j D0 mj
mj  4n

Pr
4n
j D0
2n
4n
D 1=2 :
<

From Corollary 11.12, we see that if we test a few randomly chosen hash functions from the universal family, we will quickly ﬁnd one that uses a reasonable
amount of storage.
Exercises
11.5-1 ?
Suppose that we insert n keys into a hash table of size m using open addressing
and uniform hashing. Let p.n; m/ be the probability that no collisions occur. Show
n.n1/=2m
. (Hint: See equation (3.12).) Argue that when n exthat p.n;
p m/  e
ceeds m, the probability of avoiding collisions goes rapidly to zero.

Problems
11-1 Longest-probe bound for hashing
Suppose that we use an open-addressed hash table of size m to store n  m=2
items.
a. Assuming uniform hashing, show that for i D 1; 2; : : : ; n, the probability is at
most 2k that the ith insertion requires strictly more than k probes.
b. Show that for i D 1; 2; : : : ; n, the probability is O.1=n2 / that the ith insertion
requires more than 2 lg n probes.
Let the random variable Xi denote the number of probes required by the ith insertion. You have shown in part (b) that Pr fXi > 2 lg ng D O.1=n2 /. Let the random
variable X D max1i n Xi denote the maximum number of probes required by
any of the n insertions.
c. Show that Pr fX > 2 lg ng D O.1=n/.
d. Show that the expected length E ŒX  of the longest probe sequence is O.lg n/.

Problems for Chapter 11

283

11-2 Slot-size bound for chaining
Suppose that we have a hash table with n slots, with collisions resolved by chaining, and suppose that n keys are inserted into the table. Each key is equally likely
to be hashed to each slot. Let M be the maximum number of keys in any slot after
all the keys have been inserted. Your mission is to prove an O.lg n= lg lg n/ upper
bound on E ŒM , the expected value of M .
a. Argue that the probability Qk that exactly k keys hash to a particular slot is
given by
!

 k 
1
1 nk n
1
:
Qk D
n
n
k
b. Let Pk be the probability that M D k, that is, the probability that the slot
containing the most keys contains k keys. Show that Pk  nQk .
c. Use Stirling’s approximation, equation (3.18), to show that Qk < e k =k k .
d. Show that there exists a constant c > 1 such that Qk0 < 1=n3 for k0 D
c lg n= lg lg n. Conclude that Pk < 1=n2 for k  k0 D c lg n= lg lg n.
e. Argue that




c lg n
c lg n
c lg n
 n C Pr M 

:
E ŒM   Pr M >
lg lg n
lg lg n lg lg n


Conclude that E ŒM  D O.lg n= lg lg n/.
11-3 Quadratic probing
Suppose that we are given a key k to search for in a hash table with positions
0; 1; : : : ; m  1, and suppose that we have a hash function h mapping the key space
into the set f0; 1; : : : ; m  1g. The search scheme is as follows:
1. Compute the value j D h.k/, and set i D 0.
2. Probe in position j for the desired key k. If you ﬁnd it, or if this position is
empty, terminate the search.
3. Set i D i C 1. If i now equals m, the table is full, so terminate the search.
Otherwise, set j D .i C j / mod m, and return to step 2.
Assume that m is a power of 2.
a. Show that this scheme is an instance of the general “quadratic probing” scheme
by exhibiting the appropriate constants c1 and c2 for equation (11.5).
b. Prove that this algorithm examines every table position in the worst case.

284

Chapter 11 Hash Tables

11-4 Hashing and authentication
Let H be a class of hash functions in which each hash function h 2 H maps the
universe U of keys to f0; 1; : : : ; m  1g. We say that H is k-universal if, for every
ﬁxed sequence of k distinct keys hx .1/ ; x .2/ ; : : : ; x .k/ i and for any h chosen at
random from H , the sequence hh.x .1/ /; h.x .2/ /; : : : ; h.x .k/ /i is equally likely to be
any of the mk sequences of length k with elements drawn from f0; 1; : : : ; m  1g.
a. Show that if the family H of hash functions is 2-universal, then it is universal.
b. Suppose that the universe U is the set of n-tuples of values drawn from
Zp D f0; 1; : : : ; p  1g, where p is prime. Consider an element x D
hx0 ; x1 ; : : : ; xn1 i 2 U . For any n-tuple a D ha0 ; a1 ; : : : ; an1 i 2 U , deﬁne the hash function ha by
!
n1
X
aj xj mod p :
ha .x/ D
j D0

Let H D fha g. Show that H is universal, but not 2-universal. (Hint: Find a key
for which all hash functions in H produce the same value.)
c. Suppose that we modify H slightly from part (b): for any a 2 U and for any
b 2 Zp , deﬁne
h0ab .x/

D

n1
X

!
aj xj C b

mod p

j D0

and H 0 D fh0ab g. Argue that H 0 is 2-universal. (Hint: Consider ﬁxed n-tuples
x 2 U and y 2 U , with xi ¤ yi for some i. What happens to h0ab .x/
and h0ab .y/ as ai and b range over Zp ?)
d. Suppose that Alice and Bob secretly agree on a hash function h from a
2-universal family H of hash functions. Each h 2 H maps from a universe of
keys U to Zp , where p is prime. Later, Alice sends a message m to Bob over the
Internet, where m 2 U . She authenticates this message to Bob by also sending
an authentication tag t D h.m/, and Bob checks that the pair .m; t/ he receives
indeed satisﬁes t D h.m/. Suppose that an adversary intercepts .m; t/ en route
and tries to fool Bob by replacing the pair .m; t/ with a different pair .m0 ; t 0 /.
Argue that the probability that the adversary succeeds in fooling Bob into accepting .m0 ; t 0 / is at most 1=p, no matter how much computing power the adversary has, and even if the adversary knows the family H of hash functions
used.

Notes for Chapter 11

285

Chapter notes
Knuth [211] and Gonnet [145] are excellent references for the analysis of hashing algorithms. Knuth credits H. P. Luhn (1953) for inventing hash tables, along
with the chaining method for resolving collisions. At about the same time, G. M.
Amdahl originated the idea of open addressing.
Carter and Wegman introduced the notion of universal classes of hash functions
in 1979 [58].
Fredman, Komlós, and Szemerédi [112] developed the perfect hashing scheme
for static sets presented in Section 11.5. An extension of their method to dynamic
sets, handling insertions and deletions in amortized expected time O.1/, has been
given by Dietzfelbinger et al. [86].

12

Binary Search Trees

The search tree data structure supports many dynamic-set operations, including
S EARCH, M INIMUM, M AXIMUM, P REDECESSOR, S UCCESSOR, I NSERT, and
D ELETE. Thus, we can use a search tree both as a dictionary and as a priority
queue.
Basic operations on a binary search tree take time proportional to the height of
the tree. For a complete binary tree with n nodes, such operations run in ‚.lg n/
worst-case time. If the tree is a linear chain of n nodes, however, the same operations take ‚.n/ worst-case time. We shall see in Section 12.4 that the expected
height of a randomly built binary search tree is O.lg n/, so that basic dynamic-set
operations on such a tree take ‚.lg n/ time on average.
In practice, we can’t always guarantee that binary search trees are built randomly, but we can design variations of binary search trees with good guaranteed
worst-case performance on basic operations. Chapter 13 presents one such variation, red-black trees, which have height O.lg n/. Chapter 18 introduces B-trees,
which are particularly good for maintaining databases on secondary (disk) storage.
After presenting the basic properties of binary search trees, the following sections show how to walk a binary search tree to print its values in sorted order, how
to search for a value in a binary search tree, how to ﬁnd the minimum or maximum
element, how to ﬁnd the predecessor or successor of an element, and how to insert
into or delete from a binary search tree. The basic mathematical properties of trees
appear in Appendix B.

12.1 What is a binary search tree?
A binary search tree is organized, as the name suggests, in a binary tree, as shown
in Figure 12.1. We can represent such a tree by a linked data structure in which
each node is an object. In addition to a key and satellite data, each node contains
attributes left, right, and p that point to the nodes corresponding to its left child,

12.1 What is a binary search tree?

287

6
5
2

2
5

7
5

7

8
6

8

5
(a)

(b)

Figure 12.1 Binary search trees. For any node x, the keys in the left subtree of x are at most x: key,
and the keys in the right subtree of x are at least x: key. Different binary search trees can represent
the same set of values. The worst-case running time for most search-tree operations is proportional
to the height of the tree. (a) A binary search tree on 6 nodes with height 2. (b) A less efﬁcient binary
search tree with height 4 that contains the same keys.

its right child, and its parent, respectively. If a child or the parent is missing, the
appropriate attribute contains the value NIL. The root node is the only node in the
tree whose parent is NIL.
The keys in a binary search tree are always stored in such a way as to satisfy the
binary-search-tree property:
Let x be a node in a binary search tree. If y is a node in the left subtree
of x, then y:key  x:key. If y is a node in the right subtree of x, then
y:key  x:key.
Thus, in Figure 12.1(a), the key of the root is 6, the keys 2, 5, and 5 in its left
subtree are no larger than 6, and the keys 7 and 8 in its right subtree are no smaller
than 6. The same property holds for every node in the tree. For example, the key 5
in the root’s left child is no smaller than the key 2 in that node’s left subtree and no
larger than the key 5 in the right subtree.
The binary-search-tree property allows us to print out all the keys in a binary
search tree in sorted order by a simple recursive algorithm, called an inorder tree
walk. This algorithm is so named because it prints the key of the root of a subtree
between printing the values in its left subtree and printing those in its right subtree.
(Similarly, a preorder tree walk prints the root before the values in either subtree,
and a postorder tree walk prints the root after the values in its subtrees.) To use
the following procedure to print all the elements in a binary search tree T , we call
I NORDER -T REE -WALK .T:root/.

288

Chapter 12 Binary Search Trees

I NORDER -T REE -WALK .x/
1 if x ¤ NIL
2
I NORDER -T REE -WALK .x:left/
3
print x:key
4
I NORDER -T REE -WALK .x:right/
As an example, the inorder tree walk prints the keys in each of the two binary
search trees from Figure 12.1 in the order 2; 5; 5; 6; 7; 8. The correctness of the
algorithm follows by induction directly from the binary-search-tree property.
It takes ‚.n/ time to walk an n-node binary search tree, since after the initial call, the procedure calls itself recursively exactly twice for each node in the
tree—once for its left child and once for its right child. The following theorem
gives a formal proof that it takes linear time to perform an inorder tree walk.
Theorem 12.1
If x is the root of an n-node subtree, then the call I NORDER -T REE -WALK .x/
takes ‚.n/ time.
Proof Let T .n/ denote the time taken by I NORDER -T REE -WALK when it is
called on the root of an n-node subtree. Since I NORDER -T REE -WALK visits all n
nodes of the subtree, we have T .n/ D .n/. It remains to show that T .n/ D O.n/.
Since I NORDER -T REE -WALK takes a small, constant amount of time on an
empty subtree (for the test x ¤ NIL ), we have T .0/ D c for some constant c > 0.
For n > 0, suppose that I NORDER -T REE -WALK is called on a node x whose
left subtree has k nodes and whose right subtree has n  k  1 nodes. The time to
perform I NORDER -T REE -WALK .x/ is bounded by T .n/  T .k/CT .nk1/Cd
for some constant d > 0 that reﬂects an upper bound on the time to execute the
body of I NORDER -T REE -WALK .x/, exclusive of the time spent in recursive calls.
We use the substitution method to show that T .n/ D O.n/ by proving that
T .n/  .c C d /n C c. For n D 0, we have .c C d /  0 C c D c D T .0/. For n > 0,
we have
T .n/ 
D
D
D

T .k/ C T .n  k  1/ C d
..c C d /k C c/ C ..c C d /.n  k  1/ C c/ C d
.c C d /n C c  .c C d / C c C d
.c C d /n C c ;

which completes the proof.

12.2 Querying a binary search tree

289

Exercises
12.1-1
For the set of f1; 4; 5; 10; 16; 17; 21g of keys, draw binary search trees of heights 2,
3, 4, 5, and 6.
12.1-2
What is the difference between the binary-search-tree property and the min-heap
property (see page 153)? Can the min-heap property be used to print out the keys
of an n-node tree in sorted order in O.n/ time? Show how, or explain why not.
12.1-3
Give a nonrecursive algorithm that performs an inorder tree walk. (Hint: An easy
solution uses a stack as an auxiliary data structure. A more complicated, but elegant, solution uses no stack but assumes that we can test two pointers for equality.)
12.1-4
Give recursive algorithms that perform preorder and postorder tree walks in ‚.n/
time on a tree of n nodes.
12.1-5
Argue that since sorting n elements takes .n lg n/ time in the worst case in
the comparison model, any comparison-based algorithm for constructing a binary
search tree from an arbitrary list of n elements takes .n lg n/ time in the worst
case.

12.2 Querying a binary search tree
We often need to search for a key stored in a binary search tree. Besides the
S EARCH operation, binary search trees can support such queries as M INIMUM,
M AXIMUM, S UCCESSOR, and P REDECESSOR. In this section, we shall examine
these operations and show how to support each one in time O.h/ on any binary
search tree of height h.
Searching
We use the following procedure to search for a node with a given key in a binary
search tree. Given a pointer to the root of the tree and a key k, T REE -S EARCH
returns a pointer to a node with key k if one exists; otherwise, it returns NIL.

290

Chapter 12 Binary Search Trees

15
6
7

3
2

18

4

17

20

13
9

Figure 12.2 Queries on a binary search tree. To search for the key 13 in the tree, we follow the path
15 ! 6 ! 7 ! 13 from the root. The minimum key in the tree is 2, which is found by following
left pointers from the root. The maximum key 20 is found by following right pointers from the root.
The successor of the node with key 15 is the node with key 17, since it is the minimum key in the
right subtree of 15. The node with key 13 has no right subtree, and thus its successor is its lowest
ancestor whose left child is also an ancestor. In this case, the node with key 15 is its successor.

T REE -S EARCH .x; k/
1 if x == NIL or k == x:key
2
return x
3 if k < x:key
4
return T REE -S EARCH .x:left; k/
5 else return T REE -S EARCH .x:right; k/
The procedure begins its search at the root and traces a simple path downward in
the tree, as shown in Figure 12.2. For each node x it encounters, it compares the
key k with x:key. If the two keys are equal, the search terminates. If k is smaller
than x:key, the search continues in the left subtree of x, since the binary-searchtree property implies that k could not be stored in the right subtree. Symmetrically,
if k is larger than x:key, the search continues in the right subtree. The nodes
encountered during the recursion form a simple path downward from the root of
the tree, and thus the running time of T REE -S EARCH is O.h/, where h is the height
of the tree.
We can rewrite this procedure in an iterative fashion by “unrolling” the recursion
into a while loop. On most computers, the iterative version is more efﬁcient.

12.2 Querying a binary search tree

291

I TERATIVE -T REE -S EARCH .x; k/
1 while x ¤ NIL and k ¤ x:key
2
if k < x:key
3
x D x:left
4
else x D x:right
5 return x

Minimum and maximum
We can always ﬁnd an element in a binary search tree whose key is a minimum by
following left child pointers from the root until we encounter a NIL, as shown in
Figure 12.2. The following procedure returns a pointer to the minimum element in
the subtree rooted at a given node x, which we assume to be non-NIL:
T REE -M INIMUM .x/
1 while x:left ¤ NIL
2
x D x:left
3 return x
The binary-search-tree property guarantees that T REE -M INIMUM is correct. If a
node x has no left subtree, then since every key in the right subtree of x is at least as
large as x:key, the minimum key in the subtree rooted at x is x:key. If node x has
a left subtree, then since no key in the right subtree is smaller than x:key and every
key in the left subtree is not larger than x:key, the minimum key in the subtree
rooted at x resides in the subtree rooted at x:left.
The pseudocode for T REE -M AXIMUM is symmetric:
T REE -M AXIMUM .x/
1 while x:right ¤ NIL
2
x D x:right
3 return x
Both of these procedures run in O.h/ time on a tree of height h since, as in T REE S EARCH, the sequence of nodes encountered forms a simple path downward from
the root.
Successor and predecessor
Given a node in a binary search tree, sometimes we need to ﬁnd its successor in
the sorted order determined by an inorder tree walk. If all keys are distinct, the

292

Chapter 12 Binary Search Trees

successor of a node x is the node with the smallest key greater than x:key. The
structure of a binary search tree allows us to determine the successor of a node
without ever comparing keys. The following procedure returns the successor of a
node x in a binary search tree if it exists, and NIL if x has the largest key in the
tree:
T REE -S UCCESSOR .x/
1 if x:right ¤ NIL
2
return T REE -M INIMUM .x:right/
3 y D x:p
4 while y ¤ NIL and x == y:right
5
x Dy
6
y D y:p
7 return y
We break the code for T REE -S UCCESSOR into two cases. If the right subtree
of node x is nonempty, then the successor of x is just the leftmost node in x’s
right subtree, which we ﬁnd in line 2 by calling T REE -M INIMUM .x:right/. For
example, the successor of the node with key 15 in Figure 12.2 is the node with
key 17.
On the other hand, as Exercise 12.2-6 asks you to show, if the right subtree of
node x is empty and x has a successor y, then y is the lowest ancestor of x whose
left child is also an ancestor of x. In Figure 12.2, the successor of the node with
key 13 is the node with key 15. To ﬁnd y, we simply go up the tree from x until we
encounter a node that is the left child of its parent; lines 3–7 of T REE -S UCCESSOR
handle this case.
The running time of T REE -S UCCESSOR on a tree of height h is O.h/, since we
either follow a simple path up the tree or follow a simple path down the tree. The
procedure T REE -P REDECESSOR, which is symmetric to T REE -S UCCESSOR, also
runs in time O.h/.
Even if keys are not distinct, we deﬁne the successor and predecessor of any
node x as the node returned by calls made to T REE -S UCCESSOR .x/ and T REE P REDECESSOR.x/, respectively.
In summary, we have proved the following theorem.
Theorem 12.2
We can implement the dynamic-set operations S EARCH, M INIMUM, M AXIMUM,
S UCCESSOR, and P REDECESSOR so that each one runs in O.h/ time on a binary
search tree of height h.

12.2 Querying a binary search tree

293

Exercises
12.2-1
Suppose that we have numbers between 1 and 1000 in a binary search tree, and we
want to search for the number 363. Which of the following sequences could not be
the sequence of nodes examined?
a. 2, 252, 401, 398, 330, 344, 397, 363.
b. 924, 220, 911, 244, 898, 258, 362, 363.
c. 925, 202, 911, 240, 912, 245, 363.
d. 2, 399, 387, 219, 266, 382, 381, 278, 363.
e. 935, 278, 347, 621, 299, 392, 358, 363.
12.2-2
Write recursive versions of T REE -M INIMUM and T REE -M AXIMUM.
12.2-3
Write the T REE -P REDECESSOR procedure.
12.2-4
Professor Bunyan thinks he has discovered a remarkable property of binary search
trees. Suppose that the search for key k in a binary search tree ends up in a leaf.
Consider three sets: A, the keys to the left of the search path; B, the keys on the
search path; and C , the keys to the right of the search path. Professor Bunyan
claims that any three keys a 2 A, b 2 B, and c 2 C must satisfy a  b  c. Give
a smallest possible counterexample to the professor’s claim.
12.2-5
Show that if a node in a binary search tree has two children, then its successor has
no left child and its predecessor has no right child.
12.2-6
Consider a binary search tree T whose keys are distinct. Show that if the right
subtree of a node x in T is empty and x has a successor y, then y is the lowest
ancestor of x whose left child is also an ancestor of x. (Recall that every node is
its own ancestor.)
12.2-7
An alternative method of performing an inorder tree walk of an n-node binary
search tree ﬁnds the minimum element in the tree by calling T REE -M INIMUM and
then making n  1 calls to T REE -S UCCESSOR. Prove that this algorithm runs
in ‚.n/ time.

294

Chapter 12 Binary Search Trees

12.2-8
Prove that no matter what node we start at in a height-h binary search tree, k
successive calls to T REE -S UCCESSOR take O.k C h/ time.
12.2-9
Let T be a binary search tree whose keys are distinct, let x be a leaf node, and let y
be its parent. Show that y:key is either the smallest key in T larger than x:key or
the largest key in T smaller than x:key.

12.3 Insertion and deletion
The operations of insertion and deletion cause the dynamic set represented by a
binary search tree to change. The data structure must be modiﬁed to reﬂect this
change, but in such a way that the binary-search-tree property continues to hold.
As we shall see, modifying the tree to insert a new element is relatively straightforward, but handling deletion is somewhat more intricate.
Insertion
To insert a new value  into a binary search tree T , we use the procedure T REE I NSERT. The procedure takes a node ´ for which ´:key D , ´:left D NIL,
and ´:right D NIL . It modiﬁes T and some of the attributes of ´ in such a way that
it inserts ´ into an appropriate position in the tree.
T REE -I NSERT .T; ´/
1 y D NIL
2 x D T:root
3 while x ¤ NIL
4
y Dx
5
if ´:key < x:key
6
x D x:left
7
else x D x:right
8 ´:p D y
9 if y == NIL
10
T:root D ´
// tree T was empty
11 elseif ´:key < y:key
12
y:left D ´
13 else y:right D ´

12.3 Insertion and deletion

295

12
5
2

18
9

19

15
13

17

Figure 12.3 Inserting an item with key 13 into a binary search tree. Lightly shaded nodes indicate
the simple path from the root down to the position where the item is inserted. The dashed line
indicates the link in the tree that is added to insert the item.

Figure 12.3 shows how T REE -I NSERT works. Just like the procedures T REE S EARCH and I TERATIVE -T REE -S EARCH, T REE -I NSERT begins at the root of the
tree and the pointer x traces a simple path downward looking for a NIL to replace
with the input item ´. The procedure maintains the trailing pointer y as the parent
of x. After initialization, the while loop in lines 3–7 causes these two pointers
to move down the tree, going left or right depending on the comparison of ´:key
with x:key, until x becomes NIL. This NIL occupies the position where we wish to
place the input item ´. We need the trailing pointer y, because by the time we ﬁnd
the NIL where ´ belongs, the search has proceeded one step beyond the node that
needs to be changed. Lines 8–13 set the pointers that cause ´ to be inserted.
Like the other primitive operations on search trees, the procedure T REE -I NSERT
runs in O.h/ time on a tree of height h.
Deletion
The overall strategy for deleting a node ´ from a binary search tree T has three
basic cases but, as we shall see, one of the cases is a bit tricky.


If ´ has no children, then we simply remove it by modifying its parent to replace ´ with NIL as its child.



If ´ has just one child, then we elevate that child to take ´’s position in the tree
by modifying ´’s parent to replace ´ by ´’s child.



If ´ has two children, then we ﬁnd ´’s successor y—which must be in ´’s right
subtree—and have y take ´’s position in the tree. The rest of ´’s original right
subtree becomes y’s new right subtree, and ´’s left subtree becomes y’s new
left subtree. This case is the tricky one because, as we shall see, it matters
whether y is ´’s right child.

296

Chapter 12 Binary Search Trees

The procedure for deleting a given node ´ from a binary search tree T takes as
arguments pointers to T and ´. It organizes its cases a bit differently from the three
cases outlined previously by considering the four cases shown in Figure 12.4.


If ´ has no left child (part (a) of the ﬁgure), then we replace ´ by its right child,
which may or may not be NIL. When ´’s right child is NIL, this case deals with
the situation in which ´ has no children. When ´’s right child is non-NIL, this
case handles the situation in which ´ has just one child, which is its right child.



If ´ has just one child, which is its left child (part (b) of the ﬁgure), then we
replace ´ by its left child.



Otherwise, ´ has both a left and a right child. We ﬁnd ´’s successor y, which
lies in ´’s right subtree and has no left child (see Exercise 12.2-5). We want to
splice y out of its current location and have it replace ´ in the tree.




If y is ´’s right child (part (c)), then we replace ´ by y, leaving y’s right
child alone.
Otherwise, y lies within ´’s right subtree but is not ´’s right child (part (d)).
In this case, we ﬁrst replace y by its own right child, and then we replace ´
by y.

In order to move subtrees around within the binary search tree, we deﬁne a
subroutine T RANSPLANT, which replaces one subtree as a child of its parent with
another subtree. When T RANSPLANT replaces the subtree rooted at node u with
the subtree rooted at node , node u’s parent becomes node ’s parent, and u’s
parent ends up having  as its appropriate child.
T RANSPLANT .T; u; /
1 if u:p == NIL
2
T:root D 
3 elseif u == u:p:left
4
u:p:left D 
5 else u:p:right D 
6 if  ¤ NIL
7
:p D u:p
Lines 1–2 handle the case in which u is the root of T . Otherwise, u is either a left
child or a right child of its parent. Lines 3–4 take care of updating u:p:left if u
is a left child, and line 5 updates u:p:right if u is a right child. We allow  to be
NIL, and lines 6–7 update :p if  is non-NIL. Note that T RANSPLANT does not
attempt to update :left and :right; doing so, or not doing so, is the responsibility
of T RANSPLANT’s caller.

12.3 Insertion and deletion

297

q

q

(a)

z

r
r

NIL

q

q

(b)

l

z
l

NIL

q

q

(c)

z
l

y
y

l
x

NIL

q

q

(d)

z
l

q
z

r

l

y
NIL

x

y
NIL

x

y
r

l

r

x

x

Figure 12.4 Deleting a node ´ from a binary search tree. Node ´ may be the root, a left child of
node q, or a right child of q. (a) Node ´ has no left child. We replace ´ by its right child r, which
may or may not be NIL . (b) Node ´ has a left child l but no right child. We replace ´ by l. (c) Node ´
has two children; its left child is node l, its right child is its successor y, and y’s right child is node x.
We replace ´ by y, updating y’s left child to become l, but leaving x as y’s right child. (d) Node ´
has two children (left child l and right child r), and its successor y ¤ r lies within the subtree rooted
at r. We replace y by its own right child x, and we set y to be r’s parent. Then, we set y to be q’s
child and the parent of l.

298

Chapter 12 Binary Search Trees

With the T RANSPLANT procedure in hand, here is the procedure that deletes
node ´ from binary search tree T :
T REE -D ELETE .T; ´/
1 if ´:left == NIL
2
T RANSPLANT .T; ´; ´:right/
3 elseif ´:right == NIL
4
T RANSPLANT .T; ´; ´:left/
5 else y D T REE -M INIMUM .´:right/
6
if y:p ¤ ´
7
T RANSPLANT .T; y; y:right/
8
y:right D ´:right
9
y:right:p D y
10
T RANSPLANT .T; ´; y/
11
y:left D ´:left
12
y:left:p D y
The T REE -D ELETE procedure executes the four cases as follows. Lines 1–2
handle the case in which node ´ has no left child, and lines 3–4 handle the case in
which ´ has a left child but no right child. Lines 5–12 deal with the remaining two
cases, in which ´ has two children. Line 5 ﬁnds node y, which is the successor
of ´. Because ´ has a nonempty right subtree, its successor must be the node in
that subtree with the smallest key; hence the call to T REE -M INIMUM .´:right/. As
we noted before, y has no left child. We want to splice y out of its current location,
and it should replace ´ in the tree. If y is ´’s right child, then lines 10–12 replace ´
as a child of its parent by y and replace y’s left child by ´’s left child. If y is
not ´’s left child, lines 7–9 replace y as a child of its parent by y’s right child and
turn ´’s right child into y’s right child, and then lines 10–12 replace ´ as a child of
its parent by y and replace y’s left child by ´’s left child.
Each line of T REE -D ELETE, including the calls to T RANSPLANT, takes constant
time, except for the call to T REE -M INIMUM in line 5. Thus, T REE -D ELETE runs
in O.h/ time on a tree of height h.
In summary, we have proved the following theorem.
Theorem 12.3
We can implement the dynamic-set operations I NSERT and D ELETE so that each
one runs in O.h/ time on a binary search tree of height h.

12.4 Randomly built binary search trees

299

Exercises
12.3-1
Give a recursive version of the T REE -I NSERT procedure.
12.3-2
Suppose that we construct a binary search tree by repeatedly inserting distinct values into the tree. Argue that the number of nodes examined in searching for a
value in the tree is one plus the number of nodes examined when the value was
ﬁrst inserted into the tree.
12.3-3
We can sort a given set of n numbers by ﬁrst building a binary search tree containing these numbers (using T REE -I NSERT repeatedly to insert the numbers one by
one) and then printing the numbers by an inorder tree walk. What are the worstcase and best-case running times for this sorting algorithm?
12.3-4
Is the operation of deletion “commutative” in the sense that deleting x and then y
from a binary search tree leaves the same tree as deleting y and then x? Argue why
it is or give a counterexample.
12.3-5
Suppose that instead of each node x keeping the attribute x:p, pointing to x’s
parent, it keeps x:succ, pointing to x’s successor. Give pseudocode for S EARCH,
I NSERT, and D ELETE on a binary search tree T using this representation. These
procedures should operate in time O.h/, where h is the height of the tree T . (Hint:
You may wish to implement a subroutine that returns the parent of a node.)
12.3-6
When node ´ in T REE -D ELETE has two children, we could choose node y as
its predecessor rather than its successor. What other changes to T REE -D ELETE
would be necessary if we did so? Some have argued that a fair strategy, giving
equal priority to predecessor and successor, yields better empirical performance.
How might T REE -D ELETE be changed to implement such a fair strategy?

? 12.4 Randomly built binary search trees
We have shown that each of the basic operations on a binary search tree runs
in O.h/ time, where h is the height of the tree. The height of a binary search

300

Chapter 12 Binary Search Trees

tree varies, however, as items are inserted and deleted. If, for example, the n items
are inserted in strictly increasing order, the tree will be a chain with height n  1.
On the other hand, Exercise B.5-4 shows that h  blg nc. As with quicksort, we
can show that the behavior of the average case is much closer to the best case than
to the worst case.
Unfortunately, little is known about the average height of a binary search tree
when both insertion and deletion are used to create it. When the tree is created
by insertion alone, the analysis becomes more tractable. Let us therefore deﬁne a
randomly built binary search tree on n keys as one that arises from inserting the
keys in random order into an initially empty tree, where each of the nŠ permutations
of the input keys is equally likely. (Exercise 12.4-3 asks you to show that this notion
is different from assuming that every binary search tree on n keys is equally likely.)
In this section, we shall prove the following theorem.
Theorem 12.4
The expected height of a randomly built binary search tree on n distinct keys is
O.lg n/.
Proof We start by deﬁning three random variables that help measure the height
of a randomly built binary search tree. We denote the height of a randomly built
binary search on n keys by Xn , and we deﬁne the exponential height Yn D 2Xn .
When we build a binary search tree on n keys, we choose one key as that of the
root, and we let Rn denote the random variable that holds this key’s rank within
the set of n keys; that is, Rn holds the position that this key would occupy if the
set of keys were sorted. The value of Rn is equally likely to be any element of the
set f1; 2; : : : ; ng. If Rn D i, then the left subtree of the root is a randomly built
binary search tree on i  1 keys, and the right subtree is a randomly built binary
search tree on n  i keys. Because the height of a binary tree is 1 more than the
larger of the heights of the two subtrees of the root, the exponential height of a
binary tree is twice the larger of the exponential heights of the two subtrees of the
root. If we know that Rn D i, it follows that
Yn D 2  max.Yi 1 ; Yni / :
As base cases, we have that Y1 D 1, because the exponential height of a tree with 1
node is 20 D 1 and, for convenience, we deﬁne Y0 D 0.
Next, deﬁne indicator random variables Zn;1 ; Zn;2 ; : : : ; Zn;n , where
Zn;i D I fRn D ig :
Because Rn is equally likely to be any element of f1; 2; : : : ; ng, it follows that
Pr fRn D ig D 1=n for i D 1; 2; : : : ; n, and hence, by Lemma 5.1, we have
E ŒZn;i  D 1=n ;

(12.1)

12.4 Randomly built binary search trees

301

for i D 1; 2; : : : ; n. Because exactly one value of Zn;i is 1 and all others are 0, we
also have
Yn D

n
X

Zn;i .2  max.Yi 1 ; Yni // :

i D1

We shall show that E ŒYn  is polynomial in n, which will ultimately imply that
E ŒXn  D O.lg n/.
We claim that the indicator random variable Zn;i D I fRn D ig is independent
of the values of Yi 1 and Yni . Having chosen Rn D i, the left subtree (whose
exponential height is Yi 1 ) is randomly built on the i  1 keys whose ranks are
less than i. This subtree is just like any other randomly built binary search tree
on i  1 keys. Other than the number of keys it contains, this subtree’s structure
is not affected at all by the choice of Rn D i, and hence the random variables
Yi 1 and Zn;i are independent. Likewise, the right subtree, whose exponential
height is Yni , is randomly built on the n  i keys whose ranks are greater than i.
Its structure is independent of the value of Rn , and so the random variables Yni
and Zn;i are independent. Hence, we have
" n
#
X
Zn;i .2  max.Yi 1 ; Yni //
E ŒYn  D E
i D1

D
D

n
X
i D1
n
X

E ŒZn;i .2  max.Yi 1 ; Yni //

(by linearity of expectation)

E ŒZn;i  E Œ2  max.Yi 1 ; Yni / (by independence)

i D1
n
X
1
 E Œ2  max.Yi 1 ; Yni /
D
n
i D1

(by equation (12.1))

D

2X
E Œmax.Yi 1 ; Yni /
n i D1

(by equation (C.22))



2X
.E ŒYi 1  C E ŒYni /
n i D1

(by Exercise C.3-4) .

n

n

Since each term E ŒY0  ; E ŒY1  ; : : : ; E ŒYn1  appears twice in the last summation,
once as E ŒYi 1  and once as E ŒYni , we have the recurrence
4X
E ŒYi  :
n i D0
n1

E ŒYn  

(12.2)

302

Chapter 12 Binary Search Trees

Using the substitution method, we shall show that for all positive integers n, the
recurrence (12.2) has the solution
!
1 nC3
:
E ŒYn  
4
3
In doing so, we shall use the identity
!
!
n1
X
i C3
nC3
D
:
3
4
i D0

(12.3)

(Exercise 12.4-1 asks you to prove this identity.)
For the base cases, we note that the bounds 0 D Y0 D E ŒY0   .1=4/ 33 D 1=4
D 1 hold. For the inductive case, we have that
and 1 D Y1 D E ŒY1   .1=4/ 1C3
3
4X
E ŒYi 
n i D0
n1

E ŒYn  

4 X1 i C3
n i D0 4
3
!
n1
1 X i C3
n i D0
3
!
1 nC3
n
4
n1



D
D
D
D
D

!
(by the inductive hypothesis)

(by equation (12.3))

1 .n C 3/Š

n 4Š .n  1/Š
1 .n C 3/Š

4
3Š nŠ!
1 nC3
:
4
3

We have bounded E ŒYn , but our ultimate goal is to bound E ŒXn . As Exercise 12.4-4 asks you to show, the function f .x/ D 2x is convex (see page 1199).
Therefore, we can employ Jensen’s inequality (C.26), which says that


2EŒXn   E 2Xn
D E ŒYn  ;
as follows:
2EŒXn 



1 nC3
4
3

!

Problems for Chapter 12

303

1 .n C 3/.n C 2/.n C 1/

4
6
n3 C 6n2 C 11n C 6
:
D
24
Taking logarithms of both sides gives E ŒXn  D O.lg n/.
D

Exercises
12.4-1
Prove equation (12.3).
12.4-2
Describe a binary search tree on n nodes such that the average depth of a node in
the tree is ‚.lg n/ but the height of the tree is !.lg n/. Give an asymptotic upper
bound on the height of an n-node binary search tree in which the average depth of
a node is ‚.lg n/.
12.4-3
Show that the notion of a randomly chosen binary search tree on n keys, where
each binary search tree of n keys is equally likely to be chosen, is different from
the notion of a randomly built binary search tree given in this section. (Hint: List
the possibilities when n D 3.)
12.4-4
Show that the function f .x/ D 2x is convex.
12.4-5 ?
Consider R ANDOMIZED -Q UICKSORT operating on a sequence of n distinct input
numbers. Prove that for any constant k > 0, all but O.1=nk / of the nŠ input
permutations yield an O.n lg n/ running time.

Problems
12-1 Binary search trees with equal keys
Equal keys pose a problem for the implementation of binary search trees.
a. What is the asymptotic performance of T REE -I NSERT when used to insert n
items with identical keys into an initially empty binary search tree?
We propose to improve T REE -I NSERT by testing before line 5 to determine whether
´:key D x:key and by testing before line 11 to determine whether ´:key D y:key.

304

Chapter 12 Binary Search Trees

If equality holds, we implement one of the following strategies. For each strategy,
ﬁnd the asymptotic performance of inserting n items with identical keys into an
initially empty binary search tree. (The strategies are described for line 5, in which
we compare the keys of ´ and x. Substitute y for x to arrive at the strategies for
line 11.)
b. Keep a boolean ﬂag x:b at node x, and set x to either x:left or x:right based
on the value of x:b, which alternates between FALSE and TRUE each time we
visit x while inserting a node with the same key as x.
c. Keep a list of nodes with equal keys at x, and insert ´ into the list.
d. Randomly set x to either x:left or x:right. (Give the worst-case performance
and informally derive the expected running time.)
12-2 Radix trees
Given two strings a D a0 a1 : : : ap and b D b0 b1 : : : bq , where each ai and each bj
is in some ordered set of characters, we say that string a is lexicographically less
than string b if either
1. there exists an integer j , where 0  j  min.p; q/, such that ai D bi for all
i D 0; 1; : : : ; j  1 and aj < bj , or
2. p < q and ai D bi for all i D 0; 1; : : : ; p.
For example, if a and b are bit strings, then 10100 < 10110 by rule 1 (letting
j D 3) and 10100 < 101000 by rule 2. This ordering is similar to that used in
English-language dictionaries.
The radix tree data structure shown in Figure 12.5 stores the bit strings 1011,
10, 011, 100, and 0. When searching for a key a D a0 a1 : : : ap , we go left at a
node of depth i if ai D 0 and right if ai D 1. Let S be a set of distinct bit strings
whose lengths sum to n. Show how to use a radix tree to sort S lexicographically
in ‚.n/ time. For the example in Figure 12.5, the output of the sort should be the
sequence 0, 011, 10, 100, 1011.
12-3 Average node depth in a randomly built binary search tree
In this problem, we prove that the average depth of a node in a randomly built
binary search tree with n nodes is O.lg n/. Although this result is weaker than
that of Theorem 12.4, the technique we shall use reveals a surprising similarity
between the building of a binary search tree and the execution of R ANDOMIZED Q UICKSORT from Section 7.3.
We deﬁne the total path length P .T / of a binary tree T as the sum, over all
nodes x in T , of the depth of node x, which we denote by d.x; T /.

Problems for Chapter 12

305

0

1

0
1

0
10
1
011

0
100

1
1
1011

Figure 12.5 A radix tree storing the bit strings 1011, 10, 011, 100, and 0. We can determine each
node’s key by traversing the simple path from the root to that node. There is no need, therefore, to
store the keys in the nodes; the keys appear here for illustrative purposes only. Nodes are heavily
shaded if the keys corresponding to them are not in the tree; such nodes are present only to establish
a path to other nodes.

a. Argue that the average depth of a node in T is
1
1X
d.x; T / D P .T / :
n x2T
n
Thus, we wish to show that the expected value of P .T / is O.n lg n/.
b. Let TL and TR denote the left and right subtrees of tree T , respectively. Argue
that if T has n nodes, then
P .T / D P .TL / C P .TR / C n  1 :
c. Let P .n/ denote the average total path length of a randomly built binary search
tree with n nodes. Show that
1X
.P .i/ C P .n  i  1/ C n  1/ :
P .n/ D
n i D0
n1

d. Show how to rewrite P .n/ as
2X
P .k/ C ‚.n/ :
P .n/ D
n
n1

kD1

e. Recalling the alternative analysis of the randomized version of quicksort given
in Problem 7-3, conclude that P .n/ D O.n lg n/.

306

Chapter 12 Binary Search Trees

At each recursive invocation of quicksort, we choose a random pivot element to
partition the set of elements being sorted. Each node of a binary search tree partitions the set of elements that fall into the subtree rooted at that node.
f. Describe an implementation of quicksort in which the comparisons to sort a set
of elements are exactly the same as the comparisons to insert the elements into
a binary search tree. (The order in which comparisons are made may differ, but
the same comparisons must occur.)
12-4 Number of different binary trees
Let bn denote the number of different binary trees with n nodes. In this problem,
you will ﬁnd a formula for bn , as well as an asymptotic estimate.
a. Show that b0 D 1 and that, for n  1,
bn D

n1
X

bk bn1k :

kD0

b. Referring to Problem 4-4 for the deﬁnition of a generating function, let B.x/
be the generating function
B.x/ D

1
X

bn x n :

nD0

Show that B.x/ D xB.x/2 C 1, and hence one way to express B.x/ in closed
form is
B.x/ D

p
1
1  1  4x :
2x

The Taylor expansion of f .x/ around the point x D a is given by
f .x/ D

1
X
f .k/ .a/
kD0

kŠ

.x  a/k ;

where f .k/ .x/ is the kth derivative of f evaluated at x.
c. Show that
2n
1
bn D
nC1 n

!

Notes for Chapter 12

307

p
(the nth Catalan number) by using the Taylor expansion of 1  4x around
x D 0. (If you wish, instead of using the Taylor expansion, you may use
the generalization of the binomial expansion (C.4) to nonintegral exponents n,
where for any real number n and for any integer k, we interpret kn to be
n.n  1/    .n  k C 1/=kŠ if k  0, and 0 otherwise.)
d. Show that
bn D p

4n
.1 C O.1=n// :
n3=2

Chapter notes
Knuth [211] contains a good discussion of simple binary search trees as well as
many variations. Binary search trees seem to have been independently discovered
by a number of people in the late 1950s. Radix trees are often called “tries,” which
comes from the middle letters in the word retrieval. Knuth [211] also discusses
them.
Many texts, including the ﬁrst two editions of this book, have a somewhat simpler method of deleting a node from a binary search tree when both of its children
are present. Instead of replacing node ´ by its successor y, we delete node y but
copy its key and satellite data into node ´. The downside of this approach is that
the node actually deleted might not be the node passed to the delete procedure. If
other components of a program maintain pointers to nodes in the tree, they could
mistakenly end up with “stale” pointers to nodes that have been deleted. Although
the deletion method presented in this edition of this book is a bit more complicated,
it guarantees that a call to delete node ´ deletes node ´ and only node ´.
Section 15.5 will show how to construct an optimal binary search tree when
we know the search frequencies before constructing the tree. That is, given the
frequencies of searching for each key and the frequencies of searching for values
that fall between keys in the tree, we construct a binary search tree for which a
set of searches that follows these frequencies examines the minimum number of
nodes.
The proof in Section 12.4 that bounds the expected height of a randomly built
binary search tree is due to Aslam [24]. Martı́nez and Roura [243] give randomized
algorithms for insertion into and deletion from binary search trees in which the
result of either operation is a random binary search tree. Their deﬁnition of a
random binary search tree differs—only slightly—from that of a randomly built
binary search tree in this chapter, however.

13

Red-Black Trees

Chapter 12 showed that a binary search tree of height h can support any of the basic
dynamic-set operations—such as S EARCH, P REDECESSOR, S UCCESSOR, M INI MUM , M AXIMUM , I NSERT, and D ELETE—in O.h/ time. Thus, the set operations
are fast if the height of the search tree is small. If its height is large, however, the
set operations may run no faster than with a linked list. Red-black trees are one
of many search-tree schemes that are “balanced” in order to guarantee that basic
dynamic-set operations take O.lg n/ time in the worst case.

13.1 Properties of red-black trees
A red-black tree is a binary search tree with one extra bit of storage per node: its
color, which can be either RED or BLACK. By constraining the node colors on any
simple path from the root to a leaf, red-black trees ensure that no such path is more
than twice as long as any other, so that the tree is approximately balanced.
Each node of the tree now contains the attributes color, key, left, right, and p. If
a child or the parent of a node does not exist, the corresponding pointer attribute
of the node contains the value NIL. We shall regard these NILs as being pointers to
leaves (external nodes) of the binary search tree and the normal, key-bearing nodes
as being internal nodes of the tree.
A red-black tree is a binary tree that satisﬁes the following red-black properties:
1. Every node is either red or black.
2. The root is black.
3. Every leaf (NIL) is black.
4. If a node is red, then both its children are black.
5. For each node, all simple paths from the node to descendant leaves contain the
same number of black nodes.

13.1 Properties of red-black trees

309

Figure 13.1(a) shows an example of a red-black tree.
As a matter of convenience in dealing with boundary conditions in red-black
tree code, we use a single sentinel to represent NIL (see page 238). For a red-black
tree T , the sentinel T:nil is an object with the same attributes as an ordinary node
in the tree. Its color attribute is BLACK, and its other attributes—p, left, right,
and key—can take on arbitrary values. As Figure 13.1(b) shows, all pointers to NIL
are replaced by pointers to the sentinel T:nil.
We use the sentinel so that we can treat a NIL child of a node x as an ordinary
node whose parent is x. Although we instead could add a distinct sentinel node
for each NIL in the tree, so that the parent of each NIL is well deﬁned, that approach would waste space. Instead, we use the one sentinel T:nil to represent all
the NILs—all leaves and the root’s parent. The values of the attributes p, left, right,
and key of the sentinel are immaterial, although we may set them during the course
of a procedure for our convenience.
We generally conﬁne our interest to the internal nodes of a red-black tree, since
they hold the key values. In the remainder of this chapter, we omit the leaves when
we draw red-black trees, as shown in Figure 13.1(c).
We call the number of black nodes on any simple path from, but not including, a
node x down to a leaf the black-height of the node, denoted bh.x/. By property 5,
the notion of black-height is well deﬁned, since all descending simple paths from
the node have the same number of black nodes. We deﬁne the black-height of a
red-black tree to be the black-height of its root.
The following lemma shows why red-black trees make good search trees.
Lemma 13.1
A red-black tree with n internal nodes has height at most 2 lg.n C 1/.
Proof We start by showing that the subtree rooted at any node x contains at least
2bh.x/  1 internal nodes. We prove this claim by induction on the height of x. If
the height of x is 0, then x must be a leaf (T:nil), and the subtree rooted at x indeed
contains at least 2bh.x/  1 D 20  1 D 0 internal nodes. For the inductive step,
consider a node x that has positive height and is an internal node with two children.
Each child has a black-height of either bh.x/ or bh.x/  1, depending on whether
its color is red or black, respectively. Since the height of a child of x is less than
the height of x itself, we can apply the inductive hypothesis to conclude that each
child has at least 2bh.x/1  1 internal nodes. Thus, the subtree rooted at x contains
at least .2bh.x/1  1/ C .2bh.x/1  1/ C 1 D 2bh.x/  1 internal nodes, which proves
the claim.
To complete the proof of the lemma, let h be the height of the tree. According
to property 4, at least half the nodes on any simple path from the root to a leaf, not

310

Chapter 13 Red-Black Trees

3
3
2
2
1
1

7

3

NIL

1
NIL

12

1

NIL

21

2
1

NIL

41

17

14

10

16

15

NIL

26

1

NIL

19

NIL

NIL

2
1

1

20

NIL

23

NIL

1

NIL

30

1

28

NIL

NIL

NIL

1

1

38

35

1

NIL

NIL

2

NIL

47

NIL

NIL

39

NIL

NIL

(a)

26
41

17
14

21
16

10
7

12

19

15

30
23

47

28

38

20

35

39

3

T:nil
(b)
26
17

41

14

21

10
7
3

16
12

15

19

30
23

47

28

20

38
35

39

(c)

Figure 13.1 A red-black tree with black nodes darkened and red nodes shaded. Every node in a
red-black tree is either red or black, the children of a red node are both black, and every simple path
from a node to a descendant leaf contains the same number of black nodes. (a) Every leaf, shown
as a NIL , is black. Each non-NIL node is marked with its black-height; NIL s have black-height 0.
(b) The same red-black tree but with each NIL replaced by the single sentinel T: nil, which is always
black, and with black-heights omitted. The root’s parent is also the sentinel. (c) The same red-black
tree but with leaves and the root’s parent omitted entirely. We shall use this drawing style in the
remainder of this chapter.

13.1 Properties of red-black trees

311

including the root, must be black. Consequently, the black-height of the root must
be at least h=2; thus,
n  2h=2  1 :
Moving the 1 to the left-hand side and taking logarithms on both sides yields
lg.n C 1/  h=2, or h  2 lg.n C 1/.
As an immediate consequence of this lemma, we can implement the dynamic-set
operations S EARCH, M INIMUM, M AXIMUM, S UCCESSOR, and P REDECESSOR
in O.lg n/ time on red-black trees, since each can run in O.h/ time on a binary
search tree of height h (as shown in Chapter 12) and any red-black tree on n nodes
is a binary search tree with height O.lg n/. (Of course, references to NIL in the
algorithms of Chapter 12 would have to be replaced by T:nil.) Although the algorithms T REE -I NSERT and T REE -D ELETE from Chapter 12 run in O.lg n/ time
when given a red-black tree as input, they do not directly support the dynamic-set
operations I NSERT and D ELETE, since they do not guarantee that the modiﬁed binary search tree will be a red-black tree. We shall see in Sections 13.3 and 13.4,
however, how to support these two operations in O.lg n/ time.
Exercises
13.1-1
In the style of Figure 13.1(a), draw the complete binary search tree of height 3 on
the keys f1; 2; : : : ; 15g. Add the NIL leaves and color the nodes in three different
ways such that the black-heights of the resulting red-black trees are 2, 3, and 4.
13.1-2
Draw the red-black tree that results after T REE -I NSERT is called on the tree in
Figure 13.1 with key 36. If the inserted node is colored red, is the resulting tree a
red-black tree? What if it is colored black?
13.1-3
Let us deﬁne a relaxed red-black tree as a binary search tree that satisﬁes redblack properties 1, 3, 4, and 5. In other words, the root may be either red or black.
Consider a relaxed red-black tree T whose root is red. If we color the root of T
black but make no other changes to T , is the resulting tree a red-black tree?
13.1-4
Suppose that we “absorb” every red node in a red-black tree into its black parent,
so that the children of the red node become children of the black parent. (Ignore
what happens to the keys.) What are the possible degrees of a black node after all

312

Chapter 13 Red-Black Trees

its red children are absorbed? What can you say about the depths of the leaves of
the resulting tree?
13.1-5
Show that the longest simple path from a node x in a red-black tree to a descendant
leaf has length at most twice that of the shortest simple path from node x to a
descendant leaf.
13.1-6
What is the largest possible number of internal nodes in a red-black tree with blackheight k? What is the smallest possible number?
13.1-7
Describe a red-black tree on n keys that realizes the largest possible ratio of red internal nodes to black internal nodes. What is this ratio? What tree has the smallest
possible ratio, and what is the ratio?

13.2 Rotations
The search-tree operations T REE -I NSERT and T REE -D ELETE, when run on a redblack tree with n keys, take O.lg n/ time. Because they modify the tree, the result
may violate the red-black properties enumerated in Section 13.1. To restore these
properties, we must change the colors of some of the nodes in the tree and also
change the pointer structure.
We change the pointer structure through rotation, which is a local operation in
a search tree that preserves the binary-search-tree property. Figure 13.2 shows the
two kinds of rotations: left rotations and right rotations. When we do a left rotation
on a node x, we assume that its right child y is not T:nil; x may be any node in
the tree whose right child is not T:nil. The left rotation “pivots” around the link
from x to y. It makes y the new root of the subtree, with x as y’s left child and y’s
left child as x’s right child.
The pseudocode for L EFT-ROTATE assumes that x:right ¤ T:nil and that the
root’s parent is T:nil.

13.2 Rotations

313

LEFT-ROTATE(T, x)
y

γ

x

α

x

β

RIGHT-ROTATE(T, y)

α

y

β

γ

Figure 13.2 The rotation operations on a binary search tree. The operation L EFT-ROTATE.T; x/
transforms the conﬁguration of the two nodes on the right into the conﬁguration on the left by changing a constant number of pointers. The inverse operation R IGHT-ROTATE.T; y/ transforms the conﬁguration on the left into the conﬁguration on the right. The letters ˛, ˇ, and represent arbitrary
subtrees. A rotation operation preserves the binary-search-tree property: the keys in ˛ precede x: key,
which precedes the keys in ˇ, which precede y: key, which precedes the keys in .

L EFT-ROTATE .T; x/
1 y D x:right
2 x:right D y:left
3 if y:left ¤ T:nil
4
y:left:p D x
5 y:p D x:p
6 if x:p == T:nil
7
T:root D y
8 elseif x == x:p:left
9
x:p:left D y
10 else x:p:right D y
11 y:left D x
12 x:p D y

// set y
// turn y’s left subtree into x’s right subtree

// link x’s parent to y

// put x on y’s left

Figure 13.3 shows an example of how L EFT-ROTATE modiﬁes a binary search
tree. The code for R IGHT-ROTATE is symmetric. Both L EFT-ROTATE and R IGHTROTATE run in O.1/ time. Only pointers are changed by a rotation; all other
attributes in a node remain the same.
Exercises
13.2-1
Write pseudocode for R IGHT-ROTATE.
13.2-2
Argue that in every n-node binary search tree, there are exactly n  1 possible
rotations.

314

Chapter 13 Red-Black Trees

7
4
3

11 x
6

9

18 y

2

14
12

LEFT-ROTATE(T, x)

19
17

22
20

7
4
3
2

18 y
6

x 11
9

19
14

12

22
17

20

Figure 13.3 An example of how the procedure L EFT-ROTATE.T; x/ modiﬁes a binary search tree.
Inorder tree walks of the input tree and the modiﬁed tree produce the same listing of key values.

13.2-3
Let a, b, and c be arbitrary nodes in subtrees ˛, ˇ, and , respectively, in the left
tree of Figure 13.2. How do the depths of a, b, and c change when a left rotation
is performed on node x in the ﬁgure?
13.2-4
Show that any arbitrary n-node binary search tree can be transformed into any other
arbitrary n-node binary search tree using O.n/ rotations. (Hint: First show that at
most n  1 right rotations sufﬁce to transform the tree into a right-going chain.)
13.2-5 ?
We say that a binary search tree T1 can be right-converted to binary search tree T2
if it is possible to obtain T2 from T1 via a series of calls to R IGHT-ROTATE. Give
an example of two trees T1 and T2 such that T1 cannot be right-converted to T2 .
Then, show that if a tree T1 can be right-converted to T2 , it can be right-converted
using O.n2 / calls to R IGHT-ROTATE.

13.3 Insertion

315

13.3 Insertion
We can insert a node into an n-node red-black tree in O.lg n/ time. To do so, we
use a slightly modiﬁed version of the T REE -I NSERT procedure (Section 12.3) to
insert node ´ into the tree T as if it were an ordinary binary search tree, and then we
color ´ red. (Exercise 13.3-1 asks you to explain why we choose to make node ´
red rather than black.) To guarantee that the red-black properties are preserved, we
then call an auxiliary procedure RB-I NSERT-F IXUP to recolor nodes and perform
rotations. The call RB-I NSERT .T; ´/ inserts node ´, whose key is assumed to have
already been ﬁlled in, into the red-black tree T .
RB-I NSERT .T; ´/
1 y D T:nil
2 x D T:root
3 while x ¤ T:nil
4
y Dx
5
if ´:key < x:key
6
x D x:left
7
else x D x:right
8 ´:p D y
9 if y == T:nil
10
T:root D ´
11 elseif ´:key < y:key
12
y:left D ´
13 else y:right D ´
14 ´:left D T:nil
15 ´:right D T:nil
16 ´:color D RED
17 RB-I NSERT-F IXUP .T; ´/
The procedures T REE -I NSERT and RB-I NSERT differ in four ways. First, all
instances of NIL in T REE -I NSERT are replaced by T:nil. Second, we set ´:left
and ´:right to T:nil in lines 14–15 of RB-I NSERT, in order to maintain the
proper tree structure. Third, we color ´ red in line 16. Fourth, because coloring ´ red may cause a violation of one of the red-black properties, we call
RB-I NSERT-F IXUP .T; ´/ in line 17 of RB-I NSERT to restore the red-black properties.

316

Chapter 13 Red-Black Trees

RB-I NSERT-F IXUP .T; ´/
1 while ´:p:color == RED
2
if ´:p == ´:p:p:left
3
y D ´:p:p:right
4
if y:color == RED
5
´:p:color D BLACK
6
y:color D BLACK
7
´:p:p:color D RED
8
´ D ´:p:p
9
else if ´ == ´:p:right
10
´ D ´:p
11
L EFT-ROTATE .T; ´/
12
´:p:color D BLACK
13
´:p:p:color D RED
14
R IGHT-ROTATE .T; ´:p:p/
15
else (same as then clause
with “right” and “left” exchanged)
16 T:root:color D BLACK

// case 1
// case 1
// case 1
// case 1
// case 2
// case 2
// case 3
// case 3
// case 3

To understand how RB-I NSERT-F IXUP works, we shall break our examination
of the code into three major steps. First, we shall determine what violations of
the red-black properties are introduced in RB-I NSERT when node ´ is inserted
and colored red. Second, we shall examine the overall goal of the while loop in
lines 1–15. Finally, we shall explore each of the three cases1 within the while
loop’s body and see how they accomplish the goal. Figure 13.4 shows how RBI NSERT-F IXUP operates on a sample red-black tree.
Which of the red-black properties might be violated upon the call to RBI NSERT-F IXUP? Property 1 certainly continues to hold, as does property 3, since
both children of the newly inserted red node are the sentinel T:nil. Property 5,
which says that the number of black nodes is the same on every simple path from
a given node, is satisﬁed as well, because node ´ replaces the (black) sentinel, and
node ´ is red with sentinel children. Thus, the only properties that might be violated are property 2, which requires the root to be black, and property 4, which
says that a red node cannot have a red child. Both possible violations are due to ´
being colored red. Property 2 is violated if ´ is the root, and property 4 is violated
if ´’s parent is red. Figure 13.4(a) shows a violation of property 4 after the node ´
has been inserted.
1 Case

2 falls through into case 3, and so these two cases are not mutually exclusive.

13.3 Insertion

317

11
2
(a)

14

1

7

15

5
z

8 y

4

Case 1

11
2
(b)

14 y

1

7
5

z

15
8

4

Case 2

11
7
(c)

z

14 y

2

8

1

15

5
Case 3
4
7
z

(d)

2

11

1

5
4

8

14
15

Figure 13.4 The operation of RB-I NSERT-F IXUP. (a) A node ´ after insertion. Because both ´
and its parent ´: p are red, a violation of property 4 occurs. Since ´’s uncle y is red, case 1 in the
code applies. We recolor nodes and move the pointer ´ up the tree, resulting in the tree shown in (b).
Once again, ´ and its parent are both red, but ´’s uncle y is black. Since ´ is the right child of ´: p,
case 2 applies. We perform a left rotation, and the tree that results is shown in (c). Now, ´ is the left
child of its parent, and case 3 applies. Recoloring and right rotation yield the tree in (d), which is a
legal red-black tree.

318

Chapter 13 Red-Black Trees

The while loop in lines 1–15 maintains the following three-part invariant at the
start of each iteration of the loop:
a. Node ´ is red.
b. If ´:p is the root, then ´:p is black.
c. If the tree violates any of the red-black properties, then it violates at most
one of them, and the violation is of either property 2 or property 4. If the
tree violates property 2, it is because ´ is the root and is red. If the tree
violates property 4, it is because both ´ and ´:p are red.
Part (c), which deals with violations of red-black properties, is more central to
showing that RB-I NSERT-F IXUP restores the red-black properties than parts (a)
and (b), which we use along the way to understand situations in the code. Because
we’ll be focusing on node ´ and nodes near it in the tree, it helps to know from
part (a) that ´ is red. We shall use part (b) to show that the node ´:p:p exists when
we reference it in lines 2, 3, 7, 8, 13, and 14.
Recall that we need to show that a loop invariant is true prior to the ﬁrst iteration of the loop, that each iteration maintains the loop invariant, and that the loop
invariant gives us a useful property at loop termination.
We start with the initialization and termination arguments. Then, as we examine how the body of the loop works in more detail, we shall argue that the loop
maintains the invariant upon each iteration. Along the way, we shall also demonstrate that each iteration of the loop has two possible outcomes: either the pointer ´
moves up the tree, or we perform some rotations and then the loop terminates.
Initialization: Prior to the ﬁrst iteration of the loop, we started with a red-black
tree with no violations, and we added a red node ´. We show that each part of
the invariant holds at the time RB-I NSERT-F IXUP is called:
a. When RB-I NSERT-F IXUP is called, ´ is the red node that was added.
b. If ´:p is the root, then ´:p started out black and did not change prior to the
call of RB-I NSERT-F IXUP.
c. We have already seen that properties 1, 3, and 5 hold when RB-I NSERTF IXUP is called.
If the tree violates property 2, then the red root must be the newly added
node ´, which is the only internal node in the tree. Because the parent and
both children of ´ are the sentinel, which is black, the tree does not also
violate property 4. Thus, this violation of property 2 is the only violation of
red-black properties in the entire tree.
If the tree violates property 4, then, because the children of node ´ are black
sentinels and the tree had no other violations prior to ´ being added, the

13.3 Insertion

319

violation must be because both ´ and ´:p are red. Moreover, the tree violates
no other red-black properties.
Termination: When the loop terminates, it does so because ´:p is black. (If ´ is
the root, then ´:p is the sentinel T:nil, which is black.) Thus, the tree does not
violate property 4 at loop termination. By the loop invariant, the only property
that might fail to hold is property 2. Line 16 restores this property, too, so that
when RB-I NSERT-F IXUP terminates, all the red-black properties hold.
Maintenance: We actually need to consider six cases in the while loop, but three
of them are symmetric to the other three, depending on whether line 2 determines ´’s parent ´:p to be a left child or a right child of ´’s grandparent ´:p:p.
We have given the code only for the situation in which ´:p is a left child. The
node ´:p:p exists, since by part (b) of the loop invariant, if ´:p is the root,
then ´:p is black. Since we enter a loop iteration only if ´:p is red, we know
that ´:p cannot be the root. Hence, ´:p:p exists.
We distinguish case 1 from cases 2 and 3 by the color of ´’s parent’s sibling,
or “uncle.” Line 3 makes y point to ´’s uncle ´:p:p:right, and line 4 tests y’s
color. If y is red, then we execute case 1. Otherwise, control passes to cases 2
and 3. In all three cases, ´’s grandparent ´:p:p is black, since its parent ´:p is
red, and property 4 is violated only between ´ and ´:p.
Case 1: ´’s uncle y is red
Figure 13.5 shows the situation for case 1 (lines 5–8), which occurs when
both ´:p and y are red. Because ´:p:p is black, we can color both ´:p and y
black, thereby ﬁxing the problem of ´ and ´:p both being red, and we can
color ´:p:p red, thereby maintaining property 5. We then repeat the while loop
with ´:p:p as the new node ´. The pointer ´ moves up two levels in the tree.
Now, we show that case 1 maintains the loop invariant at the start of the next
iteration. We use ´ to denote node ´ in the current iteration, and ´0 D ´:p:p
to denote the node that will be called node ´ at the test in line 1 upon the next
iteration.
a. Because this iteration colors ´:p:p red, node ´0 is red at the start of the next
iteration.
b. The node ´0 :p is ´:p:p:p in this iteration, and the color of this node does not
change. If this node is the root, it was black prior to this iteration, and it
remains black at the start of the next iteration.
c. We have already argued that case 1 maintains property 5, and it does not
introduce a violation of properties 1 or 3.

320

Chapter 13 Red-Black Trees

new z

C
(a)

A

D y

α

δ

B z

β

A

ε

D

α

γ

β

α

γ

A

β

δ

C

B

D y

ε
α

D

γ

A

ε

γ

new z

B
z

δ

B

C
(b)

C

δ

ε

β

Figure 13.5 Case 1 of the procedure RB-I NSERT-F IXUP. Property 4 is violated, since ´ and its
parent ´: p are both red. We take the same action whether (a) ´ is a right child or (b) ´ is a left
child. Each of the subtrees ˛, ˇ, , ı, and " has a black root, and each has the same black-height.
The code for case 1 changes the colors of some nodes, preserving property 5: all downward simple
paths from a node to a leaf have the same number of blacks. The while loop continues with node ´’s
grandparent ´: p: p as the new ´. Any violation of property 4 can now occur only between the new ´,
which is red, and its parent, if it is red as well.

If node ´0 is the root at the start of the next iteration, then case 1 corrected
the lone violation of property 4 in this iteration. Since ´0 is red and it is the
root, property 2 becomes the only one that is violated, and this violation is
due to ´0 .
If node ´0 is not the root at the start of the next iteration, then case 1 has
not created a violation of property 2. Case 1 corrected the lone violation
of property 4 that existed at the start of this iteration. It then made ´0 red
and left ´0 :p alone. If ´0 :p was black, there is no violation of property 4.
If ´0 :p was red, coloring ´0 red created one violation of property 4 between ´0
and ´0 :p.
Case 2: ´’s uncle y is black and ´ is a right child
Case 3: ´’s uncle y is black and ´ is a left child
In cases 2 and 3, the color of ´’s uncle y is black. We distinguish the two cases
according to whether ´ is a right or left child of ´:p. Lines 10–11 constitute
case 2, which is shown in Figure 13.6 together with case 3. In case 2, node ´
is a right child of its parent. We immediately use a left rotation to transform
the situation into case 3 (lines 12–14), in which node ´ is a left child. Because

13.3 Insertion

321

C

C

δ y

A

α

z

γ

α

β
Case 2

δ y

B

B z

γ

A

B
z

α

A

C

β

γ

δ

β
Case 3

Figure 13.6 Cases 2 and 3 of the procedure RB-I NSERT-F IXUP. As in case 1, property 4 is violated
in either case 2 or case 3 because ´ and its parent ´: p are both red. Each of the subtrees ˛, ˇ, , and ı
has a black root (˛, ˇ, and from property 4, and ı because otherwise we would be in case 1), and
each has the same black-height. We transform case 2 into case 3 by a left rotation, which preserves
property 5: all downward simple paths from a node to a leaf have the same number of blacks. Case 3
causes some color changes and a right rotation, which also preserve property 5. The while loop then
terminates, because property 4 is satisﬁed: there are no longer two red nodes in a row.

both ´ and ´:p are red, the rotation affects neither the black-height of nodes
nor property 5. Whether we enter case 3 directly or through case 2, ´’s uncle y
is black, since otherwise we would have executed case 1. Additionally, the
node ´:p:p exists, since we have argued that this node existed at the time that
lines 2 and 3 were executed, and after moving ´ up one level in line 10 and then
down one level in line 11, the identity of ´:p:p remains unchanged. In case 3,
we execute some color changes and a right rotation, which preserve property 5,
and then, since we no longer have two red nodes in a row, we are done. The
while loop does not iterate another time, since ´:p is now black.
We now show that cases 2 and 3 maintain the loop invariant. (As we have just
argued, ´:p will be black upon the next test in line 1, and the loop body will not
execute again.)
a. Case 2 makes ´ point to ´:p, which is red. No further change to ´ or its color
occurs in cases 2 and 3.
b. Case 3 makes ´:p black, so that if ´:p is the root at the start of the next
iteration, it is black.
c. As in case 1, properties 1, 3, and 5 are maintained in cases 2 and 3.
Since node ´ is not the root in cases 2 and 3, we know that there is no violation of property 2. Cases 2 and 3 do not introduce a violation of property 2,
since the only node that is made red becomes a child of a black node by the
rotation in case 3.
Cases 2 and 3 correct the lone violation of property 4, and they do not introduce another violation.

322

Chapter 13 Red-Black Trees

Having shown that each iteration of the loop maintains the invariant, we have
shown that RB-I NSERT-F IXUP correctly restores the red-black properties.
Analysis
What is the running time of RB-I NSERT? Since the height of a red-black tree on n
nodes is O.lg n/, lines 1–16 of RB-I NSERT take O.lg n/ time. In RB-I NSERTF IXUP, the while loop repeats only if case 1 occurs, and then the pointer ´ moves
two levels up the tree. The total number of times the while loop can be executed
is therefore O.lg n/. Thus, RB-I NSERT takes a total of O.lg n/ time. Moreover, it
never performs more than two rotations, since the while loop terminates if case 2
or case 3 is executed.
Exercises
13.3-1
In line 16 of RB-I NSERT, we set the color of the newly inserted node ´ to red.
Observe that if we had chosen to set ´’s color to black, then property 4 of a redblack tree would not be violated. Why didn’t we choose to set ´’s color to black?
13.3-2
Show the red-black trees that result after successively inserting the keys 41; 38; 31;
12; 19; 8 into an initially empty red-black tree.
13.3-3
Suppose that the black-height of each of the subtrees ˛; ˇ; ; ı; " in Figures 13.5
and 13.6 is k. Label each node in each ﬁgure with its black-height to verify that
the indicated transformation preserves property 5.
13.3-4
Professor Teach is concerned that RB-I NSERT-F IXUP might set T:nil:color to
RED , in which case the test in line 1 would not cause the loop to terminate when ´
is the root. Show that the professor’s concern is unfounded by arguing that RBI NSERT-F IXUP never sets T:nil:color to RED.
13.3-5
Consider a red-black tree formed by inserting n nodes with RB-I NSERT. Argue
that if n > 1, the tree has at least one red node.
13.3-6
Suggest how to implement RB-I NSERT efﬁciently if the representation for redblack trees includes no storage for parent pointers.

13.4 Deletion

323

13.4 Deletion
Like the other basic operations on an n-node red-black tree, deletion of a node takes
time O.lg n/. Deleting a node from a red-black tree is a bit more complicated than
inserting a node.
The procedure for deleting a node from a red-black tree is based on the T REE D ELETE procedure (Section 12.3). First, we need to customize the T RANSPLANT
subroutine that T REE -D ELETE calls so that it applies to a red-black tree:
RB-T RANSPLANT .T; u; /
1 if u:p == T:nil
2
T:root D 
3 elseif u == u:p:left
4
u:p:left D 
5 else u:p:right D 
6 :p D u:p
The procedure RB-T RANSPLANT differs from T RANSPLANT in two ways. First,
line 1 references the sentinel T:nil instead of NIL. Second, the assignment to :p in
line 6 occurs unconditionally: we can assign to :p even if  points to the sentinel.
In fact, we shall exploit the ability to assign to :p when  D T:nil.
The procedure RB-D ELETE is like the T REE -D ELETE procedure, but with additional lines of pseudocode. Some of the additional lines keep track of a node y
that might cause violations of the red-black properties. When we want to delete
node ´ and ´ has fewer than two children, then ´ is removed from the tree, and we
want y to be ´. When ´ has two children, then y should be ´’s successor, and y
moves into ´’s position in the tree. We also remember y’s color before it is removed from or moved within the tree, and we keep track of the node x that moves
into y’s original position in the tree, because node x might also cause violations
of the red-black properties. After deleting node ´, RB-D ELETE calls an auxiliary
procedure RB-D ELETE -F IXUP, which changes colors and performs rotations to
restore the red-black properties.

324

Chapter 13 Red-Black Trees

RB-D ELETE .T; ´/
1 y D´
2 y-original-color D y:color
3 if ´:left == T:nil
4
x D ´:right
5
RB-T RANSPLANT .T; ´; ´:right/
6 elseif ´:right == T:nil
7
x D ´:left
8
RB-T RANSPLANT .T; ´; ´:left/
9 else y D T REE -M INIMUM .´:right/
10
y-original-color D y:color
11
x D y:right
12
if y:p == ´
13
x:p D y
14
else RB-T RANSPLANT .T; y; y:right/
15
y:right D ´:right
16
y:right:p D y
17
RB-T RANSPLANT .T; ´; y/
18
y:left D ´:left
19
y:left:p D y
20
y:color D ´:color
21 if y-original-color == BLACK
22
RB-D ELETE -F IXUP .T; x/
Although RB-D ELETE contains almost twice as many lines of pseudocode as
T REE -D ELETE, the two procedures have the same basic structure. You can ﬁnd
each line of T REE -D ELETE within RB-D ELETE (with the changes of replacing
NIL by T:nil and replacing calls to T RANSPLANT by calls to RB-T RANSPLANT),
executed under the same conditions.
Here are the other differences between the two procedures:


We maintain node y as the node either removed from the tree or moved within
the tree. Line 1 sets y to point to node ´ when ´ has fewer than two children
and is therefore removed. When ´ has two children, line 9 sets y to point to ´’s
successor, just as in T REE -D ELETE, and y will move into ´’s position in the
tree.



Because node y’s color might change, the variable y-original-color stores y’s
color before any changes occur. Lines 2 and 10 set this variable immediately
after assignments to y. When ´ has two children, then y ¤ ´ and node y
moves into node ´’s original position in the red-black tree; line 20 gives y the
same color as ´. We need to save y’s original color in order to test it at the

13.4 Deletion

325

end of RB-D ELETE; if it was black, then removing or moving y could cause
violations of the red-black properties.


As discussed, we keep track of the node x that moves into node y’s original
position. The assignments in lines 4, 7, and 11 set x to point to either y’s only
child or, if y has no children, the sentinel T:nil. (Recall from Section 12.3
that y has no left child.)



Since node x moves into node y’s original position, the attribute x:p is always
set to point to the original position in the tree of y’s parent, even if x is, in fact,
the sentinel T:nil. Unless ´ is y’s original parent (which occurs only when ´ has
two children and its successor y is ´’s right child), the assignment to x:p takes
place in line 6 of RB-T RANSPLANT. (Observe that when RB-T RANSPLANT
is called in lines 5, 8, or 14, the second parameter passed is the same as x.)
When y’s original parent is ´, however, we do not want x:p to point to y’s original parent, since we are removing that node from the tree. Because node y will
move up to take ´’s position in the tree, setting x:p to y in line 13 causes x:p
to point to the original position of y’s parent, even if x D T:nil.



Finally, if node y was black, we might have introduced one or more violations
of the red-black properties, and so we call RB-D ELETE -F IXUP in line 22 to
restore the red-black properties. If y was red, the red-black properties still hold
when y is removed or moved, for the following reasons:
1. No black-heights in the tree have changed.
2. No red nodes have been made adjacent. Because y takes ´’s place in the
tree, along with ´’s color, we cannot have two adjacent red nodes at y’s new
position in the tree. In addition, if y was not ´’s right child, then y’s original
right child x replaces y in the tree. If y is red, then x must be black, and so
replacing y by x cannot cause two red nodes to become adjacent.
3. Since y could not have been the root if it was red, the root remains black.

If node y was black, three problems may arise, which the call of RB-D ELETE F IXUP will remedy. First, if y had been the root and a red child of y becomes the
new root, we have violated property 2. Second, if both x and x:p are red, then
we have violated property 4. Third, moving y within the tree causes any simple
path that previously contained y to have one fewer black node. Thus, property 5
is now violated by any ancestor of y in the tree. We can correct the violation
of property 5 by saying that node x, now occupying y’s original position, has an
“extra” black. That is, if we add 1 to the count of black nodes on any simple path
that contains x, then under this interpretation, property 5 holds. When we remove
or move the black node y, we “push” its blackness onto node x. The problem is
that now node x is neither red nor black, thereby violating property 1. Instead,

326

Chapter 13 Red-Black Trees

node x is either “doubly black” or “red-and-black,” and it contributes either 2 or 1,
respectively, to the count of black nodes on simple paths containing x. The color
attribute of x will still be either RED (if x is red-and-black) or BLACK (if x is
doubly black). In other words, the extra black on a node is reﬂected in x’s pointing
to the node rather than in the color attribute.
We can now see the procedure RB-D ELETE -F IXUP and examine how it restores
the red-black properties to the search tree.
RB-D ELETE -F IXUP .T; x/
1 while x ¤ T:root and x:color == BLACK
2
if x == x:p:left
3
w D x:p:right
4
if w:color == RED
5
w:color D BLACK
6
x:p:color D RED
7
L EFT-ROTATE .T; x:p/
8
w D x:p:right
9
if w:left:color == BLACK and w:right:color == BLACK
10
w:color D RED
11
x D x:p
12
else if w:right:color == BLACK
13
w:left:color D BLACK
14
w:color D RED
15
R IGHT-ROTATE .T; w/
16
w D x:p:right
17
w:color D x:p:color
18
x:p:color D BLACK
19
w:right:color D BLACK
20
L EFT-ROTATE .T; x:p/
21
x D T:root
22
else (same as then clause with “right” and “left” exchanged)
23 x:color D BLACK

// case 1
// case 1
// case 1
// case 1
// case 2
// case 2
// case 3
// case 3
// case 3
// case 3
// case 4
// case 4
// case 4
// case 4
// case 4

The procedure RB-D ELETE -F IXUP restores properties 1, 2, and 4. Exercises
13.4-1 and 13.4-2 ask you to show that the procedure restores properties 2 and 4,
and so in the remainder of this section, we shall focus on property 1. The goal of
the while loop in lines 1–22 is to move the extra black up the tree until
1. x points to a red-and-black node, in which case we color x (singly) black in
line 23;
2. x points to the root, in which case we simply “remove” the extra black; or
3. having performed suitable rotations and recolorings, we exit the loop.

13.4 Deletion

327

Within the while loop, x always points to a nonroot doubly black node. We
determine in line 2 whether x is a left child or a right child of its parent x:p. (We
have given the code for the situation in which x is a left child; the situation in
which x is a right child—line 22—is symmetric.) We maintain a pointer w to
the sibling of x. Since node x is doubly black, node w cannot be T:nil, because
otherwise, the number of blacks on the simple path from x:p to the (singly black)
leaf w would be smaller than the number on the simple path from x:p to x.
The four cases2 in the code appear in Figure 13.7. Before examining each case
in detail, let’s look more generally at how we can verify that the transformation
in each of the cases preserves property 5. The key idea is that in each case, the
transformation applied preserves the number of black nodes (including x’s extra
black) from (and including) the root of the subtree shown to each of the subtrees
˛; ˇ; : : : ; . Thus, if property 5 holds prior to the transformation, it continues to
hold afterward. For example, in Figure 13.7(a), which illustrates case 1, the number of black nodes from the root to either subtree ˛ or ˇ is 3, both before and after
the transformation. (Again, remember that node x adds an extra black.) Similarly,
the number of black nodes from the root to any of , ı, ", and is 2, both before and after the transformation. In Figure 13.7(b), the counting must involve the
value c of the color attribute of the root of the subtree shown, which can be either
RED or BLACK . If we deﬁne count.RED / D 0 and count.BLACK / D 1, then the
number of black nodes from the root to ˛ is 2 C count.c/, both before and after
the transformation. In this case, after the transformation, the new node x has color
attribute c, but this node is really either red-and-black (if c D RED ) or doubly black
(if c D BLACK ). You can verify the other cases similarly (see Exercise 13.4-5).
Case 1: x’s sibling w is red
Case 1 (lines 5–8 of RB-D ELETE -F IXUP and Figure 13.7(a)) occurs when node w,
the sibling of node x, is red. Since w must have black children, we can switch the
colors of w and x:p and then perform a left-rotation on x:p without violating any
of the red-black properties. The new sibling of x, which is one of w’s children
prior to the rotation, is now black, and thus we have converted case 1 into case 2,
3, or 4.
Cases 2, 3, and 4 occur when node w is black; they are distinguished by the
colors of w’s children.
2 As

in RB-I NSERT-F IXUP, the cases in RB-D ELETE -F IXUP are not mutually exclusive.

328

Chapter 13 Red-Black Trees

Case 2: x’s sibling w is black, and both of w’s children are black
In case 2 (lines 10–11 of RB-D ELETE -F IXUP and Figure 13.7(b)), both of w’s
children are black. Since w is also black, we take one black off both x and w,
leaving x with only one black and leaving w red. To compensate for removing
one black from x and w, we would like to add an extra black to x:p, which was
originally either red or black. We do so by repeating the while loop with x:p as
the new node x. Observe that if we enter case 2 through case 1, the new node x
is red-and-black, since the original x:p was red. Hence, the value c of the color
attribute of the new node x is RED, and the loop terminates when it tests the loop
condition. We then color the new node x (singly) black in line 23.
Case 3: x’s sibling w is black, w’s left child is red, and w’s right child is black
Case 3 (lines 13–16 and Figure 13.7(c)) occurs when w is black, its left child
is red, and its right child is black. We can switch the colors of w and its left
child w:left and then perform a right rotation on w without violating any of the
red-black properties. The new sibling w of x is now a black node with a red right
child, and thus we have transformed case 3 into case 4.
Case 4: x’s sibling w is black, and w’s right child is red
Case 4 (lines 17–21 and Figure 13.7(d)) occurs when node x’s sibling w is black
and w’s right child is red. By making some color changes and performing a left rotation on x:p, we can remove the extra black on x, making it singly black, without
violating any of the red-black properties. Setting x to be the root causes the while
loop to terminate when it tests the loop condition.
Analysis
What is the running time of RB-D ELETE? Since the height of a red-black tree of n
nodes is O.lg n/, the total cost of the procedure without the call to RB-D ELETE F IXUP takes O.lg n/ time. Within RB-D ELETE -F IXUP, each of cases 1, 3, and 4
lead to termination after performing a constant number of color changes and at
most three rotations. Case 2 is the only case in which the while loop can be repeated, and then the pointer x moves up the tree at most O.lg n/ times, performing
no rotations. Thus, the procedure RB-D ELETE -F IXUP takes O.lg n/ time and performs at most three rotations, and the overall time for RB-D ELETE is therefore
also O.lg n/.

13.4 Deletion

329

Case 1

B
(a)

x A

α

D w

β

C

γ

B
E

δ

ε

x A

ζ

x A

α

β

C

ε

new x

B c

C

β

C

E

γ

δ

x A

ε

ε

ζ

B c
C new w

α

E

δ

ζ

D

ζ

D w

γ

δ

Case 3

x A

β

γ

α

E

δ

ε

A

B c

α

β

D w

γ

(c)

α

E

new w C

Case 2

B c
(b)

D

β

γ

D

ζ

δ

E

ε
Case 4

B c
(d)

x A

α

D c

D w

β

C

γ

c′

δ

B
E

ε

E

A

ζ

ζ

α

C

β

γ

c′ ε

δ

ζ
new x D T:root

Figure 13.7 The cases in the while loop of the procedure RB-D ELETE -F IXUP. Darkened nodes
have color attributes BLACK, heavily shaded nodes have color attributes RED, and lightly shaded
nodes have color attributes represented by c and c 0 , which may be either RED or BLACK. The letters
˛; ˇ; : : : ; represent arbitrary subtrees. Each case transforms the conﬁguration on the left into the
conﬁguration on the right by changing some colors and/or performing a rotation. Any node pointed
to by x has an extra black and is either doubly black or red-and-black. Only case 2 causes the loop to
repeat. (a) Case 1 is transformed to case 2, 3, or 4 by exchanging the colors of nodes B and D and
performing a left rotation. (b) In case 2, the extra black represented by the pointer x moves up the
tree by coloring node D red and setting x to point to node B. If we enter case 2 through case 1, the
while loop terminates because the new node x is red-and-black, and therefore the value c of its color
attribute is RED. (c) Case 3 is transformed to case 4 by exchanging the colors of nodes C and D and
performing a right rotation. (d) Case 4 removes the extra black represented by x by changing some
colors and performing a left rotation (without violating the red-black properties), and then the loop
terminates.

330

Chapter 13 Red-Black Trees

Exercises
13.4-1
Argue that after executing RB-D ELETE -F IXUP, the root of the tree must be black.
13.4-2
Argue that if in RB-D ELETE both x and x:p are red, then property 4 is restored by
the call to RB-D ELETE -F IXUP .T; x/.
13.4-3
In Exercise 13.3-2, you found the red-black tree that results from successively
inserting the keys 41; 38; 31; 12; 19; 8 into an initially empty tree. Now show the
red-black trees that result from the successive deletion of the keys in the order
8; 12; 19; 31; 38; 41.
13.4-4
In which lines of the code for RB-D ELETE -F IXUP might we examine or modify
the sentinel T:nil?
13.4-5
In each of the cases of Figure 13.7, give the count of black nodes from the root of
the subtree shown to each of the subtrees ˛; ˇ; : : : ; , and verify that each count
remains the same after the transformation. When a node has a color attribute c
or c 0 , use the notation count.c/ or count.c 0 / symbolically in your count.
13.4-6
Professors Skelton and Baron are concerned that at the start of case 1 of RBD ELETE -F IXUP, the node x:p might not be black. If the professors are correct,
then lines 5–6 are wrong. Show that x:p must be black at the start of case 1, so that
the professors have nothing to worry about.
13.4-7
Suppose that a node x is inserted into a red-black tree with RB-I NSERT and then
is immediately deleted with RB-D ELETE. Is the resulting red-black tree the same
as the initial red-black tree? Justify your answer.

Problems for Chapter 13

331

Problems
13-1 Persistent dynamic sets
During the course of an algorithm, we sometimes ﬁnd that we need to maintain past
versions of a dynamic set as it is updated. We call such a set persistent. One way to
implement a persistent set is to copy the entire set whenever it is modiﬁed, but this
approach can slow down a program and also consume much space. Sometimes, we
can do much better.
Consider a persistent set S with the operations I NSERT, D ELETE, and S EARCH,
which we implement using binary search trees as shown in Figure 13.8(a). We
maintain a separate root for every version of the set. In order to insert the key 5
into the set, we create a new node with key 5. This node becomes the left child
of a new node with key 7, since we cannot modify the existing node with key 7.
Similarly, the new node with key 7 becomes the left child of a new node with
key 8 whose right child is the existing node with key 10. The new node with key 8
becomes, in turn, the right child of a new root r 0 with key 4 whose left child is the
existing node with key 3. We thus copy only part of the tree and share some of the
nodes with the original tree, as shown in Figure 13.8(b).
Assume that each tree node has the attributes key, left, and right but no parent.
(See also Exercise 13.3-6.)

4

r

3

r

8

2

7

4

4

3

10

r′

8

2

7

7

8

10

5
(a)

(b)

Figure 13.8 (a) A binary search tree with keys 2; 3; 4; 7; 8; 10. (b) The persistent binary search
tree that results from the insertion of key 5. The most recent version of the set consists of the nodes
reachable from the root r 0 , and the previous version consists of the nodes reachable from r. Heavily
shaded nodes are added when key 5 is inserted.

332

Chapter 13 Red-Black Trees

a. For a general persistent binary search tree, identify the nodes that we need to
change to insert a key k or delete a node y.
b. Write a procedure P ERSISTENT-T REE -I NSERT that, given a persistent tree T
and a key k to insert, returns a new persistent tree T 0 that is the result of inserting k into T .
c. If the height of the persistent binary search tree T is h, what are the time and
space requirements of your implementation of P ERSISTENT-T REE -I NSERT?
(The space requirement is proportional to the number of new nodes allocated.)
d. Suppose that we had included the parent attribute in each node. In this case,
P ERSISTENT-T REE -I NSERT would need to perform additional copying. Prove
that P ERSISTENT-T REE -I NSERT would then require .n/ time and space,
where n is the number of nodes in the tree.
e. Show how to use red-black trees to guarantee that the worst-case running time
and space are O.lg n/ per insertion or deletion.
13-2 Join operation on red-black trees
The join operation takes two dynamic sets S1 and S2 and an element x such that
for any x1 2 S1 and x2 2 S2 , we have x1 :key  x:key  x2 :key. It returns a set
S D S1 [ fxg [ S2 . In this problem, we investigate how to implement the join
operation on red-black trees.
a. Given a red-black tree T , let us store its black-height as the new attribute T:bh.
Argue that RB-I NSERT and RB-D ELETE can maintain the bh attribute without requiring extra storage in the nodes of the tree and without increasing the
asymptotic running times. Show that while descending through T , we can determine the black-height of each node we visit in O.1/ time per node visited.
We wish to implement the operation RB-J OIN .T1 ; x; T2 /, which destroys T1 and T2
and returns a red-black tree T D T1 [ fxg [ T2 . Let n be the total number of nodes
in T1 and T2 .
b. Assume that T1 :bh  T2 :bh. Describe an O.lg n/-time algorithm that ﬁnds a
black node y in T1 with the largest key from among those nodes whose blackheight is T2 :bh.
c. Let Ty be the subtree rooted at y. Describe how Ty [ fxg [ T2 can replace Ty
in O.1/ time without destroying the binary-search-tree property.
d. What color should we make x so that red-black properties 1, 3, and 5 are maintained? Describe how to enforce properties 2 and 4 in O.lg n/ time.

Problems for Chapter 13

333

e. Argue that no generality is lost by making the assumption in part (b). Describe
the symmetric situation that arises when T1 :bh  T2 :bh.
f. Argue that the running time of RB-J OIN is O.lg n/.
13-3 AVL trees
An AVL tree is a binary search tree that is height balanced: for each node x, the
heights of the left and right subtrees of x differ by at most 1. To implement an AVL
tree, we maintain an extra attribute in each node: x:h is the height of node x. As
for any other binary search tree T , we assume that T:root points to the root node.
a. Prove that an AVL tree with n nodes has height O.lg n/. (Hint: Prove that
an AVL tree of height h has at least Fh nodes, where Fh is the hth Fibonacci
number.)
b. To insert into an AVL tree, we ﬁrst place a node into the appropriate place in binary search tree order. Afterward, the tree might no longer be height balanced.
Speciﬁcally, the heights of the left and right children of some node might differ
by 2. Describe a procedure BALANCE .x/, which takes a subtree rooted at x
whose left and right children are height balanced and have heights that differ
by at most 2, i.e., jx:right:h  x:left:hj  2, and alters the subtree rooted at x
to be height balanced. (Hint: Use rotations.)
c. Using part (b), describe a recursive procedure AVL-I NSERT .x; ´/ that takes
a node x within an AVL tree and a newly created node ´ (whose key has already been ﬁlled in), and adds ´ to the subtree rooted at x, maintaining the
property that x is the root of an AVL tree. As in T REE -I NSERT from Section 12.3, assume that ´:key has already been ﬁlled in and that ´:left D NIL
and ´:right D NIL; also assume that ´:h D 0. Thus, to insert the node ´ into
the AVL tree T , we call AVL-I NSERT .T:root; ´/.
d. Show that AVL-I NSERT, run on an n-node AVL tree, takes O.lg n/ time and
performs O.1/ rotations.
13-4 Treaps
If we insert a set of n items into a binary search tree, the resulting tree may be
horribly unbalanced, leading to long search times. As we saw in Section 12.4,
however, randomly built binary search trees tend to be balanced. Therefore, one
strategy that, on average, builds a balanced tree for a ﬁxed set of items would be to
randomly permute the items and then insert them in that order into the tree.
What if we do not have all the items at once? If we receive the items one at a
time, can we still randomly build a binary search tree out of them?

334

Chapter 13 Red-Black Trees

G: 4
B: 7
A: 10

H: 5
E: 23

K: 65
I: 73

Figure 13.9 A treap. Each node x is labeled with x: key : x: priority. For example, the root has
key G and priority 4.

We will examine a data structure that answers this question in the afﬁrmative. A
treap is a binary search tree with a modiﬁed way of ordering the nodes. Figure 13.9
shows an example. As usual, each node x in the tree has a key value x:key. In
addition, we assign x:priority, which is a random number chosen independently
for each node. We assume that all priorities are distinct and also that all keys are
distinct. The nodes of the treap are ordered so that the keys obey the binary-searchtree property and the priorities obey the min-heap order property:


If  is a left child of u, then :key < u:key.



If  is a right child of u, then :key > u:key.



If  is a child of u, then :priority > u:priority.

(This combination of properties is why the tree is called a “treap”: it has features
of both a binary search tree and a heap.)
It helps to think of treaps in the following way. Suppose that we insert nodes
x1 ; x2 ; : : : ; xn , with associated keys, into a treap. Then the resulting treap is the
tree that would have been formed if the nodes had been inserted into a normal
binary search tree in the order given by their (randomly chosen) priorities, i.e.,
xi :priority < xj :priority means that we had inserted xi before xj .
a. Show that given a set of nodes x1 ; x2 ; : : : ; xn , with associated keys and priorities, all distinct, the treap associated with these nodes is unique.
b. Show that the expected height of a treap is ‚.lg n/, and hence the expected time
to search for a value in the treap is ‚.lg n/.
Let us see how to insert a new node into an existing treap. The ﬁrst thing we do
is assign to the new node a random priority. Then we call the insertion algorithm,
which we call T REAP -I NSERT, whose operation is illustrated in Figure 13.10.

Problems for Chapter 13

335

G: 4
B: 7
A: 10

G: 4
H: 5

E: 23

C: 25
K: 65

B: 7
A: 10

I: 73

D: 9

C: 25

G: 4

G: 4
H: 5

E: 23

B: 7
K: 65

A: 10

I: 73

H: 5
E: 23

D: 9

K: 65
I: 73

C: 25

D: 9
(c)

(d)

G: 4

F: 2

B: 7

H: 5
D: 9

C: 25

K: 65
I: 73

(b)

C: 25

A: 10

E: 23

(a)

B: 7
A: 10

H: 5

F: 2
K: 65

E: 23

I: 73

…
A: 10

B: 7

G: 4
D: 9

C: 25

H: 5

E: 23

K: 65
I: 73

(e)

(f)

Figure 13.10 The operation of T REAP -I NSERT . (a) The original treap, prior to insertion. (b) The
treap after inserting a node with key C and priority 25. (c)–(d) Intermediate stages when inserting a
node with key D and priority 9. (e) The treap after the insertion of parts (c) and (d) is done. (f) The
treap after inserting a node with key F and priority 2.

336

Chapter 13 Red-Black Trees

15
9
3

15
18

9

12

25

6

21
(a)

3

18
12

25

6

21
(b)

Figure 13.11 Spines of a binary search tree. The left spine is shaded in (a), and the right spine is
shaded in (b).

c. Explain how T REAP -I NSERT works. Explain the idea in English and give pseudocode. (Hint: Execute the usual binary-search-tree insertion procedure and
then perform rotations to restore the min-heap order property.)
d. Show that the expected running time of T REAP -I NSERT is ‚.lg n/.
T REAP -I NSERT performs a search and then a sequence of rotations. Although
these two operations have the same expected running time, they have different
costs in practice. A search reads information from the treap without modifying it.
In contrast, a rotation changes parent and child pointers within the treap. On most
computers, read operations are much faster than write operations. Thus we would
like T REAP -I NSERT to perform few rotations. We will show that the expected
number of rotations performed is bounded by a constant.
In order to do so, we will need some deﬁnitions, which Figure 13.11 depicts.
The left spine of a binary search tree T is the simple path from the root to the node
with the smallest key. In other words, the left spine is the simple path from the
root that consists of only left edges. Symmetrically, the right spine of T is the
simple path from the root consisting of only right edges. The length of a spine is
the number of nodes it contains.
e. Consider the treap T immediately after T REAP -I NSERT has inserted node x.
Let C be the length of the right spine of the left subtree of x. Let D be the
length of the left spine of the right subtree of x. Prove that the total number of
rotations that were performed during the insertion of x is equal to C C D.
We will now calculate the expected values of C and D. Without loss of generality,
we assume that the keys are 1; 2; : : : ; n, since we are comparing them only to one
another.

Notes for Chapter 13

337

For nodes x and y in treap T , where y ¤ x, let k D x:key and i D y:key. We
deﬁne indicator random variables
Xi k D I fy is in the right spine of the left subtree of xg :
f. Show that Xi k D 1 if and only if y:priority > x:priority, y:key < x:key, and,
for every ´ such that y:key < ´:key < x:key, we have y:priority < ´:priority.
g. Show that
Pr fXi k D 1g D
D

.k  i  1/Š
.k  i C 1/Š
1
:
.k  i C 1/.k  i/

h. Show that
E ŒC  D

k1
X
j D1

D 1

1
j.j C 1/
1
:
k

i. Use a symmetry argument to show that
E ŒD D 1 

1
:
nkC1

j. Conclude that the expected number of rotations performed when inserting a
node into a treap is less than 2.

Chapter notes
The idea of balancing a search tree is due to Adel’son-Vel’skiı̆ and Landis [2], who
introduced a class of balanced search trees called “AVL trees” in 1962, described in
Problem 13-3. Another class of search trees, called “2-3 trees,” was introduced by
J. E. Hopcroft (unpublished) in 1970. A 2-3 tree maintains balance by manipulating
the degrees of nodes in the tree. Chapter 18 covers a generalization of 2-3 trees
introduced by Bayer and McCreight [35], called “B-trees.”
Red-black trees were invented by Bayer [34] under the name “symmetric binary
B-trees.” Guibas and Sedgewick [155] studied their properties at length and introduced the red/black color convention. Andersson [15] gives a simpler-to-code

338

Chapter 13 Red-Black Trees

variant of red-black trees. Weiss [351] calls this variant AA-trees. An AA-tree is
similar to a red-black tree except that left children may never be red.
Treaps, the subject of Problem 13-4, were proposed by Seidel and Aragon [309].
They are the default implementation of a dictionary in LEDA [253], which is a
well-implemented collection of data structures and algorithms.
There are many other variations on balanced binary trees, including weightbalanced trees [264], k-neighbor trees [245], and scapegoat trees [127]. Perhaps
the most intriguing are the “splay trees” introduced by Sleator and Tarjan [320],
which are “self-adjusting.” (See Tarjan [330] for a good description of splay trees.)
Splay trees maintain balance without any explicit balance condition such as color.
Instead, “splay operations” (which involve rotations) are performed within the tree
every time an access is made. The amortized cost (see Chapter 17) of each operation on an n-node tree is O.lg n/.
Skip lists [286] provide an alternative to balanced binary trees. A skip list is a
linked list that is augmented with a number of additional pointers. Each dictionary
operation runs in expected time O.lg n/ on a skip list of n items.

14

Augmenting Data Structures

Some engineering situations require no more than a “textbook” data structure—such as a doubly linked list, a hash table, or a binary search tree—but many
others require a dash of creativity. Only in rare situations will you need to create an entirely new type of data structure, though. More often, it will sufﬁce to
augment a textbook data structure by storing additional information in it. You can
then program new operations for the data structure to support the desired application. Augmenting a data structure is not always straightforward, however, since the
added information must be updated and maintained by the ordinary operations on
the data structure.
This chapter discusses two data structures that we construct by augmenting redblack trees. Section 14.1 describes a data structure that supports general orderstatistic operations on a dynamic set. We can then quickly ﬁnd the ith smallest
number in a set or the rank of a given element in the total ordering of the set.
Section 14.2 abstracts the process of augmenting a data structure and provides a
theorem that can simplify the process of augmenting red-black trees. Section 14.3
uses this theorem to help design a data structure for maintaining a dynamic set of
intervals, such as time intervals. Given a query interval, we can then quickly ﬁnd
an interval in the set that overlaps it.

14.1 Dynamic order statistics
Chapter 9 introduced the notion of an order statistic. Speciﬁcally, the ith order
statistic of a set of n elements, where i 2 f1; 2; : : : ; ng, is simply the element in the
set with the ith smallest key. We saw how to determine any order statistic in O.n/
time from an unordered set. In this section, we shall see how to modify red-black
trees so that we can determine any order statistic for a dynamic set in O.lg n/ time.
We shall also see how to compute the rank of an element—its position in the linear
order of the set—in O.lg n/ time.

340

Chapter 14 Augmenting Data Structures

26
20

17

41

12

21

30

7

4

5

10
4

3

7

14
16

19

2

2

7

12

14

20

2

1

1

1

21

28

1

1

key
size

47
1

38
3

35

39

1

1

1

Figure 14.1 An order-statistic tree, which is an augmented red-black tree. Shaded nodes are red,
and darkened nodes are black. In addition to its usual attributes, each node x has an attribute x: size,
which is the number of nodes, other than the sentinel, in the subtree rooted at x.

Figure 14.1 shows a data structure that can support fast order-statistic operations.
An order-statistic tree T is simply a red-black tree with additional information
stored in each node. Besides the usual red-black tree attributes x:key, x:color, x:p,
x:left, and x:right in a node x, we have another attribute, x:size. This attribute
contains the number of (internal) nodes in the subtree rooted at x (including x
itself), that is, the size of the subtree. If we deﬁne the sentinel’s size to be 0—that
is, we set T:nil:size to be 0—then we have the identity
x:size D x:left:size C x:right:size C 1 :
We do not require keys to be distinct in an order-statistic tree. (For example, the
tree in Figure 14.1 has two keys with value 14 and two keys with value 21.) In the
presence of equal keys, the above notion of rank is not well deﬁned. We remove
this ambiguity for an order-statistic tree by deﬁning the rank of an element as the
position at which it would be printed in an inorder walk of the tree. In Figure 14.1,
for example, the key 14 stored in a black node has rank 5, and the key 14 stored in
a red node has rank 6.
Retrieving an element with a given rank
Before we show how to maintain this size information during insertion and deletion, let us examine the implementation of two order-statistic queries that use this
additional information. We begin with an operation that retrieves an element with
a given rank. The procedure OS-S ELECT .x; i/ returns a pointer to the node containing the ith smallest key in the subtree rooted at x. To ﬁnd the node with the ith
smallest key in an order-statistic tree T , we call OS-S ELECT .T:root; i/.

14.1 Dynamic order statistics

341

OS-S ELECT .x; i/
1 r D x:left:size C 1
2 if i == r
3
return x
4 elseif i < r
5
return OS-S ELECT .x:left; i/
6 else return OS-S ELECT .x:right; i  r/
In line 1 of OS-S ELECT, we compute r, the rank of node x within the subtree
rooted at x. The value of x:left:size is the number of nodes that come before x
in an inorder tree walk of the subtree rooted at x. Thus, x:left:size C 1 is the
rank of x within the subtree rooted at x. If i D r, then node x is the ith smallest
element, and so we return x in line 3. If i < r, then the ith smallest element
resides in x’s left subtree, and so we recurse on x:left in line 5. If i > r, then
the ith smallest element resides in x’s right subtree. Since the subtree rooted at x
contains r elements that come before x’s right subtree in an inorder tree walk, the
ith smallest element in the subtree rooted at x is the .i  r/th smallest element in
the subtree rooted at x:right. Line 6 determines this element recursively.
To see how OS-S ELECT operates, consider a search for the 17th smallest element in the order-statistic tree of Figure 14.1. We begin with x as the root, whose
key is 26, and with i D 17. Since the size of 26’s left subtree is 12, its rank is 13.
Thus, we know that the node with rank 17 is the 17  13 D 4th smallest element
in 26’s right subtree. After the recursive call, x is the node with key 41, and i D 4.
Since the size of 41’s left subtree is 5, its rank within its subtree is 6. Thus, we
know that the node with rank 4 is the 4th smallest element in 41’s left subtree. After the recursive call, x is the node with key 30, and its rank within its subtree is 2.
Thus, we recurse once again to ﬁnd the 4 2 D 2nd smallest element in the subtree
rooted at the node with key 38. We now ﬁnd that its left subtree has size 1, which
means it is the second smallest element. Thus, the procedure returns a pointer to
the node with key 38.
Because each recursive call goes down one level in the order-statistic tree, the
total time for OS-S ELECT is at worst proportional to the height of the tree. Since
the tree is a red-black tree, its height is O.lg n/, where n is the number of nodes.
Thus, the running time of OS-S ELECT is O.lg n/ for a dynamic set of n elements.
Determining the rank of an element
Given a pointer to a node x in an order-statistic tree T , the procedure OS-R ANK
returns the position of x in the linear order determined by an inorder tree walk
of T .

342

Chapter 14 Augmenting Data Structures

OS-R ANK .T; x/
1 r D x:left:size C 1
2 y Dx
3 while y ¤ T:root
4
if y == y:p:right
5
r D r C y:p:left:size C 1
6
y D y:p
7 return r
The procedure works as follows. We can think of node x’s rank as the number of
nodes preceding x in an inorder tree walk, plus 1 for x itself. OS-R ANK maintains
the following loop invariant:
At the start of each iteration of the while loop of lines 3–6, r is the rank
of x:key in the subtree rooted at node y.
We use this loop invariant to show that OS-R ANK works correctly as follows:
Initialization: Prior to the ﬁrst iteration, line 1 sets r to be the rank of x:key within
the subtree rooted at x. Setting y D x in line 2 makes the invariant true the
ﬁrst time the test in line 3 executes.
Maintenance: At the end of each iteration of the while loop, we set y D y:p.
Thus we must show that if r is the rank of x:key in the subtree rooted at y at the
start of the loop body, then r is the rank of x:key in the subtree rooted at y:p
at the end of the loop body. In each iteration of the while loop, we consider
the subtree rooted at y:p. We have already counted the number of nodes in the
subtree rooted at node y that precede x in an inorder walk, and so we must add
the nodes in the subtree rooted at y’s sibling that precede x in an inorder walk,
plus 1 for y:p if it, too, precedes x. If y is a left child, then neither y:p nor any
node in y:p’s right subtree precedes x, and so we leave r alone. Otherwise, y is
a right child and all the nodes in y:p’s left subtree precede x, as does y:p itself.
Thus, in line 5, we add y:p:left:size C 1 to the current value of r.
Termination: The loop terminates when y D T:root, so that the subtree rooted
at y is the entire tree. Thus, the value of r is the rank of x:key in the entire tree.
As an example, when we run OS-R ANK on the order-statistic tree of Figure 14.1
to ﬁnd the rank of the node with key 38, we get the following sequence of values
of y:key and r at the top of the while loop:
iteration
1
2
3
4

y:key
38
30
41
26

r
2
4
4
17

14.1 Dynamic order statistics

343

The procedure returns the rank 17.
Since each iteration of the while loop takes O.1/ time, and y goes up one level in
the tree with each iteration, the running time of OS-R ANK is at worst proportional
to the height of the tree: O.lg n/ on an n-node order-statistic tree.
Maintaining subtree sizes
Given the size attribute in each node, OS-S ELECT and OS-R ANK can quickly
compute order-statistic information. But unless we can efﬁciently maintain these
attributes within the basic modifying operations on red-black trees, our work will
have been for naught. We shall now show how to maintain subtree sizes for both
insertion and deletion without affecting the asymptotic running time of either operation.
We noted in Section 13.3 that insertion into a red-black tree consists of two
phases. The ﬁrst phase goes down the tree from the root, inserting the new node
as a child of an existing node. The second phase goes up the tree, changing colors
and performing rotations to maintain the red-black properties.
To maintain the subtree sizes in the ﬁrst phase, we simply increment x:size for
each node x on the simple path traversed from the root down toward the leaves. The
new node added gets a size of 1. Since there are O.lg n/ nodes on the traversed
path, the additional cost of maintaining the size attributes is O.lg n/.
In the second phase, the only structural changes to the underlying red-black tree
are caused by rotations, of which there are at most two. Moreover, a rotation is
a local operation: only two nodes have their size attributes invalidated. The link
around which the rotation is performed is incident on these two nodes. Referring
to the code for L EFT-ROTATE .T; x/ in Section 13.2, we add the following lines:
13
14

y:size D x:size
x:size D x:left:size C x:right:size C 1

Figure 14.2 illustrates how the attributes are updated. The change to R IGHTROTATE is symmetric.
Since at most two rotations are performed during insertion into a red-black tree,
we spend only O.1/ additional time updating size attributes in the second phase.
Thus, the total time for insertion into an n-node order-statistic tree is O.lg n/,
which is asymptotically the same as for an ordinary red-black tree.
Deletion from a red-black tree also consists of two phases: the ﬁrst operates
on the underlying search tree, and the second causes at most three rotations and
otherwise performs no structural changes. (See Section 13.4.) The ﬁrst phase
either removes one node y from the tree or moves upward it within the tree. To
update the subtree sizes, we simply traverse a simple path from node y (starting
from its original position within the tree) up to the root, decrementing the size

344

Chapter 14 Augmenting Data Structures

93
19

42
11

LEFT-ROTATE(T, x)

42

y

19

x
93

x
7

6

RIGHT-ROTATE(T, y)

4

12

y

6
4

7

Figure 14.2 Updating subtree sizes during rotations. The link around which we rotate is incident
on the two nodes whose size attributes need to be updated. The updates are local, requiring only the
size information stored in x, y, and the roots of the subtrees shown as triangles.

attribute of each node on the path. Since this path has length O.lg n/ in an nnode red-black tree, the additional time spent maintaining size attributes in the ﬁrst
phase is O.lg n/. We handle the O.1/ rotations in the second phase of deletion
in the same manner as for insertion. Thus, both insertion and deletion, including
maintaining the size attributes, take O.lg n/ time for an n-node order-statistic tree.
Exercises
14.1-1
Show how OS-S ELECT .T:root; 10/ operates on the red-black tree T of Figure 14.1.
14.1-2
Show how OS-R ANK .T; x/ operates on the red-black tree T of Figure 14.1 and
the node x with x:key D 35.
14.1-3
Write a nonrecursive version of OS-S ELECT.
14.1-4
Write a recursive procedure OS-K EY-R ANK .T; k/ that takes as input an orderstatistic tree T and a key k and returns the rank of k in the dynamic set represented
by T . Assume that the keys of T are distinct.
14.1-5
Given an element x in an n-node order-statistic tree and a natural number i, how
can we determine the ith successor of x in the linear order of the tree in O.lg n/
time?

14.2 How to augment a data structure

345

14.1-6
Observe that whenever we reference the size attribute of a node in either OSS ELECT or OS-R ANK, we use it only to compute a rank. Accordingly, suppose
we store in each node its rank in the subtree of which it is the root. Show how to
maintain this information during insertion and deletion. (Remember that these two
operations can cause rotations.)
14.1-7
Show how to use an order-statistic tree to count the number of inversions (see
Problem 2-4) in an array of size n in time O.n lg n/.
14.1-8 ?
Consider n chords on a circle, each deﬁned by its endpoints. Describe an O.n lg n/time algorithm to determine the number of pairs of chords that intersect inside the
circle. (For example, if the n chords are all diameters that meet at the center, then
the correct answer is n2 .) Assume that no two chords share an endpoint.

14.2 How to augment a data structure
The process of augmenting a basic data structure to support additional functionality
occurs quite frequently in algorithm design. We shall use it again in the next section
to design a data structure that supports operations on intervals. In this section, we
examine the steps involved in such augmentation. We shall also prove a theorem
that allows us to augment red-black trees easily in many cases.
We can break the process of augmenting a data structure into four steps:
1. Choose an underlying data structure.
2. Determine additional information to maintain in the underlying data structure.
3. Verify that we can maintain the additional information for the basic modifying
operations on the underlying data structure.
4. Develop new operations.
As with any prescriptive design method, you should not blindly follow the steps
in the order given. Most design work contains an element of trial and error, and
progress on all steps usually proceeds in parallel. There is no point, for example, in
determining additional information and developing new operations (steps 2 and 4)
if we will not be able to maintain the additional information efﬁciently. Nevertheless, this four-step method provides a good focus for your efforts in augmenting
a data structure, and it is also a good way to organize the documentation of an
augmented data structure.

346

Chapter 14 Augmenting Data Structures

We followed these steps in Section 14.1 to design our order-statistic trees. For
step 1, we chose red-black trees as the underlying data structure. A clue to the
suitability of red-black trees comes from their efﬁcient support of other dynamicset operations on a total order, such as M INIMUM, M AXIMUM, S UCCESSOR, and
P REDECESSOR.
For step 2, we added the size attribute, in which each node x stores the size of the
subtree rooted at x. Generally, the additional information makes operations more
efﬁcient. For example, we could have implemented OS-S ELECT and OS-R ANK
using just the keys stored in the tree, but they would not have run in O.lg n/ time.
Sometimes, the additional information is pointer information rather than data, as
in Exercise 14.2-1.
For step 3, we ensured that insertion and deletion could maintain the size attributes while still running in O.lg n/ time. Ideally, we should need to update only
a few elements of the data structure in order to maintain the additional information.
For example, if we simply stored in each node its rank in the tree, the OS-S ELECT
and OS-R ANK procedures would run quickly, but inserting a new minimum element would cause a change to this information in every node of the tree. When we
store subtree sizes instead, inserting a new element causes information to change
in only O.lg n/ nodes.
For step 4, we developed the operations OS-S ELECT and OS-R ANK. After all,
the need for new operations is why we bother to augment a data structure in the ﬁrst
place. Occasionally, rather than developing new operations, we use the additional
information to expedite existing ones, as in Exercise 14.2-1.
Augmenting red-black trees
When red-black trees underlie an augmented data structure, we can prove that insertion and deletion can always efﬁciently maintain certain kinds of additional information, thereby making step 3 very easy. The proof of the following theorem is
similar to the argument from Section 14.1 that we can maintain the size attribute
for order-statistic trees.
Theorem 14.1 (Augmenting a red-black tree)
Let f be an attribute that augments a red-black tree T of n nodes, and suppose that
the value of f for each node x depends on only the information in nodes x, x:left,
and x:right, possibly including x:left:f and x:right:f . Then, we can maintain the
values of f in all nodes of T during insertion and deletion without asymptotically
affecting the O.lg n/ performance of these operations.
Proof The main idea of the proof is that a change to an f attribute in a node x
propagates only to ancestors of x in the tree. That is, changing x:f may re-

14.2 How to augment a data structure

347

quire x:p:f to be updated, but nothing else; updating x:p:f may require x:p:p:f
to be updated, but nothing else; and so on up the tree. Once we have updated
T:root:f , no other node will depend on the new value, and so the process terminates. Since the height of a red-black tree is O.lg n/, changing an f attribute in a
node costs O.lg n/ time in updating all nodes that depend on the change.
Insertion of a node x into T consists of two phases. (See Section 13.3.) The
ﬁrst phase inserts x as a child of an existing node x:p. We can compute the value
of x:f in O.1/ time since, by supposition, it depends only on information in the
other attributes of x itself and the information in x’s children, but x’s children are
both the sentinel T:nil. Once we have computed x:f , the change propagates up
the tree. Thus, the total time for the ﬁrst phase of insertion is O.lg n/. During the
second phase, the only structural changes to the tree come from rotations. Since
only two nodes change in a rotation, the total time for updating the f attributes
is O.lg n/ per rotation. Since the number of rotations during insertion is at most
two, the total time for insertion is O.lg n/.
Like insertion, deletion has two phases. (See Section 13.4.) In the ﬁrst phase,
changes to the tree occur when the deleted node is removed from the tree. If the
deleted node had two children at the time, then its successor moves into the position
of the deleted node. Propagating the updates to f caused by these changes costs
at most O.lg n/, since the changes modify the tree locally. Fixing up the red-black
tree during the second phase requires at most three rotations, and each rotation
requires at most O.lg n/ time to propagate the updates to f . Thus, like insertion,
the total time for deletion is O.lg n/.
In many cases, such as maintaining the size attributes in order-statistic trees, the
cost of updating after a rotation is O.1/, rather than the O.lg n/ derived in the proof
of Theorem 14.1. Exercise 14.2-3 gives an example.
Exercises
14.2-1
Show, by adding pointers to the nodes, how to support each of the dynamic-set
queries M INIMUM, M AXIMUM, S UCCESSOR, and P REDECESSOR in O.1/ worstcase time on an augmented order-statistic tree. The asymptotic performance of
other operations on order-statistic trees should not be affected.
14.2-2
Can we maintain the black-heights of nodes in a red-black tree as attributes in the
nodes of the tree without affecting the asymptotic performance of any of the redblack tree operations? Show how, or argue why not. How about maintaining the
depths of nodes?

348

Chapter 14 Augmenting Data Structures

14.2-3 ?
Let ˝ be an associative binary operator, and let a be an attribute maintained in each
node of a red-black tree. Suppose that we want to include in each node x an additional attribute f such that x:f D x1 :a ˝ x2 :a ˝    ˝ xm :a, where x1 ; x2 ; : : : ; xm
is the inorder listing of nodes in the subtree rooted at x. Show how to update the f
attributes in O.1/ time after a rotation. Modify your argument slightly to apply it
to the size attributes in order-statistic trees.
14.2-4 ?
We wish to augment red-black trees with an operation RB-E NUMERATE .x; a; b/
that outputs all the keys k such that a  k  b in a red-black tree rooted at x.
Describe how to implement RB-E NUMERATE in ‚.m C lg n/ time, where m is the
number of keys that are output and n is the number of internal nodes in the tree.
(Hint: You do not need to add new attributes to the red-black tree.)

14.3 Interval trees
In this section, we shall augment red-black trees to support operations on dynamic
sets of intervals. A closed interval is an ordered pair of real numbers Œt1 ; t2 , with
t1  t2 . The interval Œt1 ; t2  represents the set ft 2 R W t1  t  t2 g. Open and
half-open intervals omit both or one of the endpoints from the set, respectively. In
this section, we shall assume that intervals are closed; extending the results to open
and half-open intervals is conceptually straightforward.
Intervals are convenient for representing events that each occupy a continuous
period of time. We might, for example, wish to query a database of time intervals
to ﬁnd out what events occurred during a given interval. The data structure in this
section provides an efﬁcient means for maintaining such an interval database.
We can represent an interval Œt1 ; t2  as an object i, with attributes i:low D t1
(the low endpoint) and i:high D t2 (the high endpoint). We say that intervals i
and i 0 overlap if i \ i 0 ¤ ;, that is, if i:low  i 0 :high and i 0 :low  i:high. As
Figure 14.3 shows, any two intervals i and i 0 satisfy the interval trichotomy; that
is, exactly one of the following three properties holds:
a. i and i 0 overlap,
b. i is to the left of i 0 (i.e., i:high < i 0 :low),
c. i is to the right of i 0 (i.e., i 0 :high < i:low).
An interval tree is a red-black tree that maintains a dynamic set of elements, with
each element x containing an interval x:int. Interval trees support the following
operations:

14.3 Interval trees

349

i
i′

i
i′

i
i′

i
i′

(a)
i

i′

(b)

i′

i
(c)

Figure 14.3 The interval trichotomy for two closed intervals i and i 0 . (a) If i and i 0 overlap, there
are four situations; in each, i: low  i 0 : high and i 0 : low  i: high. (b) The intervals do not overlap,
and i: high < i 0 : low. (c) The intervals do not overlap, and i 0 : high < i: low.

I NTERVAL -I NSERT .T; x/ adds the element x, whose int attribute is assumed to
contain an interval, to the interval tree T .
I NTERVAL -D ELETE .T; x/ removes the element x from the interval tree T .
I NTERVAL -S EARCH .T; i/ returns a pointer to an element x in the interval tree T
such that x:int overlaps interval i, or a pointer to the sentinel T:nil if no such
element is in the set.
Figure 14.4 shows how an interval tree represents a set of intervals. We shall track
the four-step method from Section 14.2 as we review the design of an interval tree
and the operations that run on it.
Step 1: Underlying data structure
We choose a red-black tree in which each node x contains an interval x:int and the
key of x is the low endpoint, x:int:low, of the interval. Thus, an inorder tree walk
of the data structure lists the intervals in sorted order by low endpoint.
Step 2: Additional information
In addition to the intervals themselves, each node x contains a value x:max, which
is the maximum value of any interval endpoint stored in the subtree rooted at x.
Step 3: Maintaining the information
We must verify that insertion and deletion take O.lg n/ time on an interval tree
of n nodes. We can determine x:max given interval x:int and the max values of
node x’s children:

350

Chapter 14 Augmenting Data Structures

26 26
25
19
17

(a)

19

16

21

15
8

23

9

6

10

5
0

30

20

8

3
0

5

10

15

20

25

30

[16,21]
30

[8,9]

[25,30]

23

30

(b)

int
max

[5,8]

[15,23]

[17,19]

[26,26]

10

23

20

26

[0,3]

[6,10]

[19,20]

3

10

20

Figure 14.4 An interval tree. (a) A set of 10 intervals, shown sorted bottom to top by left endpoint.
(b) The interval tree that represents them. Each node x contains an interval, shown above the dashed
line, and the maximum value of any interval endpoint in the subtree rooted at x, shown below the
dashed line. An inorder tree walk of the tree lists the nodes in sorted order by left endpoint.

x:max D max.x:int:high; x:left:max; x:right:max/ :
Thus, by Theorem 14.1, insertion and deletion run in O.lg n/ time. In fact, we
can update the max attributes after a rotation in O.1/ time, as Exercises 14.2-3
and 14.3-1 show.
Step 4: Developing new operations
The only new operation we need is I NTERVAL -S EARCH .T; i/, which ﬁnds a node
in tree T whose interval overlaps interval i. If there is no interval that overlaps i in
the tree, the procedure returns a pointer to the sentinel T:nil.

14.3 Interval trees

351

I NTERVAL -S EARCH .T; i/
1 x D T:root
2 while x ¤ T:nil and i does not overlap x:int
3
if x:left ¤ T:nil and x:left:max  i:low
4
x D x:left
5
else x D x:right
6 return x
The search for an interval that overlaps i starts with x at the root of the tree and
proceeds downward. It terminates when either it ﬁnds an overlapping interval or x
points to the sentinel T:nil. Since each iteration of the basic loop takes O.1/ time,
and since the height of an n-node red-black tree is O.lg n/, the I NTERVAL -S EARCH
procedure takes O.lg n/ time.
Before we see why I NTERVAL -S EARCH is correct, let’s examine how it works
on the interval tree in Figure 14.4. Suppose we wish to ﬁnd an interval that overlaps
the interval i D Œ22; 25. We begin with x as the root, which contains Œ16; 21 and
does not overlap i. Since x:left:max D 23 is greater than i:low D 22, the loop
continues with x as the left child of the root—the node containing Œ8; 9, which also
does not overlap i. This time, x:left:max D 10 is less than i:low D 22, and so the
loop continues with the right child of x as the new x. Because the interval Œ15; 23
stored in this node overlaps i, the procedure returns this node.
As an example of an unsuccessful search, suppose we wish to ﬁnd an interval
that overlaps i D Œ11; 14 in the interval tree of Figure 14.4. We once again begin with x as the root. Since the root’s interval Œ16; 21 does not overlap i, and
since x:left:max D 23 is greater than i:low D 11, we go left to the node containing Œ8; 9. Interval Œ8; 9 does not overlap i, and x:left:max D 10 is less than
i:low D 11, and so we go right. (Note that no interval in the left subtree overlaps i.) Interval Œ15; 23 does not overlap i, and its left child is T:nil, so again we
go right, the loop terminates, and we return the sentinel T:nil.
To see why I NTERVAL -S EARCH is correct, we must understand why it sufﬁces
to examine a single path from the root. The basic idea is that at any node x,
if x:int does not overlap i, the search always proceeds in a safe direction: the
search will deﬁnitely ﬁnd an overlapping interval if the tree contains one. The
following theorem states this property more precisely.
Theorem 14.2
Any execution of I NTERVAL -S EARCH .T; i/ either returns a node whose interval
overlaps i, or it returns T:nil and the tree T contains no node whose interval overlaps i.

352

Chapter 14 Augmenting Data Structures

i′′
i′′
i′
i′

i

(a)

i

i′′
i′

(b)

Figure 14.5 Intervals in the proof of Theorem 14.2. The value of x: left: max is shown in each case
as a dashed line. (a) The search goes right. No interval i 0 in x’s left subtree can overlap i. (b) The
search goes left. The left subtree of x contains an interval that overlaps i (situation not shown),
or x’s left subtree contains an interval i 0 such that i 0 : high D x: left: max. Since i does not overlap i 0 ,
neither does it overlap any interval i 00 in x’s right subtree, since i 0 : low  i 00 : low.

Proof The while loop of lines 2–5 terminates either when x D T:nil or i overlaps x:int. In the latter case, it is certainly correct to return x. Therefore, we focus
on the former case, in which the while loop terminates because x D T:nil.
We use the following invariant for the while loop of lines 2–5:
If tree T contains an interval that overlaps i, then the subtree rooted at x
contains such an interval.
We use this loop invariant as follows:
Initialization: Prior to the ﬁrst iteration, line 1 sets x to be the root of T , so that
the invariant holds.
Maintenance: Each iteration of the while loop executes either line 4 or line 5. We
shall show that both cases maintain the loop invariant.
If line 5 is executed, then because of the branch condition in line 3, we
have x:left D T:nil, or x:left:max < i:low. If x:left D T:nil, the subtree
rooted at x:left clearly contains no interval that overlaps i, and so setting x
to x:right maintains the invariant. Suppose, therefore, that x:left ¤ T:nil and
x:left:max < i:low. As Figure 14.5(a) shows, for each interval i 0 in x’s left
subtree, we have
i 0 :high  x:left:max
< i:low :
By the interval trichotomy, therefore, i 0 and i do not overlap. Thus, the left
subtree of x contains no intervals that overlap i, so that setting x to x:right
maintains the invariant.

14.3 Interval trees

353

If, on the other hand, line 4 is executed, then we will show that the contrapositive of the loop invariant holds. That is, if the subtree rooted at x:left contains no interval overlapping i, then no interval anywhere in the tree overlaps i.
Since line 4 is executed, then because of the branch condition in line 3, we
have x:left:max  i:low. Moreover, by deﬁnition of the max attribute, x’s left
subtree must contain some interval i 0 such that
i 0 :high D x:left:max
 i:low :
(Figure 14.5(b) illustrates the situation.) Since i and i 0 do not overlap, and
since it is not true that i 0 :high < i:low, it follows by the interval trichotomy
that i:high < i 0 :low. Interval trees are keyed on the low endpoints of intervals,
and thus the search-tree property implies that for any interval i 00 in x’s right
subtree,
i:high < i 0 :low
 i 00 :low :
By the interval trichotomy, i and i 00 do not overlap. We conclude that whether
or not any interval in x’s left subtree overlaps i, setting x to x:left maintains
the invariant.
Termination: If the loop terminates when x D T:nil, then the subtree rooted at x
contains no interval overlapping i. The contrapositive of the loop invariant
implies that T contains no interval that overlaps i. Hence it is correct to return
x D T:nil.
Thus, the I NTERVAL -S EARCH procedure works correctly.
Exercises
14.3-1
Write pseudocode for L EFT-ROTATE that operates on nodes in an interval tree and
updates the max attributes in O.1/ time.
14.3-2
Rewrite the code for I NTERVAL -S EARCH so that it works properly when all intervals are open.
14.3-3
Describe an efﬁcient algorithm that, given an interval i, returns an interval overlapping i that has the minimum low endpoint, or T:nil if no such interval exists.

354

Chapter 14 Augmenting Data Structures

14.3-4
Given an interval tree T and an interval i, describe how to list all intervals in T
that overlap i in O.min.n; k lg n// time, where k is the number of intervals in the
output list. (Hint: One simple method makes several queries, modifying the tree
between queries. A slightly more complicated method does not modify the tree.)
14.3-5
Suggest modiﬁcations to the interval-tree procedures to support the new operation I NTERVAL -S EARCH -E XACTLY .T; i/, where T is an interval tree and i is
an interval. The operation should return a pointer to a node x in T such that
x:int:low D i:low and x:int:high D i:high, or T:nil if T contains no such node.
All operations, including I NTERVAL -S EARCH -E XACTLY, should run in O.lg n/
time on an n-node interval tree.
14.3-6
Show how to maintain a dynamic set Q of numbers that supports the operation
M IN -G AP, which gives the magnitude of the difference of the two closest numbers in Q. For example, if Q D f1; 5; 9; 15; 18; 22g, then M IN -G AP .Q/ returns
18  15 D 3, since 15 and 18 are the two closest numbers in Q. Make the operations I NSERT, D ELETE, S EARCH, and M IN -G AP as efﬁcient as possible, and
analyze their running times.
14.3-7 ?
VLSI databases commonly represent an integrated circuit as a list of rectangles. Assume that each rectangle is rectilinearly oriented (sides parallel to the
x- and y-axes), so that we represent a rectangle by its minimum and maximum xand y-coordinates. Give an O.n lg n/-time algorithm to decide whether or not a set
of n rectangles so represented contains two rectangles that overlap. Your algorithm
need not report all intersecting pairs, but it must report that an overlap exists if one
rectangle entirely covers another, even if the boundary lines do not intersect. (Hint:
Move a “sweep” line across the set of rectangles.)

Problems
14-1 Point of maximum overlap
Suppose that we wish to keep track of a point of maximum overlap in a set of
intervals—a point with the largest number of intervals in the set that overlap it.
a. Show that there will always be a point of maximum overlap that is an endpoint
of one of the segments.

Notes for Chapter 14

355

b. Design a data structure that efﬁciently supports the operations I NTERVAL I NSERT, I NTERVAL -D ELETE, and F IND -POM, which returns a point of maximum overlap. (Hint: Keep a red-black tree of all the endpoints. Associate
a value of C1 with each left endpoint, and associate a value of 1 with each
right endpoint. Augment each node of the tree with some extra information to
maintain the point of maximum overlap.)
14-2 Josephus permutation
We deﬁne the Josephus problem as follows. Suppose that n people form a circle
and that we are given a positive integer m  n. Beginning with a designated
ﬁrst person, we proceed around the circle, removing every mth person. After each
person is removed, counting continues around the circle that remains. This process
continues until we have removed all n people. The order in which the people are
removed from the circle deﬁnes the .n; m/-Josephus permutation of the integers
1; 2; : : : ; n. For example, the .7; 3/-Josephus permutation is h3; 6; 2; 7; 5; 1; 4i.
a. Suppose that m is a constant. Describe an O.n/-time algorithm that, given an
integer n, outputs the .n; m/-Josephus permutation.
b. Suppose that m is not a constant. Describe an O.n lg n/-time algorithm that,
given integers n and m, outputs the .n; m/-Josephus permutation.

Chapter notes
In their book, Preparata and Shamos [282] describe several of the interval trees
that appear in the literature, citing work by H. Edelsbrunner (1980) and E. M.
McCreight (1981). The book details an interval tree that, given a static database
of n intervals, allows us to enumerate all k intervals that overlap a given query
interval in O.k C lg n/ time.

IV

Advanced Design and Analysis Techniques

Introduction
This part covers three important techniques used in designing and analyzing efﬁcient algorithms: dynamic programming (Chapter 15), greedy algorithms (Chapter 16), and amortized analysis (Chapter 17). Earlier parts have presented other
widely applicable techniques, such as divide-and-conquer, randomization, and how
to solve recurrences. The techniques in this part are somewhat more sophisticated,
but they help us to attack many computational problems. The themes introduced in
this part will recur later in this book.
Dynamic programming typically applies to optimization problems in which we
make a set of choices in order to arrive at an optimal solution. As we make
each choice, subproblems of the same form often arise. Dynamic programming
is effective when a given subproblem may arise from more than one partial set of
choices; the key technique is to store the solution to each such subproblem in case it
should reappear. Chapter 15 shows how this simple idea can sometimes transform
exponential-time algorithms into polynomial-time algorithms.
Like dynamic-programming algorithms, greedy algorithms typically apply to
optimization problems in which we make a set of choices in order to arrive at an
optimal solution. The idea of a greedy algorithm is to make each choice in a locally
optimal manner. A simple example is coin-changing: to minimize the number of
U.S. coins needed to make change for a given amount, we can repeatedly select
the largest-denomination coin that is not larger than the amount that remains. A
greedy approach provides an optimal solution for many such problems much more
quickly than would a dynamic-programming approach. We cannot always easily
tell whether a greedy approach will be effective, however. Chapter 16 introduces

358

Part IV Advanced Design and Analysis Techniques

matroid theory, which provides a mathematical basis that can help us to show that
a greedy algorithm yields an optimal solution.
We use amortized analysis to analyze certain algorithms that perform a sequence
of similar operations. Instead of bounding the cost of the sequence of operations
by bounding the actual cost of each operation separately, an amortized analysis
provides a bound on the actual cost of the entire sequence. One advantage of this
approach is that although some operations might be expensive, many others might
be cheap. In other words, many of the operations might run in well under the worstcase time. Amortized analysis is not just an analysis tool, however; it is also a way
of thinking about the design of algorithms, since the design of an algorithm and the
analysis of its running time are often closely intertwined. Chapter 17 introduces
three ways to perform an amortized analysis of an algorithm.

15

Dynamic Programming

Dynamic programming, like the divide-and-conquer method, solves problems by
combining the solutions to subproblems. (“Programming” in this context refers
to a tabular method, not to writing computer code.) As we saw in Chapters 2
and 4, divide-and-conquer algorithms partition the problem into disjoint subproblems, solve the subproblems recursively, and then combine their solutions to solve
the original problem. In contrast, dynamic programming applies when the subproblems overlap—that is, when subproblems share subsubproblems. In this context,
a divide-and-conquer algorithm does more work than necessary, repeatedly solving the common subsubproblems. A dynamic-programming algorithm solves each
subsubproblem just once and then saves its answer in a table, thereby avoiding the
work of recomputing the answer every time it solves each subsubproblem.
We typically apply dynamic programming to optimization problems. Such problems can have many possible solutions. Each solution has a value, and we wish to
ﬁnd a solution with the optimal (minimum or maximum) value. We call such a
solution an optimal solution to the problem, as opposed to the optimal solution,
since there may be several solutions that achieve the optimal value.
When developing a dynamic-programming algorithm, we follow a sequence of
four steps:
1. Characterize the structure of an optimal solution.
2. Recursively deﬁne the value of an optimal solution.
3. Compute the value of an optimal solution, typically in a bottom-up fashion.
4. Construct an optimal solution from computed information.
Steps 1–3 form the basis of a dynamic-programming solution to a problem. If we
need only the value of an optimal solution, and not the solution itself, then we
can omit step 4. When we do perform step 4, we sometimes maintain additional
information during step 3 so that we can easily construct an optimal solution.
The sections that follow use the dynamic-programming method to solve some
optimization problems. Section 15.1 examines the problem of cutting a rod into

360

Chapter 15 Dynamic Programming

rods of smaller length in way that maximizes their total value. Section 15.2 asks
how we can multiply a chain of matrices while performing the fewest total scalar
multiplications. Given these examples of dynamic programming, Section 15.3 discusses two key characteristics that a problem must have for dynamic programming
to be a viable solution technique. Section 15.4 then shows how to ﬁnd the longest
common subsequence of two sequences via dynamic programming. Finally, Section 15.5 uses dynamic programming to construct binary search trees that are optimal, given a known distribution of keys to be looked up.

15.1 Rod cutting
Our ﬁrst example uses dynamic programming to solve a simple problem in deciding where to cut steel rods. Serling Enterprises buys long steel rods and cuts them
into shorter rods, which it then sells. Each cut is free. The management of Serling
Enterprises wants to know the best way to cut up the rods.
We assume that we know, for i D 1; 2; : : :, the price pi in dollars that Serling
Enterprises charges for a rod of length i inches. Rod lengths are always an integral
number of inches. Figure 15.1 gives a sample price table.
The rod-cutting problem is the following. Given a rod of length n inches and a
table of prices pi for i D 1; 2; : : : ; n, determine the maximum revenue rn obtainable by cutting up the rod and selling the pieces. Note that if the price pn for a rod
of length n is large enough, an optimal solution may require no cutting at all.
Consider the case when n D 4. Figure 15.2 shows all the ways to cut up a rod
of 4 inches in length, including the way with no cuts at all. We see that cutting a
4-inch rod into two 2-inch pieces produces revenue p2 C p2 D 5 C 5 D 10, which
is optimal.
We can cut up a rod of length n in 2n1 different ways, since we have an independent option of cutting, or not cutting, at distance i inches from the left end,

length i
price pi

1
1

2
5

3
8

4
9

5
10

6
17

7
17

8
20

9
24

10
30

Figure 15.1 A sample price table for rods. Each rod of length i inches earns the company pi
dollars of revenue.

15.1 Rod cutting

9

1

(a)
1

1

361

8

5

(b)
5

(e)

1

5

5

8

(c)
1

(f)

5

1

(g)

1

(d)
1

1

1

1

1

(h)

Figure 15.2 The 8 possible ways of cutting up a rod of length 4. Above each piece is the
value of that piece, according to the sample price chart of Figure 15.1. The optimal strategy is
part (c)—cutting the rod into two pieces of length 2—which has total value 10.

for i D 1; 2; : : : ; n  1.1 We denote a decomposition into pieces using ordinary
additive notation, so that 7 D 2 C 2 C 3 indicates that a rod of length 7 is cut into
three pieces—two of length 2 and one of length 3. If an optimal solution cuts the
rod into k pieces, for some 1  k  n, then an optimal decomposition
n D i1 C i2 C    C ik
of the rod into pieces of lengths i1 , i2 , . . . , ik provides maximum corresponding
revenue
rn D pi 1 C pi 2 C    C pi k :
For our sample problem, we can determine the optimal revenue ﬁgures ri , for
i D 1; 2; : : : ; 10, by inspection, with the corresponding optimal decompositions

1 If

we required the pieces to be cut in order of nondecreasing size, there would be fewer ways
to consider. For n D 4, we would consider only 5 such ways: parts (a), (b), (c), (e), and (h)
in p
Figure 15.2. The number of ways is called the partition function; it is approximately equal to
p
e  2n=3 =4n 3. This quantity is less than 2n1 , but still much greater than any polynomial in n.
We shall not pursue this line of inquiry further, however.

362

Chapter 15 Dynamic Programming

r1
r2
r3
r4
r5
r6
r7
r8
r9
r10

D
D
D
D
D
D
D
D
D
D

1
5
8
10
13
17
18
22
25
30

from solution 1 D 1 (no cuts) ;
from solution 2 D 2 (no cuts) ;
from solution 3 D 3 (no cuts) ;
from solution 4 D 2 C 2 ;
from solution 5 D 2 C 3 ;
from solution 6 D 6 (no cuts) ;
from solution 7 D 1 C 6 or 7 D 2 C 2 C 3 ;
from solution 8 D 2 C 6 ;
from solution 9 D 3 C 6 ;
from solution 10 D 10 (no cuts) :

More generally, we can frame the values rn for n  1 in terms of optimal revenues from shorter rods:
rn D max .pn ; r1 C rn1 ; r2 C rn2 ; : : : ; rn1 C r1 / :

(15.1)

The ﬁrst argument, pn , corresponds to making no cuts at all and selling the rod of
length n as is. The other n  1 arguments to max correspond to the maximum revenue obtained by making an initial cut of the rod into two pieces of size i and n  i,
for each i D 1; 2; : : : ; n  1, and then optimally cutting up those pieces further,
obtaining revenues ri and rni from those two pieces. Since we don’t know ahead
of time which value of i optimizes revenue, we have to consider all possible values
for i and pick the one that maximizes revenue. We also have the option of picking
no i at all if we can obtain more revenue by selling the rod uncut.
Note that to solve the original problem of size n, we solve smaller problems of
the same type, but of smaller sizes. Once we make the ﬁrst cut, we may consider
the two pieces as independent instances of the rod-cutting problem. The overall
optimal solution incorporates optimal solutions to the two related subproblems,
maximizing revenue from each of those two pieces. We say that the rod-cutting
problem exhibits optimal substructure: optimal solutions to a problem incorporate
optimal solutions to related subproblems, which we may solve independently.
In a related, but slightly simpler, way to arrange a recursive structure for the rodcutting problem, we view a decomposition as consisting of a ﬁrst piece of length i
cut off the left-hand end, and then a right-hand remainder of length n  i. Only
the remainder, and not the ﬁrst piece, may be further divided. We may view every
decomposition of a length-n rod in this way: as a ﬁrst piece followed by some
decomposition of the remainder. When doing so, we can couch the solution with
no cuts at all as saying that the ﬁrst piece has size i D n and revenue pn and that
the remainder has size 0 with corresponding revenue r0 D 0. We thus obtain the
following simpler version of equation (15.1):
rn D max .pi C rni / :
1i n

(15.2)

15.1 Rod cutting

363

In this formulation, an optimal solution embodies the solution to only one related
subproblem—the remainder—rather than two.
Recursive top-down implementation
The following procedure implements the computation implicit in equation (15.2)
in a straightforward, top-down, recursive manner.
C UT-ROD .p; n/
1 if n == 0
2
return 0
3 q D 1
4 for i D 1 to n
5
q D max.q; pŒi C C UT-ROD .p; n  i//
6 return q
Procedure C UT-ROD takes as input an array pŒ1 : : n of prices and an integer n,
and it returns the maximum revenue possible for a rod of length n. If n D 0, no
revenue is possible, and so C UT-ROD returns 0 in line 2. Line 3 initializes the
maximum revenue q to 1, so that the for loop in lines 4–5 correctly computes
q D max1i n .pi C C UT-ROD .p; n  i//; line 6 then returns this value. A simple
induction on n proves that this answer is equal to the desired answer rn , using
equation (15.2).
If you were to code up C UT-ROD in your favorite programming language and run
it on your computer, you would ﬁnd that once the input size becomes moderately
large, your program would take a long time to run. For n D 40, you would ﬁnd that
your program takes at least several minutes, and most likely more than an hour. In
fact, you would ﬁnd that each time you increase n by 1, your program’s running
time would approximately double.
Why is C UT-ROD so inefﬁcient? The problem is that C UT-ROD calls itself
recursively over and over again with the same parameter values; it solves the
same subproblems repeatedly. Figure 15.3 illustrates what happens for n D 4:
C UT-ROD .p; n/ calls C UT-ROD .p; n  i/ for i D 1; 2; : : : ; n. Equivalently,
C UT-ROD .p; n/ calls C UT-ROD .p; j / for each j D 0; 1; : : : ; n  1. When this
process unfolds recursively, the amount of work done, as a function of n, grows
explosively.
To analyze the running time of C UT-ROD, let T .n/ denote the total number of
calls made to C UT-ROD when called with its second parameter equal to n. This
expression equals the number of nodes in a subtree whose root is labeled n in the
recursion tree. The count includes the initial call at its root. Thus, T .0/ D 1 and

364

Chapter 15 Dynamic Programming

4
2

3
2
1

1
0

0

0

1

1
0

0

0

0

0

Figure 15.3 The recursion tree showing recursive calls resulting from a call C UT-ROD.p; n/ for
n D 4. Each node label gives the size n of the corresponding subproblem, so that an edge from
a parent with label s to a child with label t corresponds to cutting off an initial piece of size s  t
and leaving a remaining subproblem of size t. A path from the root to a leaf corresponds to one of
the 2n1 ways of cutting up a rod of length n. In general, this recursion tree has 2n nodes and 2n1
leaves.

T .n/ D 1 C

n1
X

T .j / :

(15.3)

j D0

The initial 1 is for the call at the root, and the term T .j / counts the number of calls
(including recursive calls) due to the call C UT-ROD .p; n  i/, where j D n  i.
As Exercise 15.1-1 asks you to show,
T .n/ D 2n ;

(15.4)

and so the running time of C UT-ROD is exponential in n.
In retrospect, this exponential running time is not so surprising. C UT-ROD explicitly considers all the 2n1 possible ways of cutting up a rod of length n. The
tree of recursive calls has 2n1 leaves, one for each possible way of cutting up the
rod. The labels on the simple path from the root to a leaf give the sizes of each
remaining right-hand piece before making each cut. That is, the labels give the
corresponding cut points, measured from the right-hand end of the rod.
Using dynamic programming for optimal rod cutting
We now show how to convert C UT-ROD into an efﬁcient algorithm, using dynamic
programming.
The dynamic-programming method works as follows. Having observed that a
naive recursive solution is inefﬁcient because it solves the same subproblems repeatedly, we arrange for each subproblem to be solved only once, saving its solution. If we need to refer to this subproblem’s solution again later, we can just look it

15.1 Rod cutting

365

up, rather than recompute it. Dynamic programming thus uses additional memory
to save computation time; it serves an example of a time-memory trade-off. The
savings may be dramatic: an exponential-time solution may be transformed into a
polynomial-time solution. A dynamic-programming approach runs in polynomial
time when the number of distinct subproblems involved is polynomial in the input
size and we can solve each such subproblem in polynomial time.
There are usually two equivalent ways to implement a dynamic-programming
approach. We shall illustrate both of them with our rod-cutting example.
The ﬁrst approach is top-down with memoization.2 In this approach, we write
the procedure recursively in a natural manner, but modiﬁed to save the result of
each subproblem (usually in an array or hash table). The procedure now ﬁrst checks
to see whether it has previously solved this subproblem. If so, it returns the saved
value, saving further computation at this level; if not, the procedure computes the
value in the usual manner. We say that the recursive procedure has been memoized;
it “remembers” what results it has computed previously.
The second approach is the bottom-up method. This approach typically depends
on some natural notion of the “size” of a subproblem, such that solving any particular subproblem depends only on solving “smaller” subproblems. We sort the
subproblems by size and solve them in size order, smallest ﬁrst. When solving a
particular subproblem, we have already solved all of the smaller subproblems its
solution depends upon, and we have saved their solutions. We solve each subproblem only once, and when we ﬁrst see it, we have already solved all of its
prerequisite subproblems.
These two approaches yield algorithms with the same asymptotic running time,
except in unusual circumstances where the top-down approach does not actually
recurse to examine all possible subproblems. The bottom-up approach often has
much better constant factors, since it has less overhead for procedure calls.
Here is the the pseudocode for the top-down C UT-ROD procedure, with memoization added:
M EMOIZED -C UT-ROD .p; n/
1 let rŒ0 : : n be a new array
2 for i D 0 to n
3
rŒi D 1
4 return M EMOIZED -C UT-ROD -AUX .p; n; r/

2 This

is not a misspelling. The word really is memoization, not memorization. Memoization comes
from memo, since the technique consists of recording a value so that we can look it up later.

366

Chapter 15 Dynamic Programming

M EMOIZED -C UT-ROD -AUX .p; n; r/
1 if rŒn  0
2
return rŒn
3 if n == 0
4
q D0
5 else q D 1
6
for i D 1 to n
7
q D max.q; pŒi C M EMOIZED -C UT-ROD -AUX .p; n  i; r//
8 rŒn D q
9 return q
Here, the main procedure M EMOIZED -C UT-ROD initializes a new auxiliary array rŒ0 : : n with the value 1, a convenient choice with which to denote “unknown.” (Known revenue values are always nonnegative.) It then calls its helper
routine, M EMOIZED -C UT-ROD -AUX.
The procedure M EMOIZED -C UT-ROD -AUX is just the memoized version of our
previous procedure, C UT-ROD. It ﬁrst checks in line 1 to see whether the desired
value is already known and, if it is, then line 2 returns it. Otherwise, lines 3–7
compute the desired value q in the usual manner, line 8 saves it in rŒn, and line 9
returns it.
The bottom-up version is even simpler:
B OTTOM -U P -C UT-ROD .p; n/
1 let rŒ0 : : n be a new array
2 rŒ0 D 0
3 for j D 1 to n
4
q D 1
5
for i D 1 to j
6
q D max.q; pŒi C rŒj  i/
7
rŒj  D q
8 return rŒn
For the bottom-up dynamic-programming approach, B OTTOM -U P -C UT-ROD
uses the natural ordering of the subproblems: a problem of size i is “smaller”
than a subproblem of size j if i < j . Thus, the procedure solves subproblems of
sizes j D 0; 1; : : : ; n, in that order.
Line 1 of procedure B OTTOM -U P -C UT-ROD creates a new array rŒ0 : : n in
which to save the results of the subproblems, and line 2 initializes rŒ0 to 0, since
a rod of length 0 earns no revenue. Lines 3–6 solve each subproblem of size j , for
j D 1; 2; : : : ; n, in order of increasing size. The approach used to solve a problem
of a particular size j is the same as that used by C UT-ROD, except that line 6 now

15.1 Rod cutting

367

4
3
2
1
0

Figure 15.4 The subproblem graph for the rod-cutting problem with n D 4. The vertex labels
give the sizes of the corresponding subproblems. A directed edge .x; y/ indicates that we need a
solution to subproblem y when solving subproblem x. This graph is a reduced version of the tree of
Figure 15.3, in which all nodes with the same label are collapsed into a single vertex and all edges
go from parent to child.

directly references array entry rŒj  i instead of making a recursive call to solve
the subproblem of size j  i. Line 7 saves in rŒj  the solution to the subproblem
of size j . Finally, line 8 returns rŒn, which equals the optimal value rn .
The bottom-up and top-down versions have the same asymptotic running time.
The running time of procedure B OTTOM -U P -C UT-ROD is ‚.n2 /, due to its
doubly-nested loop structure. The number of iterations of its inner for loop, in
lines 5–6, forms an arithmetic series. The running time of its top-down counterpart,
M EMOIZED -C UT-ROD, is also ‚.n2 /, although this running time may be a little
harder to see. Because a recursive call to solve a previously solved subproblem
returns immediately, M EMOIZED -C UT-ROD solves each subproblem just once. It
solves subproblems for sizes 0; 1; : : : ; n. To solve a subproblem of size n, the for
loop of lines 6–7 iterates n times. Thus, the total number of iterations of this for
loop, over all recursive calls of M EMOIZED -C UT-ROD, forms an arithmetic series,
giving a total of ‚.n2 / iterations, just like the inner for loop of B OTTOM -U P C UT-ROD. (We actually are using a form of aggregate analysis here. We shall see
aggregate analysis in detail in Section 17.1.)
Subproblem graphs
When we think about a dynamic-programming problem, we should understand the
set of subproblems involved and how subproblems depend on one another.
The subproblem graph for the problem embodies exactly this information. Figure 15.4 shows the subproblem graph for the rod-cutting problem with n D 4. It
is a directed graph, containing one vertex for each distinct subproblem. The sub-

368

Chapter 15 Dynamic Programming

problem graph has a directed edge from the vertex for subproblem x to the vertex
for subproblem y if determining an optimal solution for subproblem x involves
directly considering an optimal solution for subproblem y. For example, the subproblem graph contains an edge from x to y if a top-down recursive procedure for
solving x directly calls itself to solve y. We can think of the subproblem graph
as a “reduced” or “collapsed” version of the recursion tree for the top-down recursive method, in which we coalesce all nodes for the same subproblem into a single
vertex and direct all edges from parent to child.
The bottom-up method for dynamic programming considers the vertices of the
subproblem graph in such an order that we solve the subproblems y adjacent to
a given subproblem x before we solve subproblem x. (Recall from Section B.4
that the adjacency relation is not necessarily symmetric.) Using the terminology
from Chapter 22, in a bottom-up dynamic-programming algorithm, we consider the
vertices of the subproblem graph in an order that is a “reverse topological sort,” or
a “topological sort of the transpose” (see Section 22.4) of the subproblem graph. In
other words, no subproblem is considered until all of the subproblems it depends
upon have been solved. Similarly, using notions from the same chapter, we can
view the top-down method (with memoization) for dynamic programming as a
“depth-ﬁrst search” of the subproblem graph (see Section 22.3).
The size of the subproblem graph G D .V; E/ can help us determine the running
time of the dynamic programming algorithm. Since we solve each subproblem just
once, the running time is the sum of the times needed to solve each subproblem.
Typically, the time to compute the solution to a subproblem is proportional to the
degree (number of outgoing edges) of the corresponding vertex in the subproblem
graph, and the number of subproblems is equal to the number of vertices in the subproblem graph. In this common case, the running time of dynamic programming
is linear in the number of vertices and edges.
Reconstructing a solution
Our dynamic-programming solutions to the rod-cutting problem return the value of
an optimal solution, but they do not return an actual solution: a list of piece sizes.
We can extend the dynamic-programming approach to record not only the optimal
value computed for each subproblem, but also a choice that led to the optimal
value. With this information, we can readily print an optimal solution.
Here is an extended version of B OTTOM -U P -C UT-ROD that computes, for each
rod size j , not only the maximum revenue rj , but also sj , the optimal size of the
ﬁrst piece to cut off:

15.1 Rod cutting

369

E XTENDED -B OTTOM -U P -C UT-ROD .p; n/
1 let rŒ0 : : n and sŒ0 : : n be new arrays
2 rŒ0 D 0
3 for j D 1 to n
4
q D 1
5
for i D 1 to j
6
if q < pŒi C rŒj  i
7
q D pŒi C rŒj  i
8
sŒj  D i
9
rŒj  D q
10 return r and s
This procedure is similar to B OTTOM -U P -C UT-ROD, except that it creates the array s in line 1, and it updates sŒj  in line 8 to hold the optimal size i of the ﬁrst
piece to cut off when solving a subproblem of size j .
The following procedure takes a price table p and a rod size n, and it calls
E XTENDED -B OTTOM -U P -C UT-ROD to compute the array sŒ1 : : n of optimal
ﬁrst-piece sizes and then prints out the complete list of piece sizes in an optimal
decomposition of a rod of length n:
P RINT-C UT-ROD -S OLUTION .p; n/
1 .r; s/ D E XTENDED -B OTTOM -U P -C UT-ROD .p; n/
2 while n > 0
3
print sŒn
4
n D n  sŒn
In our rod-cutting example, the call E XTENDED -B OTTOM -U P -C UT-ROD .p; 10/
would return the following arrays:
0 1 2 3 4 5 6 7 8 9 10
i
rŒi 0 1 5 8 10 13 17 18 22 25 30
sŒi 0 1 2 3 2 2 6 1 2 3 10
A call to P RINT-C UT-ROD -S OLUTION .p; 10/ would print just 10, but a call with
n D 7 would print the cuts 1 and 6, corresponding to the ﬁrst optimal decomposition for r7 given earlier.
Exercises
15.1-1
Show that equation (15.4) follows from equation (15.3) and the initial condition
T .0/ D 1.

370

Chapter 15 Dynamic Programming

15.1-2
Show, by means of a counterexample, that the following “greedy” strategy does
not always determine an optimal way to cut rods. Deﬁne the density of a rod of
length i to be pi =i, that is, its value per inch. The greedy strategy for a rod of
length n cuts off a ﬁrst piece of length i, where 1  i  n, having maximum
density. It then continues by applying the greedy strategy to the remaining piece of
length n  i.
15.1-3
Consider a modiﬁcation of the rod-cutting problem in which, in addition to a
price pi for each rod, each cut incurs a ﬁxed cost of c. The revenue associated with
a solution is now the sum of the prices of the pieces minus the costs of making the
cuts. Give a dynamic-programming algorithm to solve this modiﬁed problem.
15.1-4
Modify M EMOIZED -C UT-ROD to return not only the value but the actual solution,
too.
15.1-5
The Fibonacci numbers are deﬁned by recurrence (3.22). Give an O.n/-time
dynamic-programming algorithm to compute the nth Fibonacci number. Draw the
subproblem graph. How many vertices and edges are in the graph?

15.2 Matrix-chain multiplication
Our next example of dynamic programming is an algorithm that solves the problem
of matrix-chain multiplication. We are given a sequence (chain) hA1 ; A2 ; : : : ; An i
of n matrices to be multiplied, and we wish to compute the product
A1 A2    An :

(15.5)

We can evaluate the expression (15.5) using the standard algorithm for multiplying pairs of matrices as a subroutine once we have parenthesized it to resolve all
ambiguities in how the matrices are multiplied together. Matrix multiplication is
associative, and so all parenthesizations yield the same product. A product of matrices is fully parenthesized if it is either a single matrix or the product of two fully
parenthesized matrix products, surrounded by parentheses. For example, if the
chain of matrices is hA1 ; A2 ; A3 ; A4 i, then we can fully parenthesize the product
A1 A2 A3 A4 in ﬁve distinct ways:

15.2 Matrix-chain multiplication

371

.A1 .A2 .A3 A4 /// ;
.A1 ..A2 A3 /A4 // ;
..A1 A2 /.A3 A4 // ;
..A1 .A2 A3 //A4 / ;
...A1 A2 /A3 /A4 / :
How we parenthesize a chain of matrices can have a dramatic impact on the cost
of evaluating the product. Consider ﬁrst the cost of multiplying two matrices. The
standard algorithm is given by the following pseudocode, which generalizes the
S QUARE -M ATRIX -M ULTIPLY procedure from Section 4.2. The attributes rows
and columns are the numbers of rows and columns in a matrix.
M ATRIX -M ULTIPLY .A; B/
1 if A:columns ¤ B:rows
2
error “incompatible dimensions”
3 else let C be a new A:rows B:columns matrix
4
for i D 1 to A:rows
5
for j D 1 to B:columns
6
cij D 0
7
for k D 1 to A:columns
8
cij D cij C ai k  bkj
9
return C
We can multiply two matrices A and B only if they are compatible: the number of
columns of A must equal the number of rows of B. If A is a p q matrix and B is
a q r matrix, the resulting matrix C is a p r matrix. The time to compute C is
dominated by the number of scalar multiplications in line 8, which is pqr. In what
follows, we shall express costs in terms of the number of scalar multiplications.
To illustrate the different costs incurred by different parenthesizations of a matrix
product, consider the problem of a chain hA1 ; A2 ; A3 i of three matrices. Suppose
that the dimensions of the matrices are 10 100, 100 5, and 5 50, respectively. If we multiply according to the parenthesization ..A1 A2 /A3 /, we perform
10  100  5 D 5000 scalar multiplications to compute the 10 5 matrix product A1 A2 , plus another 10  5  50 D 2500 scalar multiplications to multiply this
matrix by A3 , for a total of 7500 scalar multiplications. If instead we multiply
according to the parenthesization .A1 .A2 A3 //, we perform 100  5  50 D 25,000
scalar multiplications to compute the 100 50 matrix product A2 A3 , plus another
10  100  50 D 50,000 scalar multiplications to multiply A1 by this matrix, for a
total of 75,000 scalar multiplications. Thus, computing the product according to
the ﬁrst parenthesization is 10 times faster.
We state the matrix-chain multiplication problem as follows: given a chain
hA1 ; A2 ; : : : ; An i of n matrices, where for i D 1; 2; : : : ; n, matrix Ai has dimension

372

Chapter 15 Dynamic Programming

pi 1 pi , fully parenthesize the product A1 A2    An in a way that minimizes the
number of scalar multiplications.
Note that in the matrix-chain multiplication problem, we are not actually multiplying matrices. Our goal is only to determine an order for multiplying matrices
that has the lowest cost. Typically, the time invested in determining this optimal
order is more than paid for by the time saved later on when actually performing the
matrix multiplications (such as performing only 7500 scalar multiplications instead
of 75,000).
Counting the number of parenthesizations
Before solving the matrix-chain multiplication problem by dynamic programming,
let us convince ourselves that exhaustively checking all possible parenthesizations
does not yield an efﬁcient algorithm. Denote the number of alternative parenthesizations of a sequence of n matrices by P .n/. When n D 1, we have just one
matrix and therefore only one way to fully parenthesize the matrix product. When
n  2, a fully parenthesized matrix product is the product of two fully parenthesized matrix subproducts, and the split between the two subproducts may occur
between the kth and .k C 1/st matrices for any k D 1; 2; : : : ; n  1. Thus, we
obtain the recurrence

1

P .n/ D

n1
X

if n D 1 ;
P .k/P .n  k/ if n  2 :

(15.6)

kD1

Problem 12-4 asked you to show that the solution to a similar recurrence is the
sequence of Catalan numbers, which grows as .4n =n3=2 /. A simpler exercise
(see Exercise 15.2-3) is to show that the solution to the recurrence (15.6) is .2n /.
The number of solutions is thus exponential in n, and the brute-force method of
exhaustive search makes for a poor strategy when determining how to optimally
parenthesize a matrix chain.
Applying dynamic programming
We shall use the dynamic-programming method to determine how to optimally
parenthesize a matrix chain. In so doing, we shall follow the four-step sequence
that we stated at the beginning of this chapter:
1. Characterize the structure of an optimal solution.
2. Recursively deﬁne the value of an optimal solution.
3. Compute the value of an optimal solution.

15.2 Matrix-chain multiplication

373

4. Construct an optimal solution from computed information.
We shall go through these steps in order, demonstrating clearly how we apply each
step to the problem.
Step 1: The structure of an optimal parenthesization
For our ﬁrst step in the dynamic-programming paradigm, we ﬁnd the optimal substructure and then use it to construct an optimal solution to the problem from optimal solutions to subproblems. In the matrix-chain multiplication problem, we can
perform this step as follows. For convenience, let us adopt the notation Ai ::j , where
i  j , for the matrix that results from evaluating the product Ai Ai C1    Aj . Observe that if the problem is nontrivial, i.e., i < j , then to parenthesize the product
Ai Ai C1    Aj , we must split the product between Ak and AkC1 for some integer k
in the range i  k < j . That is, for some value of k, we ﬁrst compute the matrices
Ai ::k and AkC1::j and then multiply them together to produce the ﬁnal product Ai ::j .
The cost of parenthesizing this way is the cost of computing the matrix Ai ::k , plus
the cost of computing AkC1::j , plus the cost of multiplying them together.
The optimal substructure of this problem is as follows. Suppose that to optimally parenthesize Ai Ai C1    Aj , we split the product between Ak and AkC1 .
Then the way we parenthesize the “preﬁx” subchain Ai Ai C1    Ak within this
optimal parenthesization of Ai Ai C1    Aj must be an optimal parenthesization of
Ai Ai C1    Ak . Why? If there were a less costly way to parenthesize Ai Ai C1    Ak ,
then we could substitute that parenthesization in the optimal parenthesization
of Ai Ai C1    Aj to produce another way to parenthesize Ai Ai C1    Aj whose cost
was lower than the optimum: a contradiction. A similar observation holds for how
we parenthesize the subchain AkC1 AkC2    Aj in the optimal parenthesization of
Ai Ai C1    Aj : it must be an optimal parenthesization of AkC1 AkC2    Aj .
Now we use our optimal substructure to show that we can construct an optimal
solution to the problem from optimal solutions to subproblems. We have seen that
any solution to a nontrivial instance of the matrix-chain multiplication problem
requires us to split the product, and that any optimal solution contains within it optimal solutions to subproblem instances. Thus, we can build an optimal solution to
an instance of the matrix-chain multiplication problem by splitting the problem into
two subproblems (optimally parenthesizing Ai Ai C1    Ak and AkC1 AkC2    Aj ),
ﬁnding optimal solutions to subproblem instances, and then combining these optimal subproblem solutions. We must ensure that when we search for the correct
place to split the product, we have considered all possible places, so that we are
sure of having examined the optimal one.

374

Chapter 15 Dynamic Programming

Step 2: A recursive solution
Next, we deﬁne the cost of an optimal solution recursively in terms of the optimal
solutions to subproblems. For the matrix-chain multiplication problem, we pick as
our subproblems the problems of determining the minimum cost of parenthesizing
Ai Ai C1    Aj for 1  i  j  n. Let mŒi; j  be the minimum number of scalar
multiplications needed to compute the matrix Ai ::j ; for the full problem, the lowestcost way to compute A1::n would thus be mŒ1; n.
We can deﬁne mŒi; j  recursively as follows. If i D j , the problem is trivial;
the chain consists of just one matrix Ai ::i D Ai , so that no scalar multiplications
are necessary to compute the product. Thus, mŒi; i D 0 for i D 1; 2; : : : ; n. To
compute mŒi; j  when i < j , we take advantage of the structure of an optimal
solution from step 1. Let us assume that to optimally parenthesize, we split the
product Ai Ai C1    Aj between Ak and AkC1 , where i  k < j . Then, mŒi; j 
equals the minimum cost for computing the subproducts Ai ::k and AkC1::j , plus the
cost of multiplying these two matrices together. Recalling that each matrix Ai is
pi 1 pi , we see that computing the matrix product Ai ::k AkC1::j takes pi 1 pk pj
scalar multiplications. Thus, we obtain
mŒi; j  D mŒi; k C mŒk C 1; j  C pi 1 pk pj :
This recursive equation assumes that we know the value of k, which we do not.
There are only j i possible values for k, however, namely k D i; i C1; : : : ; j 1.
Since the optimal parenthesization must use one of these values for k, we need only
check them all to ﬁnd the best. Thus, our recursive deﬁnition for the minimum cost
of parenthesizing the product Ai Ai C1    Aj becomes
(
0
if i D j ;
mŒi; j  D
(15.7)
min fmŒi; k C mŒk C 1; j  C pi 1 pk pj g if i < j :
i k<j

The mŒi; j  values give the costs of optimal solutions to subproblems, but they
do not provide all the information we need to construct an optimal solution. To
help us do so, we deﬁne sŒi; j  to be a value of k at which we split the product
Ai Ai C1    Aj in an optimal parenthesization. That is, sŒi; j  equals a value k such
that mŒi; j  D mŒi; k C mŒk C 1; j  C pi 1 pk pj .
Step 3: Computing the optimal costs
At this point, we could easily write a recursive algorithm based on recurrence (15.7)
to compute the minimum cost mŒ1; n for multiplying A1 A2    An . As we saw for
the rod-cutting problem, and as we shall see in Section 15.3, this recursive algorithm takes exponential time, which is no better than the brute-force method of
checking each way of parenthesizing the product.

15.2 Matrix-chain multiplication

375

Observe that we have relatively few distinct subproblems: one subproblem for
each choice of i and j satisfying 1  i  j  n, or n2 C n D ‚.n2 / in all.
A recursive algorithm may encounter each subproblem many times in different
branches of its recursion tree. This property of overlapping subproblems is the
second hallmark of when dynamic programming applies (the ﬁrst hallmark being
optimal substructure).
Instead of computing the solution to recurrence (15.7) recursively, we compute
the optimal cost by using a tabular, bottom-up approach. (We present the corresponding top-down approach using memoization in Section 15.3.)
We shall implement the tabular, bottom-up method in the procedure M ATRIX C HAIN -O RDER, which appears below. This procedure assumes that matrix Ai
has dimensions pi 1 pi for i D 1; 2; : : : ; n. Its input is a sequence p D
hp0 ; p1 ; : : : ; pn i, where p:length D n C 1. The procedure uses an auxiliary
table mŒ1 : : n; 1 : : n for storing the mŒi; j  costs and another auxiliary table
sŒ1 : : n  1; 2 : : n that records which index of k achieved the optimal cost in computing mŒi; j . We shall use the table s to construct an optimal solution.
In order to implement the bottom-up approach, we must determine which entries
of the table we refer to when computing mŒi; j . Equation (15.7) shows that the
cost mŒi; j  of computing a matrix-chain product of j i C1 matrices depends only
on the costs of computing matrix-chain products of fewer than j  i C 1 matrices.
That is, for k D i; i C 1; : : : ; j  1, the matrix Ai ::k is a product of k  i C 1 <
j  i C 1 matrices and the matrix AkC1::j is a product of j  k < j  i C 1
matrices. Thus, the algorithm should ﬁll in the table m in a manner that corresponds
to solving the parenthesization problem on matrix chains of increasing length. For
the subproblem of optimally parenthesizing the chain Ai Ai C1    Aj , we consider
the subproblem size to be the length j  i C 1 of the chain.
M ATRIX -C HAIN -O RDER .p/
1 n D p:length  1
2 let mŒ1 : : n; 1 : : n and sŒ1 : : n  1; 2 : : n be new tables
3 for i D 1 to n
4
mŒi; i D 0
5 for l D 2 to n
// l is the chain length
6
for i D 1 to n  l C 1
7
j D i Cl 1
8
mŒi; j  D 1
9
for k D i to j  1
10
q D mŒi; k C mŒk C 1; j  C pi 1 pk pj
11
if q < mŒi; j 
12
mŒi; j  D q
13
sŒi; j  D k
14 return m and s

376

Chapter 15 Dynamic Programming

m

s

6

1

6

15,125

j

5
2
11,875 10,500

4

9,375

3

7,875

1

2
15,750

7,125

4,375

2,625

3

5,375

2,500
750

3

4

4

3

3

3,500

1,000

5

j

i

5

5,000

1

6

0

0

0

0

0

0

A1

A2

A3

A4

A5

A6

1

2

1
3

2
3

3
3

2

3
3

3

i
3
4
5

4

5
5

Figure 15.5 The m and s tables computed by M ATRIX -C HAIN -O RDER for n D 6 and the following matrix dimensions:
matrix
dimension

A1
30 35

A2
35 15

A3
15 5

5

A4
10

A5
10 20

A6
20 25

The tables are rotated so that the main diagonal runs horizontally. The m table uses only the main
diagonal and upper triangle, and the s table uses only the upper triangle. The minimum number of
scalar multiplications to multiply the 6 matrices is mŒ1; 6 D 15,125. Of the darker entries, the pairs
that have the same shading are taken together in line 10 when computing
8
D 13,000 ;
ˆ
<mŒ2; 2 C mŒ3; 5 C p1 p2 p5 D 0 C 2500 C 35  15  20
mŒ2; 5 D min mŒ2; 3 C mŒ4; 5 C p1 p3 p5 D 2625 C 1000 C 35  5  20 D 7125 ;
:̂
D 11,375
mŒ2; 4 C mŒ5; 5 C p1 p4 p5 D 4375 C 0 C 35  10  20
D 7125 :

The algorithm ﬁrst computes mŒi; i D 0 for i D 1; 2; : : : ; n (the minimum
costs for chains of length 1) in lines 3–4. It then uses recurrence (15.7) to compute
mŒi; i C 1 for i D 1; 2; : : : ; n  1 (the minimum costs for chains of length l D 2)
during the ﬁrst execution of the for loop in lines 5–13. The second time through the
loop, it computes mŒi; iC2 for i D 1; 2; : : : ; n2 (the minimum costs for chains of
length l D 3), and so forth. At each step, the mŒi; j  cost computed in lines 10–13
depends only on table entries mŒi; k and mŒk C 1; j  already computed.
Figure 15.5 illustrates this procedure on a chain of n D 6 matrices. Since
we have deﬁned mŒi; j  only for i  j , only the portion of the table m strictly
above the main diagonal is used. The ﬁgure shows the table rotated to make the
main diagonal run horizontally. The matrix chain is listed along the bottom. Using this layout, we can ﬁnd the minimum cost mŒi; j  for multiplying a subchain
Ai Ai C1    Aj of matrices at the intersection of lines running northeast from Ai and

15.2 Matrix-chain multiplication

377

northwest from Aj . Each horizontal row in the table contains the entries for matrix
chains of the same length. M ATRIX -C HAIN -O RDER computes the rows from bottom to top and from left to right within each row. It computes each entry mŒi; j 
using the products pi 1 pk pj for k D i; i C 1; : : : ; j  1 and all entries southwest
and southeast from mŒi; j .
A simple inspection of the nested loop structure of M ATRIX -C HAIN -O RDER
yields a running time of O.n3 / for the algorithm. The loops are nested three deep,
and each loop index (l, i, and k) takes on at most n1 values. Exercise 15.2-5 asks
you to show that the running time of this algorithm is in fact also .n3 /. The algorithm requires ‚.n2 / space to store the m and s tables. Thus, M ATRIX -C HAIN O RDER is much more efﬁcient than the exponential-time method of enumerating
all possible parenthesizations and checking each one.
Step 4: Constructing an optimal solution
Although M ATRIX -C HAIN -O RDER determines the optimal number of scalar multiplications needed to compute a matrix-chain product, it does not directly show
how to multiply the matrices. The table sŒ1 : : n  1; 2 : : n gives us the information we need to do so. Each entry sŒi; j  records a value of k such that an optimal parenthesization of Ai Ai C1    Aj splits the product between Ak and AkC1 .
Thus, we know that the ﬁnal matrix multiplication in computing A1::n optimally
is A1::sŒ1;n AsŒ1;nC1::n . We can determine the earlier matrix multiplications recursively, since sŒ1; sŒ1; n determines the last matrix multiplication when computing
A1::sŒ1;n and sŒsŒ1; n C 1; n determines the last matrix multiplication when computing AsŒ1;nC1::n . The following recursive procedure prints an optimal parenthesization of hAi ; Ai C1 ; : : : ; Aj i, given the s table computed by M ATRIX -C HAIN O RDER and the indices i and j . The initial call P RINT-O PTIMAL -PARENS .s; 1; n/
prints an optimal parenthesization of hA1 ; A2 ; : : : ; An i.
P RINT-O PTIMAL -PARENS .s; i; j /
1 if i == j
2
print “A”i
3 else print “(”
4
P RINT-O PTIMAL -PARENS .s; i; sŒi; j /
5
P RINT-O PTIMAL -PARENS .s; sŒi; j  C 1; j /
6
print “)”
In the example of Figure 15.5, the call P RINT-O PTIMAL -PARENS .s; 1; 6/ prints
the parenthesization ..A1 .A2 A3 //..A4 A5 /A6 //.

378

Chapter 15 Dynamic Programming

Exercises
15.2-1
Find an optimal parenthesization of a matrix-chain product whose sequence of
dimensions is h5; 10; 3; 12; 5; 50; 6i.
15.2-2
Give a recursive algorithm M ATRIX -C HAIN -M ULTIPLY .A; s; i; j / that actually
performs the optimal matrix-chain multiplication, given the sequence of matrices
hA1 ; A2 ; : : : ; An i, the s table computed by M ATRIX -C HAIN -O RDER, and the indices i and j . (The initial call would be M ATRIX -C HAIN -M ULTIPLY .A; s; 1; n/.)
15.2-3
Use the substitution method to show that the solution to the recurrence (15.6)
is .2n /.
15.2-4
Describe the subproblem graph for matrix-chain multiplication with an input chain
of length n. How many vertices does it have? How many edges does it have, and
which edges are they?
15.2-5
Let R.i; j / be the number of times that table entry mŒi; j  is referenced while
computing other table entries in a call of M ATRIX -C HAIN -O RDER. Show that the
total number of references for the entire table is
n X
n
X
i D1 j Di

R.i; j / D

n3  n
:
3

(Hint: You may ﬁnd equation (A.3) useful.)
15.2-6
Show that a full parenthesization of an n-element expression has exactly n1 pairs
of parentheses.

15.3 Elements of dynamic programming
Although we have just worked through two examples of the dynamic-programming
method, you might still be wondering just when the method applies. From an engineering perspective, when should we look for a dynamic-programming solution
to a problem? In this section, we examine the two key ingredients that an opti-

15.3 Elements of dynamic programming

379

mization problem must have in order for dynamic programming to apply: optimal
substructure and overlapping subproblems. We also revisit and discuss more fully
how memoization might help us take advantage of the overlapping-subproblems
property in a top-down recursive approach.
Optimal substructure
The ﬁrst step in solving an optimization problem by dynamic programming is to
characterize the structure of an optimal solution. Recall that a problem exhibits
optimal substructure if an optimal solution to the problem contains within it optimal solutions to subproblems. Whenever a problem exhibits optimal substructure,
we have a good clue that dynamic programming might apply. (As Chapter 16 discusses, it also might mean that a greedy strategy applies, however.) In dynamic
programming, we build an optimal solution to the problem from optimal solutions
to subproblems. Consequently, we must take care to ensure that the range of subproblems we consider includes those used in an optimal solution.
We discovered optimal substructure in both of the problems we have examined
in this chapter so far. In Section 15.1, we observed that the optimal way of cutting up a rod of length n (if we make any cuts at all) involves optimally cutting
up the two pieces resulting from the ﬁrst cut. In Section 15.2, we observed that
an optimal parenthesization of Ai Ai C1    Aj that splits the product between Ak
and AkC1 contains within it optimal solutions to the problems of parenthesizing
Ai Ai C1    Ak and AkC1 AkC2    Aj .
You will ﬁnd yourself following a common pattern in discovering optimal substructure:
1. You show that a solution to the problem consists of making a choice, such as
choosing an initial cut in a rod or choosing an index at which to split the matrix
chain. Making this choice leaves one or more subproblems to be solved.
2. You suppose that for a given problem, you are given the choice that leads to an
optimal solution. You do not concern yourself yet with how to determine this
choice. You just assume that it has been given to you.
3. Given this choice, you determine which subproblems ensue and how to best
characterize the resulting space of subproblems.
4. You show that the solutions to the subproblems used within an optimal solution
to the problem must themselves be optimal by using a “cut-and-paste” technique. You do so by supposing that each of the subproblem solutions is not
optimal and then deriving a contradiction. In particular, by “cutting out” the
nonoptimal solution to each subproblem and “pasting in” the optimal one, you
show that you can get a better solution to the original problem, thus contradicting your supposition that you already had an optimal solution. If an optimal

380

Chapter 15 Dynamic Programming

solution gives rise to more than one subproblem, they are typically so similar
that you can modify the cut-and-paste argument for one to apply to the others
with little effort.
To characterize the space of subproblems, a good rule of thumb says to try to
keep the space as simple as possible and then expand it as necessary. For example,
the space of subproblems that we considered for the rod-cutting problem contained
the problems of optimally cutting up a rod of length i for each size i. This subproblem space worked well, and we had no need to try a more general space of
subproblems.
Conversely, suppose that we had tried to constrain our subproblem space for
matrix-chain multiplication to matrix products of the form A1 A2    Aj . As before,
an optimal parenthesization must split this product between Ak and AkC1 for some
1  k < j . Unless we could guarantee that k always equals j  1, we would ﬁnd
that we had subproblems of the form A1 A2    Ak and AkC1 AkC2    Aj , and that
the latter subproblem is not of the form A1 A2    Aj . For this problem, we needed
to allow our subproblems to vary at “both ends,” that is, to allow both i and j to
vary in the subproblem Ai Ai C1    Aj .
Optimal substructure varies across problem domains in two ways:
1. how many subproblems an optimal solution to the original problem uses, and
2. how many choices we have in determining which subproblem(s) to use in an
optimal solution.
In the rod-cutting problem, an optimal solution for cutting up a rod of size n
uses just one subproblem (of size n  i), but we must consider n choices for i
in order to determine which one yields an optimal solution. Matrix-chain multiplication for the subchain Ai Ai C1    Aj serves as an example with two subproblems and j  i choices. For a given matrix Ak at which we split the product, we have two subproblems—parenthesizing Ai Ai C1    Ak and parenthesizing
AkC1 AkC2    Aj —and we must solve both of them optimally. Once we determine
the optimal solutions to subproblems, we choose from among j  i candidates for
the index k.
Informally, the running time of a dynamic-programming algorithm depends on
the product of two factors: the number of subproblems overall and how many
choices we look at for each subproblem. In rod cutting, we had ‚.n/ subproblems
overall, and at most n choices to examine for each, yielding an O.n2 / running time.
Matrix-chain multiplication had ‚.n2 / subproblems overall, and in each we had at
most n  1 choices, giving an O.n3 / running time (actually, a ‚.n3 / running time,
by Exercise 15.2-5).
Usually, the subproblem graph gives an alternative way to perform the same
analysis. Each vertex corresponds to a subproblem, and the choices for a sub-

15.3 Elements of dynamic programming

381

problem are the edges incident to that subproblem. Recall that in rod cutting,
the subproblem graph had n vertices and at most n edges per vertex, yielding an
O.n2 / running time. For matrix-chain multiplication, if we were to draw the subproblem graph, it would have ‚.n2 / vertices and each vertex would have degree at
most n  1, giving a total of O.n3 / vertices and edges.
Dynamic programming often uses optimal substructure in a bottom-up fashion.
That is, we ﬁrst ﬁnd optimal solutions to subproblems and, having solved the subproblems, we ﬁnd an optimal solution to the problem. Finding an optimal solution to the problem entails making a choice among subproblems as to which we
will use in solving the problem. The cost of the problem solution is usually the
subproblem costs plus a cost that is directly attributable to the choice itself. In
rod cutting, for example, ﬁrst we solved the subproblems of determining optimal
ways to cut up rods of length i for i D 0; 1; : : : ; n  1, and then we determined
which such subproblem yielded an optimal solution for a rod of length n, using
equation (15.2). The cost attributable to the choice itself is the term pi in equation (15.2). In matrix-chain multiplication, we determined optimal parenthesizations of subchains of Ai Ai C1    Aj , and then we chose the matrix Ak at which to
split the product. The cost attributable to the choice itself is the term pi 1 pk pj .
In Chapter 16, we shall examine “greedy algorithms,” which have many similarities to dynamic programming. In particular, problems to which greedy algorithms
apply have optimal substructure. One major difference between greedy algorithms
and dynamic programming is that instead of ﬁrst ﬁnding optimal solutions to subproblems and then making an informed choice, greedy algorithms ﬁrst make a
“greedy” choice—the choice that looks best at the time—and then solve a resulting
subproblem, without bothering to solve all possible related smaller subproblems.
Surprisingly, in some cases this strategy works!
Subtleties
You should be careful not to assume that optimal substructure applies when it does
not. Consider the following two problems in which we are given a directed graph
G D .V; E/ and vertices u;  2 V .
Unweighted shortest path:3 Find a path from u to  consisting of the fewest
edges. Such a path must be simple, since removing a cycle from a path produces a path with fewer edges.

3 We use the term “unweighted” to distinguish this problem from that of ﬁnding shortest paths with
weighted edges, which we shall see in Chapters 24 and 25. We can use the breadth-ﬁrst search
technique of Chapter 22 to solve the unweighted problem.

382

Chapter 15 Dynamic Programming

q

r

s

t

Figure 15.6 A directed graph showing that the problem of ﬁnding a longest simple path in an
unweighted directed graph does not have optimal substructure. The path q ! r ! t is a longest
simple path from q to t, but the subpath q ! r is not a longest simple path from q to r, nor is the
subpath r ! t a longest simple path from r to t.

Unweighted longest simple path: Find a simple path from u to  consisting of
the most edges. We need to include the requirement of simplicity because otherwise we can traverse a cycle as many times as we like to create paths with an
arbitrarily large number of edges.
The unweighted shortest-path problem exhibits optimal substructure, as follows.
Suppose that u ¤ , so that the problem is nontrivial. Then, any path p from u
to  must contain an intermediate vertex, say w. (Note that w may be u or .)
p
p
p
Thus, we can decompose the path u ;  into subpaths u ;1 w ;2 . Clearly, the
number of edges in p equals the number of edges in p1 plus the number of edges
in p2 . We claim that if p is an optimal (i.e., shortest) path from u to , then p1
must be a shortest path from u to w. Why? We use a “cut-and-paste” argument:
if there were another path, say p10 , from u to w with fewer edges than p1 , then we
p0

p

could cut out p1 and paste in p10 to produce a path u ;1 w ;2  with fewer edges
than p, thus contradicting p’s optimality. Symmetrically, p2 must be a shortest
path from w to . Thus, we can ﬁnd a shortest path from u to  by considering
all intermediate vertices w, ﬁnding a shortest path from u to w and a shortest path
from w to , and choosing an intermediate vertex w that yields the overall shortest
path. In Section 25.2, we use a variant of this observation of optimal substructure
to ﬁnd a shortest path between every pair of vertices on a weighted, directed graph.
You might be tempted to assume that the problem of ﬁnding an unweighted
longest simple path exhibits optimal substructure as well. After all, if we decomp
p
p
pose a longest simple path u ;  into subpaths u ;1 w ;2 , then mustn’t p1
be a longest simple path from u to w, and mustn’t p2 be a longest simple path
from w to ? The answer is no! Figure 15.6 supplies an example. Consider the
path q ! r ! t, which is a longest simple path from q to t. Is q ! r a longest
simple path from q to r? No, for the path q ! s ! t ! r is a simple path
that is longer. Is r ! t a longest simple path from r to t? No again, for the path
r ! q ! s ! t is a simple path that is longer.

15.3 Elements of dynamic programming

383

This example shows that for longest simple paths, not only does the problem
lack optimal substructure, but we cannot necessarily assemble a “legal” solution
to the problem from solutions to subproblems. If we combine the longest simple
paths q ! s ! t ! r and r ! q ! s ! t, we get the path q ! s ! t ! r !
q ! s ! t, which is not simple. Indeed, the problem of ﬁnding an unweighted
longest simple path does not appear to have any sort of optimal substructure. No
efﬁcient dynamic-programming algorithm for this problem has ever been found. In
fact, this problem is NP-complete, which—as we shall see in Chapter 34—means
that we are unlikely to ﬁnd a way to solve it in polynomial time.
Why is the substructure of a longest simple path so different from that of a shortest path? Although a solution to a problem for both longest and shortest paths uses
two subproblems, the subproblems in ﬁnding the longest simple path are not independent, whereas for shortest paths they are. What do we mean by subproblems
being independent? We mean that the solution to one subproblem does not affect
the solution to another subproblem of the same problem. For the example of Figure 15.6, we have the problem of ﬁnding a longest simple path from q to t with two
subproblems: ﬁnding longest simple paths from q to r and from r to t. For the ﬁrst
of these subproblems, we choose the path q ! s ! t ! r, and so we have also
used the vertices s and t. We can no longer use these vertices in the second subproblem, since the combination of the two solutions to subproblems would yield a
path that is not simple. If we cannot use vertex t in the second problem, then we
cannot solve it at all, since t is required to be on the path that we ﬁnd, and it is
not the vertex at which we are “splicing” together the subproblem solutions (that
vertex being r). Because we use vertices s and t in one subproblem solution, we
cannot use them in the other subproblem solution. We must use at least one of them
to solve the other subproblem, however, and we must use both of them to solve it
optimally. Thus, we say that these subproblems are not independent. Looked at
another way, using resources in solving one subproblem (those resources being
vertices) renders them unavailable for the other subproblem.
Why, then, are the subproblems independent for ﬁnding a shortest path? The
answer is that by nature, the subproblems do not share resources. We claim that
if a vertex w is on a shortest path p from u to , then we can splice together any
p
p
shortest path u ;1 w and any shortest path w ;2  to produce a shortest path from u
to . We are assured that, other than w, no vertex can appear in both paths p1
and p2 . Why? Suppose that some vertex x ¤ w appears in both p1 and p2 , so that
pux
px
we can decompose p1 as u ; x ; w and p2 as w ; x ; . By the optimal
substructure of this problem, path p has as many edges as p1 and p2 together; let’s
pux
px
say that p has e edges. Now let us construct a path p 0 D u ; x ;  from u to .
Because we have excised the paths from x to w and from w to x, each of which
contains at least one edge, path p 0 contains at most e  2 edges, which contradicts

384

Chapter 15 Dynamic Programming

the assumption that p is a shortest path. Thus, we are assured that the subproblems
for the shortest-path problem are independent.
Both problems examined in Sections 15.1 and 15.2 have independent subproblems. In matrix-chain multiplication, the subproblems are multiplying subchains
Ai Ai C1    Ak and AkC1 AkC2    Aj . These subchains are disjoint, so that no matrix could possibly be included in both of them. In rod cutting, to determine the
best way to cut up a rod of length n, we look at the best ways of cutting up rods
of length i for i D 0; 1; : : : ; n  1. Because an optimal solution to the length-n
problem includes just one of these subproblem solutions (after we have cut off the
ﬁrst piece), independence of subproblems is not an issue.
Overlapping subproblems
The second ingredient that an optimization problem must have for dynamic programming to apply is that the space of subproblems must be “small” in the sense
that a recursive algorithm for the problem solves the same subproblems over and
over, rather than always generating new subproblems. Typically, the total number
of distinct subproblems is a polynomial in the input size. When a recursive algorithm revisits the same problem repeatedly, we say that the optimization problem
has overlapping subproblems.4 In contrast, a problem for which a divide-andconquer approach is suitable usually generates brand-new problems at each step
of the recursion. Dynamic-programming algorithms typically take advantage of
overlapping subproblems by solving each subproblem once and then storing the
solution in a table where it can be looked up when needed, using constant time per
lookup.
In Section 15.1, we brieﬂy examined how a recursive solution to rod cutting makes exponentially many calls to ﬁnd solutions of smaller subproblems.
Our dynamic-programming solution takes an exponential-time recursive algorithm
down to quadratic time.
To illustrate the overlapping-subproblems property in greater detail, let us reexamine the matrix-chain multiplication problem. Referring back to Figure 15.5,
observe that M ATRIX -C HAIN -O RDER repeatedly looks up the solution to subproblems in lower rows when solving subproblems in higher rows. For example, it
references entry mŒ3; 4 four times: during the computations of mŒ2; 4, mŒ1; 4,

4 It

may seem strange that dynamic programming relies on subproblems being both independent
and overlapping. Although these requirements may sound contradictory, they describe two different
notions, rather than two points on the same axis. Two subproblems of the same problem are independent if they do not share resources. Two subproblems are overlapping if they are really the same
subproblem that occurs as a subproblem of different problems.

15.3 Elements of dynamic programming

385

1..4

1..1

2..4

1..2

2..2

3..4

2..3

4..4

3..3

4..4

2..2

3..3

1..1

3..4

2..2

3..3

1..3

4..4

4..4

1..1

2..3

1..2

3..3

2..2

3..3

1..1

2..2

Figure 15.7 The recursion tree for the computation of R ECURSIVE -M ATRIX -C HAIN.p; 1; 4/.
Each node contains the parameters i and j . The computations performed in a shaded subtree are
replaced by a single table lookup in M EMOIZED -M ATRIX -C HAIN.

mŒ3; 5, and mŒ3; 6. If we were to recompute mŒ3; 4 each time, rather than just
looking it up, the running time would increase dramatically. To see how, consider
the following (inefﬁcient) recursive procedure that determines mŒi; j , the minimum number of scalar multiplications needed to compute the matrix-chain product
Ai ::j D Ai Ai C1    Aj . The procedure is based directly on the recurrence (15.7).
R ECURSIVE -M ATRIX -C HAIN .p; i; j /
1 if i == j
2
return 0
3 mŒi; j  D 1
4 for k D i to j  1
5
q D R ECURSIVE -M ATRIX -C HAIN .p; i; k/
C R ECURSIVE -M ATRIX -C HAIN .p; k C 1; j /
C pi 1 pk pj
6
if q < mŒi; j 
7
mŒi; j  D q
8 return mŒi; j 
Figure 15.7 shows the recursion tree produced by the call R ECURSIVE -M ATRIX C HAIN.p; 1; 4/. Each node is labeled by the values of the parameters i and j .
Observe that some pairs of values occur many times.
In fact, we can show that the time to compute mŒ1; n by this recursive procedure is at least exponential in n. Let T .n/ denote the time taken by R ECURSIVE M ATRIX -C HAIN to compute an optimal parenthesization of a chain of n matrices.
Because the execution of lines 1–2 and of lines 6–7 each take at least unit time, as

386

Chapter 15 Dynamic Programming

does the multiplication in line 5, inspection of the procedure yields the recurrence
T .1/  1 ;
n1
X
.T .k/ C T .n  k/ C 1/
T .n/  1 C

for n > 1 :

kD1

Noting that for i D 1; 2; : : : ; n  1, each term T .i/ appears once as T .k/ and once
as T .n  k/, and collecting the n  1 1s in the summation together with the 1 out
front, we can rewrite the recurrence as
T .n/  2

n1
X

T .i/ C n :

(15.8)

i D1

We shall prove that T .n/ D .2n / using the substitution method. Speciﬁcally, we shall show that T .n/  2n1 for all n  1. The basis is easy, since
T .1/  1 D 20 . Inductively, for n  2 we have
T .n/  2

n1
X

2i 1 C n

i D1

D 2

n2
X

2i C n

i D0
n1

 1/ C n (by equation (A.5))
D 2.2
n
D 2 2Cn
 2n1 ;
which completes the proof. Thus, the total amount of work performed by the call
R ECURSIVE -M ATRIX -C HAIN .p; 1; n/ is at least exponential in n.
Compare this top-down, recursive algorithm (without memoization) with the
bottom-up dynamic-programming algorithm. The latter is more efﬁcient because
it takes advantage of the overlapping-subproblems property. Matrix-chain multiplication has only ‚.n2 / distinct subproblems, and the dynamic-programming
algorithm solves each exactly once. The recursive algorithm, on the other hand,
must again solve each subproblem every time it reappears in the recursion tree.
Whenever a recursion tree for the natural recursive solution to a problem contains
the same subproblem repeatedly, and the total number of distinct subproblems is
small, dynamic programming can improve efﬁciency, sometimes dramatically.

15.3 Elements of dynamic programming

387

Reconstructing an optimal solution
As a practical matter, we often store which choice we made in each subproblem in
a table so that we do not have to reconstruct this information from the costs that we
stored.
For matrix-chain multiplication, the table sŒi; j  saves us a signiﬁcant amount of
work when reconstructing an optimal solution. Suppose that we did not maintain
the sŒi; j  table, having ﬁlled in only the table mŒi; j  containing optimal subproblem costs. We choose from among j  i possibilities when we determine which
subproblems to use in an optimal solution to parenthesizing Ai Ai C1    Aj , and
j  i is not a constant. Therefore, it would take ‚.j  i/ D !.1/ time to reconstruct which subproblems we chose for a solution to a given problem. By storing
in sŒi; j  the index of the matrix at which we split the product Ai Ai C1    Aj , we
can reconstruct each choice in O.1/ time.
Memoization
As we saw for the rod-cutting problem, there is an alternative approach to dynamic programming that often offers the efﬁciency of the bottom-up dynamicprogramming approach while maintaining a top-down strategy. The idea is to
memoize the natural, but inefﬁcient, recursive algorithm. As in the bottom-up approach, we maintain a table with subproblem solutions, but the control structure
for ﬁlling in the table is more like the recursive algorithm.
A memoized recursive algorithm maintains an entry in a table for the solution to
each subproblem. Each table entry initially contains a special value to indicate that
the entry has yet to be ﬁlled in. When the subproblem is ﬁrst encountered as the
recursive algorithm unfolds, its solution is computed and then stored in the table.
Each subsequent time that we encounter this subproblem, we simply look up the
value stored in the table and return it.5
Here is a memoized version of R ECURSIVE -M ATRIX -C HAIN. Note where it
resembles the memoized top-down method for the rod-cutting problem.

5 This

approach presupposes that we know the set of all possible subproblem parameters and that we
have established the relationship between table positions and subproblems. Another, more general,
approach is to memoize by using hashing with the subproblem parameters as keys.

388

Chapter 15 Dynamic Programming

M EMOIZED -M ATRIX -C HAIN .p/
1 n D p:length  1
2 let mŒ1 : : n; 1 : : n be a new table
3 for i D 1 to n
4
for j D i to n
5
mŒi; j  D 1
6 return L OOKUP -C HAIN .m; p; 1; n/
L OOKUP -C HAIN .m; p; i; j /
1 if mŒi; j  < 1
2
return mŒi; j 
3 if i == j
4
mŒi; j  D 0
5 else for k D i to j  1
6
q D L OOKUP -C HAIN .m; p; i; k/
C L OOKUP -C HAIN .m; p; k C 1; j / C pi 1 pk pj
7
if q < mŒi; j 
8
mŒi; j  D q
9 return mŒi; j 
The M EMOIZED -M ATRIX -C HAIN procedure, like M ATRIX -C HAIN -O RDER,
maintains a table mŒ1 : : n; 1 : : n of computed values of mŒi; j , the minimum number of scalar multiplications needed to compute the matrix Ai ::j . Each table entry
initially contains the value 1 to indicate that the entry has yet to be ﬁlled in. Upon
calling L OOKUP -C HAIN .m; p; i; j /, if line 1 ﬁnds that mŒi; j  < 1, then the procedure simply returns the previously computed cost mŒi; j  in line 2. Otherwise,
the cost is computed as in R ECURSIVE -M ATRIX -C HAIN, stored in mŒi; j , and
returned. Thus, L OOKUP -C HAIN .m; p; i; j / always returns the value of mŒi; j ,
but it computes it only upon the ﬁrst call of L OOKUP -C HAIN with these speciﬁc
values of i and j .
Figure 15.7 illustrates how M EMOIZED -M ATRIX -C HAIN saves time compared
with R ECURSIVE -M ATRIX -C HAIN. Shaded subtrees represent values that it looks
up rather than recomputes.
Like the bottom-up dynamic-programming algorithm M ATRIX -C HAIN -O RDER,
the procedure M EMOIZED -M ATRIX -C HAIN runs in O.n3 / time. Line 5 of
M EMOIZED -M ATRIX -C HAIN executes ‚.n2 / times. We can categorize the calls
of L OOKUP -C HAIN into two types:
1. calls in which mŒi; j  D 1, so that lines 3–9 execute, and
2. calls in which mŒi; j  < 1, so that L OOKUP -C HAIN simply returns in line 2.

15.3 Elements of dynamic programming

389

There are ‚.n2 / calls of the ﬁrst type, one per table entry. All calls of the second type are made as recursive calls by calls of the ﬁrst type. Whenever a given
call of L OOKUP -C HAIN makes recursive calls, it makes O.n/ of them. Therefore, there are O.n3 / calls of the second type in all. Each call of the second type
takes O.1/ time, and each call of the ﬁrst type takes O.n/ time plus the time spent
in its recursive calls. The total time, therefore, is O.n3 /. Memoization thus turns
an .2n /-time algorithm into an O.n3 /-time algorithm.
In summary, we can solve the matrix-chain multiplication problem by either a
top-down, memoized dynamic-programming algorithm or a bottom-up dynamicprogramming algorithm in O.n3 / time. Both methods take advantage of the
overlapping-subproblems property. There are only ‚.n2 / distinct subproblems in
total, and either of these methods computes the solution to each subproblem only
once. Without memoization, the natural recursive algorithm runs in exponential
time, since solved subproblems are repeatedly solved.
In general practice, if all subproblems must be solved at least once, a bottom-up
dynamic-programming algorithm usually outperforms the corresponding top-down
memoized algorithm by a constant factor, because the bottom-up algorithm has no
overhead for recursion and less overhead for maintaining the table. Moreover, for
some problems we can exploit the regular pattern of table accesses in the dynamicprogramming algorithm to reduce time or space requirements even further. Alternatively, if some subproblems in the subproblem space need not be solved at all,
the memoized solution has the advantage of solving only those subproblems that
are deﬁnitely required.
Exercises
15.3-1
Which is a more efﬁcient way to determine the optimal number of multiplications
in a matrix-chain multiplication problem: enumerating all the ways of parenthesizing the product and computing the number of multiplications for each, or running
R ECURSIVE -M ATRIX -C HAIN? Justify your answer.
15.3-2
Draw the recursion tree for the M ERGE -S ORT procedure from Section 2.3.1 on an
array of 16 elements. Explain why memoization fails to speed up a good divideand-conquer algorithm such as M ERGE -S ORT.
15.3-3
Consider a variant of the matrix-chain multiplication problem in which the goal is
to parenthesize the sequence of matrices so as to maximize, rather than minimize,

390

Chapter 15 Dynamic Programming

the number of scalar multiplications. Does this problem exhibit optimal substructure?
15.3-4
As stated, in dynamic programming we ﬁrst solve the subproblems and then choose
which of them to use in an optimal solution to the problem. Professor Capulet
claims that we do not always need to solve all the subproblems in order to ﬁnd an
optimal solution. She suggests that we can ﬁnd an optimal solution to the matrixchain multiplication problem by always choosing the matrix Ak at which to split
the subproduct Ai Ai C1    Aj (by selecting k to minimize the quantity pi 1 pk pj )
before solving the subproblems. Find an instance of the matrix-chain multiplication problem for which this greedy approach yields a suboptimal solution.
15.3-5
Suppose that in the rod-cutting problem of Section 15.1, we also had limit li on the
number of pieces of length i that we are allowed to produce, for i D 1; 2; : : : ; n.
Show that the optimal-substructure property described in Section 15.1 no longer
holds.
15.3-6
Imagine that you wish to exchange one currency for another. You realize that
instead of directly exchanging one currency for another, you might be better off
making a series of trades through other currencies, winding up with the currency
you want. Suppose that you can trade n different currencies, numbered 1; 2; : : : ; n,
where you start with currency 1 and wish to wind up with currency n. You are
given, for each pair of currencies i and j , an exchange rate rij , meaning that if
you start with d units of currency i, you can trade for drij units of currency j .
A sequence of trades may entail a commission, which depends on the number of
trades you make. Let ck be the commission that you are charged when you make k
trades. Show that, if ck D 0 for all k D 1; 2; : : : ; n, then the problem of ﬁnding the
best sequence of exchanges from currency 1 to currency n exhibits optimal substructure. Then show that if commissions ck are arbitrary values, then the problem
of ﬁnding the best sequence of exchanges from currency 1 to currency n does not
necessarily exhibit optimal substructure.

15.4 Longest common subsequence
Biological applications often need to compare the DNA of two (or more) different organisms. A strand of DNA consists of a string of molecules called

15.4 Longest common subsequence

391

bases, where the possible bases are adenine, guanine, cytosine, and thymine.
Representing each of these bases by its initial letter, we can express a strand
of DNA as a string over the ﬁnite set fA; C; G; Tg. (See Appendix C for
the deﬁnition of a string.) For example, the DNA of one organism may be
S1 D ACCGGTCGAGTGCGCGGAAGCCGGCCGAA, and the DNA of another organism may be S2 D GTCGTTCGGAATGCCGTTGCTCTGTAAA. One reason to compare two strands of DNA is to determine how “similar” the two strands are, as some
measure of how closely related the two organisms are. We can, and do, deﬁne similarity in many different ways. For example, we can say that two DNA strands are
similar if one is a substring of the other. (Chapter 32 explores algorithms to solve
this problem.) In our example, neither S1 nor S2 is a substring of the other. Alternatively, we could say that two strands are similar if the number of changes needed
to turn one into the other is small. (Problem 15-5 looks at this notion.) Yet another
way to measure the similarity of strands S1 and S2 is by ﬁnding a third strand S3
in which the bases in S3 appear in each of S1 and S2 ; these bases must appear
in the same order, but not necessarily consecutively. The longer the strand S3 we
can ﬁnd, the more similar S1 and S2 are. In our example, the longest strand S3 is
GTCGTCGGAAGCCGGCCGAA.
We formalize this last notion of similarity as the longest-common-subsequence
problem. A subsequence of a given sequence is just the given sequence with zero or
more elements left out. Formally, given a sequence X D hx1 ; x2 ; : : : ; xm i, another
sequence Z D h´1 ; ´2 ; : : : ; ´k i is a subsequence of X if there exists a strictly
increasing sequence hi1 ; i2 ; : : : ; ik i of indices of X such that for all j D 1; 2; : : : ; k,
we have xij D ´j . For example, Z D hB; C; D; Bi is a subsequence of X D
hA; B; C; B; D; A; Bi with corresponding index sequence h2; 3; 5; 7i.
Given two sequences X and Y , we say that a sequence Z is a common subsequence of X and Y if Z is a subsequence of both X and Y . For example, if
X D hA; B; C; B; D; A; Bi and Y D hB; D; C; A; B; Ai, the sequence hB; C; Ai is
a common subsequence of both X and Y . The sequence hB; C; Ai is not a longest
common subsequence (LCS) of X and Y , however, since it has length 3 and the
sequence hB; C; B; Ai, which is also common to both X and Y , has length 4. The
sequence hB; C; B; Ai is an LCS of X and Y , as is the sequence hB; D; A; Bi,
since X and Y have no common subsequence of length 5 or greater.
In the longest-common-subsequence problem, we are given two sequences
X D hx1 ; x2 ; : : : ; xm i and Y D hy1 ; y2 ; : : : ; yn i and wish to ﬁnd a maximumlength common subsequence of X and Y . This section shows how to efﬁciently
solve the LCS problem using dynamic programming.

392

Chapter 15 Dynamic Programming

Step 1: Characterizing a longest common subsequence
In a brute-force approach to solving the LCS problem, we would enumerate all
subsequences of X and check each subsequence to see whether it is also a subsequence of Y , keeping track of the longest subsequence we ﬁnd. Each subsequence
of X corresponds to a subset of the indices f1; 2; : : : ; mg of X . Because X has 2m
subsequences, this approach requires exponential time, making it impractical for
long sequences.
The LCS problem has an optimal-substructure property, however, as the following theorem shows. As we shall see, the natural classes of subproblems correspond to pairs of “preﬁxes” of the two input sequences. To be precise, given a
sequence X D hx1 ; x2 ; : : : ; xm i, we deﬁne the ith preﬁx of X , for i D 0; 1; : : : ; m,
as Xi D hx1 ; x2 ; : : : ; xi i. For example, if X D hA; B; C; B; D; A; Bi, then
X4 D hA; B; C; Bi and X0 is the empty sequence.
Theorem 15.1 (Optimal substructure of an LCS)
Let X D hx1 ; x2 ; : : : ; xm i and Y D hy1 ; y2 ; : : : ; yn i be sequences, and let Z D
h´1 ; ´2 ; : : : ; ´k i be any LCS of X and Y .
1. If xm D yn , then ´k D xm D yn and Zk1 is an LCS of Xm1 and Yn1 .
2. If xm ¤ yn , then ´k ¤ xm implies that Z is an LCS of Xm1 and Y .
3. If xm ¤ yn , then ´k ¤ yn implies that Z is an LCS of X and Yn1 .
Proof (1) If ´k ¤ xm , then we could append xm D yn to Z to obtain a common
subsequence of X and Y of length k C 1, contradicting the supposition that Z is
a longest common subsequence of X and Y . Thus, we must have ´k D xm D yn .
Now, the preﬁx Zk1 is a length-.k  1/ common subsequence of Xm1 and Yn1 .
We wish to show that it is an LCS. Suppose for the purpose of contradiction
that there exists a common subsequence W of Xm1 and Yn1 with length greater
than k  1. Then, appending xm D yn to W produces a common subsequence of
X and Y whose length is greater than k, which is a contradiction.
(2) If ´k ¤ xm , then Z is a common subsequence of Xm1 and Y . If there were a
common subsequence W of Xm1 and Y with length greater than k, then W would
also be a common subsequence of Xm and Y , contradicting the assumption that Z
is an LCS of X and Y .
(3) The proof is symmetric to (2).
The way that Theorem 15.1 characterizes longest common subsequences tells
us that an LCS of two sequences contains within it an LCS of preﬁxes of the two
sequences. Thus, the LCS problem has an optimal-substructure property. A recur-

15.4 Longest common subsequence

393

sive solution also has the overlapping-subproblems property, as we shall see in a
moment.
Step 2: A recursive solution
Theorem 15.1 implies that we should examine either one or two subproblems when
ﬁnding an LCS of X D hx1 ; x2 ; : : : ; xm i and Y D hy1 ; y2 ; : : : ; yn i. If xm D yn ,
we must ﬁnd an LCS of Xm1 and Yn1 . Appending xm D yn to this LCS yields
an LCS of X and Y . If xm ¤ yn , then we must solve two subproblems: ﬁnding an
LCS of Xm1 and Y and ﬁnding an LCS of X and Yn1 . Whichever of these two
LCSs is longer is an LCS of X and Y . Because these cases exhaust all possibilities,
we know that one of the optimal subproblem solutions must appear within an LCS
of X and Y .
We can readily see the overlapping-subproblems property in the LCS problem.
To ﬁnd an LCS of X and Y , we may need to ﬁnd the LCSs of X and Yn1 and
of Xm1 and Y . But each of these subproblems has the subsubproblem of ﬁnding
an LCS of Xm1 and Yn1 . Many other subproblems share subsubproblems.
As in the matrix-chain multiplication problem, our recursive solution to the LCS
problem involves establishing a recurrence for the value of an optimal solution.
Let us deﬁne cŒi; j  to be the length of an LCS of the sequences Xi and Yj . If
either i D 0 or j D 0, one of the sequences has length 0, and so the LCS has
length 0. The optimal substructure of the LCS problem gives the recursive formula

0

cŒi; j  D

if i D 0 or j D 0 ;
cŒi  1; j  1 C 1
if i; j > 0 and xi D yj ;
max.cŒi; j  1; cŒi  1; j / if i; j > 0 and xi ¤ yj :

(15.9)

Observe that in this recursive formulation, a condition in the problem restricts
which subproblems we may consider. When xi D yj , we can and should consider
the subproblem of ﬁnding an LCS of Xi 1 and Yj 1 . Otherwise, we instead consider the two subproblems of ﬁnding an LCS of Xi and Yj 1 and of Xi 1 and Yj . In
the previous dynamic-programming algorithms we have examined—for rod cutting
and matrix-chain multiplication—we ruled out no subproblems due to conditions
in the problem. Finding an LCS is not the only dynamic-programming algorithm
that rules out subproblems based on conditions in the problem. For example, the
edit-distance problem (see Problem 15-5) has this characteristic.
Step 3: Computing the length of an LCS
Based on equation (15.9), we could easily write an exponential-time recursive algorithm to compute the length of an LCS of two sequences. Since the LCS problem

394

Chapter 15 Dynamic Programming

has only ‚.mn/ distinct subproblems, however, we can use dynamic programming
to compute the solutions bottom up.
Procedure LCS-L ENGTH takes two sequences X D hx1 ; x2 ; : : : ; xm i and
Y D hy1 ; y2 ; : : : ; yn i as inputs. It stores the cŒi; j  values in a table cŒ0 : : m; 0 : : n,
and it computes the entries in row-major order. (That is, the procedure ﬁlls in the
ﬁrst row of c from left to right, then the second row, and so on.) The procedure also
maintains the table bŒ1 : : m; 1 : : n to help us construct an optimal solution. Intuitively, bŒi; j  points to the table entry corresponding to the optimal subproblem
solution chosen when computing cŒi; j . The procedure returns the b and c tables;
cŒm; n contains the length of an LCS of X and Y .
LCS-L ENGTH .X; Y /
1 m D X:length
2 n D Y:length
3 let bŒ1 : : m; 1 : : n and cŒ0 : : m; 0 : : n be new tables
4 for i D 1 to m
5
cŒi; 0 D 0
6 for j D 0 to n
7
cŒ0; j  D 0
8 for i D 1 to m
9
for j D 1 to n
10
if xi == yj
11
cŒi; j  D cŒi  1; j  1 C 1
12
bŒi; j  D “-”
13
elseif cŒi  1; j   cŒi; j  1
14
cŒi; j  D cŒi  1; j 
15
bŒi; j  D “"”
16
else cŒi; j  D cŒi; j  1
17
bŒi; j  D “ ”
18 return c and b
Figure 15.8 shows the tables produced by LCS-L ENGTH on the sequences X D
hA; B; C; B; D; A; Bi and Y D hB; D; C; A; B; Ai. The running time of the
procedure is ‚.mn/, since each table entry takes ‚.1/ time to compute.
Step 4: Constructing an LCS
The b table returned by LCS-L ENGTH enables us to quickly construct an LCS of
X D hx1 ; x2 ; : : : ; xm i and Y D hy1 ; y2 ; : : : ; yn i. We simply begin at bŒm; n and
trace through the table by following the arrows. Whenever we encounter a “-” in
entry bŒi; j , it implies that xi D yj is an element of the LCS that LCS-L ENGTH

15.4 Longest common subsequence

j
i

395

0

1

2

3

4

5

6

yj

B

D

C

A

B

A

0

xi

0

0

0

0

0

0

0

1

A

0

0

0

0

1

1

1

2

B

0

1

1

1

1

2

2

3

C

0

1

1

2

2

2

2

4

B

0

1

1

2

2

3

3

5

D

0

1

2

2

2

3

3

6

A

0

1

2

2

3

3

4

7

B

0

1

2

2

3

4

4

Figure 15.8 The c and b tables computed by LCS-L ENGTH on the sequences X D hA; B; C; B;
D; A; Bi and Y D hB; D; C; A; B; Ai. The square in row i and column j contains the value of cŒi; j 
and the appropriate arrow for the value of bŒi; j . The entry 4 in cŒ7; 6—the lower right-hand corner
of the table—is the length of an LCS hB; C; B; Ai of X and Y . For i; j > 0, entry cŒi; j  depends
only on whether xi D yj and the values in entries cŒi  1; j , cŒi; j  1, and cŒi  1; j  1, which
are computed before cŒi; j . To reconstruct the elements of an LCS, follow the bŒi; j  arrows from
the lower right-hand corner; the sequence is shaded. Each “-” on the shaded sequence corresponds
to an entry (highlighted) for which xi D yj is a member of an LCS.

found. With this method, we encounter the elements of this LCS in reverse order.
The following recursive procedure prints out an LCS of X and Y in the proper,
forward order. The initial call is P RINT-LCS.b; X; X:length; Y:length/.
P RINT-LCS.b; X; i; j /
1 if i == 0 or j == 0
2
return
3 if bŒi; j  == “-”
4
P RINT-LCS.b; X; i  1; j  1/
5
print xi
6 elseif bŒi; j  == “"”
7
P RINT-LCS.b; X; i  1; j /
8 else P RINT-LCS.b; X; i; j  1/
For the b table in Figure 15.8, this procedure prints BCBA. The procedure takes
time O.m C n/, since it decrements at least one of i and j in each recursive call.

396

Chapter 15 Dynamic Programming

Improving the code
Once you have developed an algorithm, you will often ﬁnd that you can improve
on the time or space it uses. Some changes can simplify the code and improve
constant factors but otherwise yield no asymptotic improvement in performance.
Others can yield substantial asymptotic savings in time and space.
In the LCS algorithm, for example, we can eliminate the b table altogether. Each
cŒi; j  entry depends on only three other c table entries: cŒi  1; j  1, cŒi  1; j ,
and cŒi; j  1. Given the value of cŒi; j , we can determine in O.1/ time which of
these three values was used to compute cŒi; j , without inspecting table b. Thus, we
can reconstruct an LCS in O.mCn/ time using a procedure similar to P RINT-LCS.
(Exercise 15.4-2 asks you to give the pseudocode.) Although we save ‚.mn/ space
by this method, the auxiliary space requirement for computing an LCS does not
asymptotically decrease, since we need ‚.mn/ space for the c table anyway.
We can, however, reduce the asymptotic space requirements for LCS-L ENGTH,
since it needs only two rows of table c at a time: the row being computed and the
previous row. (In fact, as Exercise 15.4-4 asks you to show, we can use only slightly
more than the space for one row of c to compute the length of an LCS.) This
improvement works if we need only the length of an LCS; if we need to reconstruct
the elements of an LCS, the smaller table does not keep enough information to
retrace our steps in O.m C n/ time.
Exercises
15.4-1
Determine an LCS of h1; 0; 0; 1; 0; 1; 0; 1i and h0; 1; 0; 1; 1; 0; 1; 1; 0i.
15.4-2
Give pseudocode to reconstruct an LCS from the completed c table and the original
sequences X D hx1 ; x2 ; : : : ; xm i and Y D hy1 ; y2 ; : : : ; yn i in O.m C n/ time,
without using the b table.
15.4-3
Give a memoized version of LCS-L ENGTH that runs in O.mn/ time.
15.4-4
Show how to compute the length of an LCS using only 2min.m; n/ entries in the c
table plus O.1/ additional space. Then show how to do the same thing, but using
min.m; n/ entries plus O.1/ additional space.

15.5 Optimal binary search trees

397

15.4-5
Give an O.n2 /-time algorithm to ﬁnd the longest monotonically increasing subsequence of a sequence of n numbers.
15.4-6 ?
Give an O.n lg n/-time algorithm to ﬁnd the longest monotonically increasing subsequence of a sequence of n numbers. (Hint: Observe that the last element of a
candidate subsequence of length i is at least as large as the last element of a candidate subsequence of length i  1. Maintain candidate subsequences by linking
them through the input sequence.)

15.5 Optimal binary search trees
Suppose that we are designing a program to translate text from English to French.
For each occurrence of each English word in the text, we need to look up its French
equivalent. We could perform these lookup operations by building a binary search
tree with n English words as keys and their French equivalents as satellite data.
Because we will search the tree for each individual word in the text, we want the
total time spent searching to be as low as possible. We could ensure an O.lg n/
search time per occurrence by using a red-black tree or any other balanced binary
search tree. Words appear with different frequencies, however, and a frequently
used word such as the may appear far from the root while a rarely used word such
as machicolation appears near the root. Such an organization would slow down the
translation, since the number of nodes visited when searching for a key in a binary
search tree equals one plus the depth of the node containing the key. We want
words that occur frequently in the text to be placed nearer the root.6 Moreover,
some words in the text might have no French translation,7 and such words would
not appear in the binary search tree at all. How do we organize a binary search tree
so as to minimize the number of nodes visited in all searches, given that we know
how often each word occurs?
What we need is known as an optimal binary search tree. Formally, we are
given a sequence K D hk1 ; k2 ; : : : ; kn i of n distinct keys in sorted order (so that
k1 < k2 <    < kn ), and we wish to build a binary search tree from these keys.
For each key ki , we have a probability pi that a search will be for ki . Some
searches may be for values not in K, and so we also have n C 1 “dummy keys”

6 If the subject
7 Yes,

of the text is castle architecture, we might want machicolation to appear near the root.

machicolation has a French counterpart: mâchicoulis.

398

Chapter 15 Dynamic Programming

k2

k2

k1
d0

k4
d1

k1

k3
d2

k5
d3

d4

d0

k5
d1

d5

k4
k3

d2

i
pi
qi

0
0.05

d4
d3

(a)

Figure 15.9

d5

(b)

Two binary search trees for a set of n D 5 keys with the following probabilities:
1
0.15
0.10

2
0.10
0.05

3
0.05
0.05

4
0.10
0.05

5
0.20
0.10

(a) A binary search tree with expected search cost 2.80. (b) A binary search tree with expected search
cost 2.75. This tree is optimal.

d0 ; d1 ; d2 ; : : : ; dn representing values not in K. In particular, d0 represents all values less than k1 , dn represents all values greater than kn , and for i D 1; 2; : : : ; n1,
the dummy key di represents all values between ki and ki C1 . For each dummy
key di , we have a probability qi that a search will correspond to di . Figure 15.9
shows two binary search trees for a set of n D 5 keys. Each key ki is an internal
node, and each dummy key di is a leaf. Every search is either successful (ﬁnding
some key ki ) or unsuccessful (ﬁnding some dummy key di ), and so we have
n
X
i D1

pi C

n
X

qi D 1 :

(15.10)

i D0

Because we have probabilities of searches for each key and each dummy key,
we can determine the expected cost of a search in a given binary search tree T . Let
us assume that the actual cost of a search equals the number of nodes examined,
i.e., the depth of the node found by the search in T , plus 1. Then the expected cost
of a search in T is
n
n
X
X
.depthT .ki / C 1/  pi C
.depthT .di / C 1/  qi
E Œsearch cost in T  D
i D1

D 1C

i D0
n
X
i D1

depthT .ki /  pi C

n
X
i D0

depthT .di /  qi ;

(15.11)

15.5 Optimal binary search trees

399

where depthT denotes a node’s depth in the tree T . The last equality follows from
equation (15.10). In Figure 15.9(a), we can calculate the expected search cost node
by node:
node
k1
k2
k3
k4
k5
d0
d1
d2
d3
d4
d5
Total

depth
1
0
2
1
2
2
2
3
3
3
3

probability
0.15
0.10
0.05
0.10
0.20
0.05
0.10
0.05
0.05
0.05
0.10

contribution
0.30
0.10
0.15
0.20
0.60
0.15
0.30
0.20
0.20
0.20
0.40
2.80

For a given set of probabilities, we wish to construct a binary search tree whose
expected search cost is smallest. We call such a tree an optimal binary search tree.
Figure 15.9(b) shows an optimal binary search tree for the probabilities given in
the ﬁgure caption; its expected cost is 2.75. This example shows that an optimal
binary search tree is not necessarily a tree whose overall height is smallest. Nor
can we necessarily construct an optimal binary search tree by always putting the
key with the greatest probability at the root. Here, key k5 has the greatest search
probability of any key, yet the root of the optimal binary search tree shown is k2 .
(The lowest expected cost of any binary search tree with k5 at the root is 2.85.)
As with matrix-chain multiplication, exhaustive checking of all possibilities fails
to yield an efﬁcient algorithm. We can label the nodes of any n-node binary tree
with the keys k1 ; k2 ; : : : ; kn to construct a binary search tree, and then add in the
dummy keys as leaves. In Problem 12-4, we saw that the number of binary trees
with n nodes is .4n =n3=2 /, and so we would have to examine an exponential
number of binary search trees in an exhaustive search. Not surprisingly, we shall
solve this problem with dynamic programming.
Step 1: The structure of an optimal binary search tree
To characterize the optimal substructure of optimal binary search trees, we start
with an observation about subtrees. Consider any subtree of a binary search tree.
It must contain keys in a contiguous range ki ; : : : ; kj , for some 1  i  j  n.
In addition, a subtree that contains keys ki ; : : : ; kj must also have as its leaves the
dummy keys di 1 ; : : : ; dj .
Now we can state the optimal substructure: if an optimal binary search tree T
has a subtree T 0 containing keys ki ; : : : ; kj , then this subtree T 0 must be optimal as

400

Chapter 15 Dynamic Programming

well for the subproblem with keys ki ; : : : ; kj and dummy keys di 1 ; : : : ; dj . The
usual cut-and-paste argument applies. If there were a subtree T 00 whose expected
cost is lower than that of T 0 , then we could cut T 0 out of T and paste in T 00 ,
resulting in a binary search tree of lower expected cost than T , thus contradicting
the optimality of T .
We need to use the optimal substructure to show that we can construct an optimal solution to the problem from optimal solutions to subproblems. Given keys
ki ; : : : ; kj , one of these keys, say kr (i  r  j ), is the root of an optimal
subtree containing these keys. The left subtree of the root kr contains the keys
ki ; : : : ; kr1 (and dummy keys di 1 ; : : : ; dr1 ), and the right subtree contains the
keys krC1 ; : : : ; kj (and dummy keys dr ; : : : ; dj ). As long as we examine all candidate roots kr , where i  r  j , and we determine all optimal binary search trees
containing ki ; : : : ; kr1 and those containing krC1 ; : : : ; kj , we are guaranteed that
we will ﬁnd an optimal binary search tree.
There is one detail worth noting about “empty” subtrees. Suppose that in a
subtree with keys ki ; : : : ; kj , we select ki as the root. By the above argument, ki ’s
left subtree contains the keys ki ; : : : ; ki 1 . We interpret this sequence as containing
no keys. Bear in mind, however, that subtrees also contain dummy keys. We adopt
the convention that a subtree containing keys ki ; : : : ; ki 1 has no actual keys but
does contain the single dummy key di 1 . Symmetrically, if we select kj as the root,
then kj ’s right subtree contains the keys kj C1 ; : : : ; kj ; this right subtree contains
no actual keys, but it does contain the dummy key dj .
Step 2: A recursive solution
We are ready to deﬁne the value of an optimal solution recursively. We pick our
subproblem domain as ﬁnding an optimal binary search tree containing the keys
ki ; : : : ; kj , where i  1, j  n, and j  i  1. (When j D i  1, there
are no actual keys; we have just the dummy key di 1 .) Let us deﬁne eŒi; j  as
the expected cost of searching an optimal binary search tree containing the keys
ki ; : : : ; kj . Ultimately, we wish to compute eŒ1; n.
The easy case occurs when j D i  1. Then we have just the dummy key di 1 .
The expected search cost is eŒi; i  1 D qi 1 .
When j  i, we need to select a root kr from among ki ; : : : ; kj and then make an
optimal binary search tree with keys ki ; : : : ; kr1 as its left subtree and an optimal
binary search tree with keys krC1 ; : : : ; kj as its right subtree. What happens to the
expected search cost of a subtree when it becomes a subtree of a node? The depth
of each node in the subtree increases by 1. By equation (15.11), the expected search
cost of this subtree increases by the sum of all the probabilities in the subtree. For
a subtree with keys ki ; : : : ; kj , let us denote this sum of probabilities as

15.5 Optimal binary search trees

w.i; j / D

j
X

pl C

lDi

j
X

ql :

401

(15.12)

lDi 1

Thus, if kr is the root of an optimal subtree containing keys ki ; : : : ; kj , we have
eŒi; j  D pr C .eŒi; r  1 C w.i; r  1// C .eŒr C 1; j  C w.r C 1; j // :
Noting that
w.i; j / D w.i; r  1/ C pr C w.r C 1; j / ;
we rewrite eŒi; j  as
eŒi; j  D eŒi; r  1 C eŒr C 1; j  C w.i; j / :

(15.13)

The recursive equation (15.13) assumes that we know which node kr to use as
the root. We choose the root that gives the lowest expected search cost, giving us
our ﬁnal recursive formulation:
(
if j D i  1 ;
qi 1
(15.14)
eŒi; j  D
min feŒi; r  1 C eŒr C 1; j  C w.i; j /g if i  j :
i rj

The eŒi; j  values give the expected search costs in optimal binary search trees.
To help us keep track of the structure of optimal binary search trees, we deﬁne
rootŒi; j , for 1  i  j  n, to be the index r for which kr is the root of an
optimal binary search tree containing keys ki ; : : : ; kj . Although we will see how
to compute the values of rootŒi; j , we leave the construction of an optimal binary
search tree from these values as Exercise 15.5-1.
Step 3: Computing the expected search cost of an optimal binary search tree
At this point, you may have noticed some similarities between our characterizations
of optimal binary search trees and matrix-chain multiplication. For both problem
domains, our subproblems consist of contiguous index subranges. A direct, recursive implementation of equation (15.14) would be as inefﬁcient as a direct, recursive matrix-chain multiplication algorithm. Instead, we store the eŒi; j  values in a
table eŒ1 : : n C 1; 0 : : n. The ﬁrst index needs to run to n C 1 rather than n because
in order to have a subtree containing only the dummy key dn , we need to compute
and store eŒn C 1; n. The second index needs to start from 0 because in order to
have a subtree containing only the dummy key d0 , we need to compute and store
eŒ1; 0. We use only the entries eŒi; j  for which j  i  1. We also use a table
rootŒi; j , for recording the root of the subtree containing keys ki ; : : : ; kj . This
table uses only the entries for which 1  i  j  n.
We will need one other table for efﬁciency. Rather than compute the value
of w.i; j / from scratch every time we are computing eŒi; j —which would take

402

Chapter 15 Dynamic Programming

‚.j  i/ additions—we store these values in a table wŒ1 : : n C 1; 0 : : n. For the
base case, we compute wŒi; i  1 D qi 1 for 1  i  n C 1. For j  i, we
compute
wŒi; j  D wŒi; j  1 C pj C qj :

(15.15)

Thus, we can compute the ‚.n2 / values of wŒi; j  in ‚.1/ time each.
The pseudocode that follows takes as inputs the probabilities p1 ; : : : ; pn and
q0 ; : : : ; qn and the size n, and it returns the tables e and root.
O PTIMAL -BST.p; q; n/
1 let eŒ1 : : n C 1; 0 : : n, wŒ1 : : n C 1; 0 : : n,
and rootŒ1 : : n; 1 : : n be new tables
2 for i D 1 to n C 1
3
eŒi; i  1 D qi 1
4
wŒi; i  1 D qi 1
5 for l D 1 to n
6
for i D 1 to n  l C 1
7
j D i Cl 1
8
eŒi; j  D 1
9
wŒi; j  D wŒi; j  1 C pj C qj
10
for r D i to j
11
t D eŒi; r  1 C eŒr C 1; j  C wŒi; j 
12
if t < eŒi; j 
13
eŒi; j  D t
14
rootŒi; j  D r
15 return e and root
From the description above and the similarity to the M ATRIX -C HAIN -O RDER procedure in Section 15.2, you should ﬁnd the operation of this procedure to be fairly
straightforward. The for loop of lines 2–4 initializes the values of eŒi; i  1
and wŒi; i  1. The for loop of lines 5–14 then uses the recurrences (15.14)
and (15.15) to compute eŒi; j  and wŒi; j  for all 1  i  j  n. In the ﬁrst iteration, when l D 1, the loop computes eŒi; i and wŒi; i for i D 1; 2; : : : ; n. The second iteration, with l D 2, computes eŒi; i C1 and wŒi; i C1 for i D 1; 2; : : : ; n1,
and so forth. The innermost for loop, in lines 10–14, tries each candidate index r
to determine which key kr to use as the root of an optimal binary search tree containing keys ki ; : : : ; kj . This for loop saves the current value of the index r in
rootŒi; j  whenever it ﬁnds a better key to use as the root.
Figure 15.10 shows the tables eŒi; j , wŒi; j , and rootŒi; j  computed by the
procedure O PTIMAL -BST on the key distribution shown in Figure 15.9. As in the
matrix-chain multiplication example of Figure 15.5, the tables are rotated to make

15.5 Optimal binary search trees

403

e

w

5

j
2

1
2.75
2
1.75 2.00
3
3
1.25 1.20 1.30

5

i

4

1
1.00
2
0.70 0.80
3
3
0.55 0.50 0.60

j

4
0.90 0.70 0.60 0.90
5
0.45 0.40 0.25 0.30 0.50
0
6
0.05 0.10 0.05 0.05 0.05 0.10

4

2

i

4
0.45 0.35 0.30 0.50
5
0.30 0.25 0.15 0.20 0.35
0
6
0.05 0.10 0.05 0.05 0.05 0.10

1

1

root
5
j

2

3
2

2
1

1
1

1
2

4

2
2

2

3
5

4
3

i

2
4

4
5

4

5
5

Figure 15.10 The tables eŒi; j , wŒi; j , and rootŒi; j  computed by O PTIMAL -BST on the key
distribution shown in Figure 15.9. The tables are rotated so that the diagonals run horizontally.

the diagonals run horizontally. O PTIMAL -BST computes the rows from bottom to
top and from left to right within each row.
The O PTIMAL -BST procedure takes ‚.n3 / time, just like M ATRIX -C HAIN O RDER. We can easily see that its running time is O.n3 /, since its for loops are
nested three deep and each loop index takes on at most n values. The loop indices in
O PTIMAL -BST do not have exactly the same bounds as those in M ATRIX -C HAIN O RDER, but they are within at most 1 in all directions. Thus, like M ATRIX -C HAIN O RDER, the O PTIMAL -BST procedure takes .n3 / time.
Exercises
15.5-1
Write pseudocode for the procedure C ONSTRUCT-O PTIMAL -BST.root/ which,
given the table root, outputs the structure of an optimal binary search tree. For the
example in Figure 15.10, your procedure should print out the structure

404

Chapter 15 Dynamic Programming

k2 is the root
k1 is the left child of k2
d0 is the left child of k1
d1 is the right child of k1
k5 is the right child of k2
k4 is the left child of k5
k3 is the left child of k4
d2 is the left child of k3
d3 is the right child of k3
d4 is the right child of k4
d5 is the right child of k5
corresponding to the optimal binary search tree shown in Figure 15.9(b).
15.5-2
Determine the cost and structure of an optimal binary search tree for a set of n D 7
keys with the following probabilities:
i
pi
qi

0
0.06

1
0.04
0.06

2
0.06
0.06

3
0.08
0.06

4
0.02
0.05

5
0.10
0.05

6
0.12
0.05

7
0.14
0.05

15.5-3
Suppose that instead of maintaining the table wŒi; j , we computed the value
of w.i; j / directly from equation (15.12) in line 9 of O PTIMAL -BST and used this
computed value in line 11. How would this change affect the asymptotic running
time of O PTIMAL -BST?
15.5-4 ?
Knuth [212] has shown that there are always roots of optimal subtrees such that
rootŒi; j  1  rootŒi; j   rootŒi C 1; j  for all 1  i < j  n. Use this fact to
modify the O PTIMAL -BST procedure to run in ‚.n2 / time.

Problems
15-1 Longest simple path in a directed acyclic graph
Suppose that we are given a directed acyclic graph G D .V; E/ with realvalued edge weights and two distinguished vertices s and t. Describe a dynamicprogramming approach for ﬁnding a longest weighted simple path from s to t.
What does the subproblem graph look like? What is the efﬁciency of your algorithm?

Problems for Chapter 15

(a)

405

(b)

Figure 15.11 Seven points in the plane, shown on a unit grid. (a) The shortest closed tour, with
length approximately 24:89. This tour is not bitonic. (b) The shortest bitonic tour for the same set of
points. Its length is approximately 25:58.

15-2 Longest palindrome subsequence
A palindrome is a nonempty string over some alphabet that reads the same forward and backward. Examples of palindromes are all strings of length 1, civic,
racecar, and aibohphobia (fear of palindromes).
Give an efﬁcient algorithm to ﬁnd the longest palindrome that is a subsequence
of a given input string. For example, given the input character, your algorithm
should return carac. What is the running time of your algorithm?
15-3 Bitonic euclidean traveling-salesman problem
In the euclidean traveling-salesman problem, we are given a set of n points in
the plane, and we wish to ﬁnd the shortest closed tour that connects all n points.
Figure 15.11(a) shows the solution to a 7-point problem. The general problem is
NP-hard, and its solution is therefore believed to require more than polynomial
time (see Chapter 34).
J. L. Bentley has suggested that we simplify the problem by restricting our attention to bitonic tours, that is, tours that start at the leftmost point, go strictly
rightward to the rightmost point, and then go strictly leftward back to the starting
point. Figure 15.11(b) shows the shortest bitonic tour of the same 7 points. In this
case, a polynomial-time algorithm is possible.
Describe an O.n2 /-time algorithm for determining an optimal bitonic tour. You
may assume that no two points have the same x-coordinate and that all operations
on real numbers take unit time. (Hint: Scan left to right, maintaining optimal possibilities for the two parts of the tour.)
15-4 Printing neatly
Consider the problem of neatly printing a paragraph with a monospaced font (all
characters having the same width) on a printer. The input text is a sequence of n

406

Chapter 15 Dynamic Programming

words of lengths l1 ; l2 ; : : : ; ln , measured in characters. We want to print this paragraph neatly on a number of lines that hold a maximum of M characters each. Our
criterion of “neatness” is as follows. If a given line contains words i through j ,
where i  j , and we leave exactly one space between words,
Pj the number of extra
space characters at the end of the line is M  j C i  kDi lk , which must be
nonnegative so that the words ﬁt on the line. We wish to minimize the sum, over
all lines except the last, of the cubes of the numbers of extra space characters at the
ends of lines. Give a dynamic-programming algorithm to print a paragraph of n
words neatly on a printer. Analyze the running time and space requirements of
your algorithm.
15-5 Edit distance
In order to transform one source string of text xŒ1 : : m to a target string yŒ1 : : n,
we can perform various transformation operations. Our goal is, given x and y,
to produce a series of transformations that change x to y. We use an array ´—assumed to be large enough to hold all the characters it will need—to hold
the intermediate results. Initially, ´ is empty, and at termination, we should have
´Œj  D yŒj  for j D 1; 2; : : : ; n. We maintain current indices i into x and j into ´,
and the operations are allowed to alter ´ and these indices. Initially, i D j D 1.
We are required to examine every character in x during the transformation, which
means that at the end of the sequence of transformation operations, we must have
i D m C 1.
We may choose from among six transformation operations:
Copy a character from x to ´ by setting ´Œj  D xŒi and then incrementing both i
and j . This operation examines xŒi.
Replace a character from x by another character c, by setting ´Œj  D c, and then
incrementing both i and j . This operation examines xŒi.
Delete a character from x by incrementing i but leaving j alone. This operation
examines xŒi.
Insert the character c into ´ by setting ´Œj  D c and then incrementing j , but
leaving i alone. This operation examines no characters of x.
Twiddle (i.e., exchange) the next two characters by copying them from x to ´ but
in the opposite order; we do so by setting ´Œj  D xŒi C 1 and ´Œj C 1 D xŒi
and then setting i D i C 2 and j D j C 2. This operation examines xŒi
and xŒi C 1.
Kill the remainder of x by setting i D m C 1. This operation examines all characters in x that have not yet been examined. This operation, if performed, must
be the ﬁnal operation.

Problems for Chapter 15

407

As an example, one way to transform the source string algorithm to the target
string altruistic is to use the following sequence of operations, where the
underlined characters are xŒi and ´Œj  after the operation:
Operation
initial strings
copy
copy
replace by t
delete
copy
insert u
insert i
insert s
twiddle
insert c
kill

x
algorithm
algorithm
algorithm
algorithm
algorithm
algorithm
algorithm
algorithm
algorithm
algorithm
algorithm
algorithm

´
a
al
alt
alt
altr
altru
altrui
altruis
altruisti
altruistic
altruistic

Note that there are several other sequences of transformation operations that transform algorithm to altruistic.
Each of the transformation operations has an associated cost. The cost of an
operation depends on the speciﬁc application, but we assume that each operation’s
cost is a constant that is known to us. We also assume that the individual costs of
the copy and replace operations are less than the combined costs of the delete and
insert operations; otherwise, the copy and replace operations would not be used.
The cost of a given sequence of transformation operations is the sum of the costs
of the individual operations in the sequence. For the sequence above, the cost of
transforming algorithm to altruistic is
.3  cost.copy// C cost.replace/ C cost.delete/ C .4  cost.insert//
C cost.twiddle/ C cost.kill/ :
a. Given two sequences xŒ1 : : m and yŒ1 : : n and set of transformation-operation
costs, the edit distance from x to y is the cost of the least expensive operation
sequence that transforms x to y. Describe a dynamic-programming algorithm
that ﬁnds the edit distance from xŒ1 : : m to yŒ1 : : n and prints an optimal operation sequence. Analyze the running time and space requirements of your
algorithm.
The edit-distance problem generalizes the problem of aligning two DNA sequences
(see, for example, Setubal and Meidanis [310, Section 3.2]). There are several
methods for measuring the similarity of two DNA sequences by aligning them.
One such method to align two sequences x and y consists of inserting spaces at

408

Chapter 15 Dynamic Programming

arbitrary locations in the two sequences (including at either end) so that the resulting sequences x 0 and y 0 have the same length but do not have a space in the same
position (i.e., for no position j are both x 0 Œj  and y 0 Œj  a space). Then we assign a
“score” to each position. Position j receives a score as follows:


C1 if x 0 Œj  D y 0 Œj  and neither is a space,



1 if x 0 Œj  ¤ y 0 Œj  and neither is a space,



2 if either x 0 Œj  or y 0 Œj  is a space.

The score for the alignment is the sum of the scores of the individual positions. For
example, given the sequences x D GATCGGCAT and y D CAATGTGAATC, one
alignment is
G ATCG GCAT
CAAT GTGAATC
-*++*+*+-++*
A + under a position indicates a score of C1 for that position, a - indicates a score
of 1, and a * indicates a score of 2, so that this alignment has a total score of
6  1  2  1  4  2 D 4.
b. Explain how to cast the problem of ﬁnding an optimal alignment as an edit
distance problem using a subset of the transformation operations copy, replace,
delete, insert, twiddle, and kill.
15-6 Planning a company party
Professor Stewart is consulting for the president of a corporation that is planning
a company party. The company has a hierarchical structure; that is, the supervisor
relation forms a tree rooted at the president. The personnel ofﬁce has ranked each
employee with a conviviality rating, which is a real number. In order to make the
party fun for all attendees, the president does not want both an employee and his
or her immediate supervisor to attend.
Professor Stewart is given the tree that describes the structure of the corporation,
using the left-child, right-sibling representation described in Section 10.4. Each
node of the tree holds, in addition to the pointers, the name of an employee and
that employee’s conviviality ranking. Describe an algorithm to make up a guest
list that maximizes the sum of the conviviality ratings of the guests. Analyze the
running time of your algorithm.
15-7 Viterbi algorithm
We can use dynamic programming on a directed graph G D .V; E/ for speech
recognition. Each edge .u; / 2 E is labeled with a sound .u; / from a ﬁnite set † of sounds. The labeled graph is a formal model of a person speaking

Problems for Chapter 15

409

a restricted language. Each path in the graph starting from a distinguished vertex 0 2 V corresponds to a possible sequence of sounds produced by the model.
We deﬁne the label of a directed path to be the concatenation of the labels of the
edges on that path.
a. Describe an efﬁcient algorithm that, given an edge-labeled graph G with distinguished vertex 0 and a sequence s D h 1 ; 2 ; : : : ; k i of sounds from †,
returns a path in G that begins at 0 and has s as its label, if any such path exists.
Otherwise, the algorithm should return NO - SUCH - PATH. Analyze the running
time of your algorithm. (Hint: You may ﬁnd concepts from Chapter 22 useful.)
Now, suppose that every edge .u; / 2 E has an associated nonnegative probability p.u; / of traversing the edge .u; / from vertex u and thus producing the
corresponding sound. The sum of the probabilities of the edges leaving any vertex
equals 1. The probability of a path is deﬁned to be the product of the probabilities of its edges. We can view the probability of a path beginning at 0 as the
probability that a “random walk” beginning at 0 will follow the speciﬁed path,
where we randomly choose which edge to take leaving a vertex u according to the
probabilities of the available edges leaving u.
b. Extend your answer to part (a) so that if a path is returned, it is a most probable path starting at 0 and having label s. Analyze the running time of your
algorithm.
15-8 Image compression by seam carving
We are given a color picture consisting of an m n array AŒ1 : : m; 1 : : n of pixels,
where each pixel speciﬁes a triple of red, green, and blue (RGB) intensities. Suppose that we wish to compress this picture slightly. Speciﬁcally, we wish to remove
one pixel from each of the m rows, so that the whole picture becomes one pixel
narrower. To avoid disturbing visual effects, however, we require that the pixels
removed in two adjacent rows be in the same or adjacent columns; the pixels removed form a “seam” from the top row to the bottom row where successive pixels
in the seam are adjacent vertically or diagonally.
a. Show that the number of such possible seams grows at least exponentially in m,
assuming that n > 1.
b. Suppose now that along with each pixel AŒi; j , we have calculated a realvalued disruption measure d Œi; j , indicating how disruptive it would be to
remove pixel AŒi; j . Intuitively, the lower a pixel’s disruption measure, the
more similar the pixel is to its neighbors. Suppose further that we deﬁne the
disruption measure of a seam to be the sum of the disruption measures of its
pixels.

410

Chapter 15 Dynamic Programming

Give an algorithm to ﬁnd a seam with the lowest disruption measure. How
efﬁcient is your algorithm?
15-9 Breaking a string
A certain string-processing language allows a programmer to break a string into
two pieces. Because this operation copies the string, it costs n time units to break
a string of n characters into two pieces. Suppose a programmer wants to break
a string into many pieces. The order in which the breaks occur can affect the
total amount of time used. For example, suppose that the programmer wants to
break a 20-character string after characters 2, 8, and 10 (numbering the characters
in ascending order from the left-hand end, starting from 1). If she programs the
breaks to occur in left-to-right order, then the ﬁrst break costs 20 time units, the
second break costs 18 time units (breaking the string from characters 3 to 20 at
character 8), and the third break costs 12 time units, totaling 50 time units. If she
programs the breaks to occur in right-to-left order, however, then the ﬁrst break
costs 20 time units, the second break costs 10 time units, and the third break costs
8 time units, totaling 38 time units. In yet another order, she could break ﬁrst at 8
(costing 20), then break the left piece at 2 (costing 8), and ﬁnally the right piece
at 10 (costing 12), for a total cost of 40.
Design an algorithm that, given the numbers of characters after which to break,
determines a least-cost way to sequence those breaks. More formally, given a
string S with n characters and an array LŒ1 : : m containing the break points, compute the lowest cost for a sequence of breaks, along with a sequence of breaks that
achieves this cost.
15-10 Planning an investment strategy
Your knowledge of algorithms helps you obtain an exciting job with the Acme
Computer Company, along with a $10,000 signing bonus. You decide to invest
this money with the goal of maximizing your return at the end of 10 years. You
decide to use the Amalgamated Investment Company to manage your investments.
Amalgamated Investments requires you to observe the following rules. It offers n
different investments, numbered 1 through n. In each year j , investment i provides
a return rate of rij . In other words, if you invest d dollars in investment i in year j ,
then at the end of year j , you have drij dollars. The return rates are guaranteed,
that is, you are given all the return rates for the next 10 years for each investment.
You make investment decisions only once per year. At the end of each year, you
can leave the money made in the previous year in the same investments, or you
can shift money to other investments, by either shifting money between existing
investments or moving money to a new investement. If you do not move your
money between two consecutive years, you pay a fee of f1 dollars, whereas if you
switch your money, you pay a fee of f2 dollars, where f2 > f1 .

Problems for Chapter 15

411

a. The problem, as stated, allows you to invest your money in multiple investments
in each year. Prove that there exists an optimal investment strategy that, in
each year, puts all the money into a single investment. (Recall that an optimal
investment strategy maximizes the amount of money after 10 years and is not
concerned with any other objectives, such as minimizing risk.)
b. Prove that the problem of planning your optimal investment strategy exhibits
optimal substructure.
c. Design an algorithm that plans your optimal investment strategy. What is the
running time of your algorithm?
d. Suppose that Amalgamated Investments imposed the additional restriction that,
at any point, you can have no more than $15,000 in any one investment. Show
that the problem of maximizing your income at the end of 10 years no longer
exhibits optimal substructure.
15-11 Inventory planning
The Rinky Dink Company makes machines that resurface ice rinks. The demand
for such products varies from month to month, and so the company needs to develop a strategy to plan its manufacturing given the ﬂuctuating, but predictable,
demand. The company wishes to design a plan for the next n months. For each
month i, the company P
knows the demand di , that is, the number of machines that
it will sell. Let D D niD1 di be the total demand over the next n months. The
company keeps a full-time staff who provide labor to manufacture up to m machines per month. If the company needs to make more than m machines in a given
month, it can hire additional, part-time labor, at a cost that works out to c dollars
per machine. Furthermore, if, at the end of a month, the company is holding any
unsold machines, it must pay inventory costs. The cost for holding j machines is
given as a function h.j / for j D 1; 2; : : : ; D, where h.j /  0 for 1  j  D and
h.j /  h.j C 1/ for 1  j  D  1.
Give an algorithm that calculates a plan for the company that minimizes its costs
while fulﬁlling all the demand. The running time should be polyomial in n and D.
15-12 Signing free-agent baseball players
Suppose that you are the general manager for a major-league baseball team. During
the off-season, you need to sign some free-agent players for your team. The team
owner has given you a budget of $X to spend on free agents. You are allowed to
spend less than $X altogether, but the owner will ﬁre you if you spend any more
than $X .

412

Chapter 15 Dynamic Programming

You are considering N different positions, and for each position, P free-agent
players who play that position are available.8 Because you do not want to overload
your roster with too many players at any position, for each position you may sign
at most one free agent who plays that position. (If you do not sign any players at a
particular position, then you plan to stick with the players you already have at that
position.)
To determine how valuable a player is going to be, you decide to use a sabermetric statistic9 known as “VORP,” or “value over replacement player.” A player with
a higher VORP is more valuable than a player with a lower VORP. A player with a
higher VORP is not necessarily more expensive to sign than a player with a lower
VORP, because factors other than a player’s value determine how much it costs to
sign him.
For each available free-agent player, you have three pieces of information:


the player’s position,



the amount of money it will cost to sign the player, and



the player’s VORP.

Devise an algorithm that maximizes the total VORP of the players you sign while
spending no more than $X altogether. You may assume that each player signs for a
multiple of $100,000. Your algorithm should output the total VORP of the players
you sign, the total amount of money you spend, and a list of which players you
sign. Analyze the running time and space requirement of your algorithm.

Chapter notes
R. Bellman began the systematic study of dynamic programming in 1955. The
word “programming,” both here and in linear programming, refers to using a tabular solution method. Although optimization techniques incorporating elements of
dynamic programming were known earlier, Bellman provided the area with a solid
mathematical basis [37].

8 Although there are nine positions on a baseball team, N is not necesarily equal to 9 because some
general managers have particular ways of thinking about positions. For example, a general manager
might consider right-handed pitchers and left-handed pitchers to be separate “positions,” as well as
starting pitchers, long relief pitchers (relief pitchers who can pitch several innings), and short relief
pitchers (relief pitchers who normally pitch at most only one inning).
9 Sabermetrics is the application of statistical analysis to baseball records. It provides several ways
to compare the relative values of individual players.

Notes for Chapter 15

413

Galil and Park [125] classify dynamic-programming algorithms according to the
size of the table and the number of other table entries each entry depends on. They
call a dynamic-programming algorithm tD=eD if its table size is O.nt / and each
entry depends on O.ne / other entries. For example, the matrix-chain multiplication
algorithm in Section 15.2 would be 2D=1D, and the longest-common-subsequence
algorithm in Section 15.4 would be 2D=0D.
Hu and Shing [182, 183] give an O.n lg n/-time algorithm for the matrix-chain
multiplication problem.
The O.mn/-time algorithm for the longest-common-subsequence problem appears to be a folk algorithm. Knuth [70] posed the question of whether subquadratic
algorithms for the LCS problem exist. Masek and Paterson [244] answered this
question in the afﬁrmative by giving an algorithm that runs in O.mn= lg n/ time,
where n  m and the sequences are drawn from a set of bounded size. For the
special case in which no element appears more than once in an input sequence,
Szymanski [326] shows how to solve the problem in O..n C m/ lg.n C m// time.
Many of these results extend to the problem of computing string edit distances
(Problem 15-5).
An early paper on variable-length binary encodings by Gilbert and Moore [133]
had applications to constructing optimal binary search trees for the case in which all
probabilities pi are 0; this paper contains an O.n3 /-time algorithm. Aho, Hopcroft,
and Ullman [5] present the algorithm from Section 15.5. Exercise 15.5-4 is due to
Knuth [212]. Hu and Tucker [184] devised an algorithm for the case in which all
probabilities pi are 0 that uses O.n2 / time and O.n/ space; subsequently, Knuth
[211] reduced the time to O.n lg n/.
Problem 15-8 is due to Avidan and Shamir [27], who have posted on the Web a
wonderful video illustrating this image-compression technique.

16

Greedy Algorithms

Algorithms for optimization problems typically go through a sequence of steps,
with a set of choices at each step. For many optimization problems, using dynamic
programming to determine the best choices is overkill; simpler, more efﬁcient algorithms will do. A greedy algorithm always makes the choice that looks best at
the moment. That is, it makes a locally optimal choice in the hope that this choice
will lead to a globally optimal solution. This chapter explores optimization problems for which greedy algorithms provide optimal solutions. Before reading this
chapter, you should read about dynamic programming in Chapter 15, particularly
Section 15.3.
Greedy algorithms do not always yield optimal solutions, but for many problems
they do. We shall ﬁrst examine, in Section 16.1, a simple but nontrivial problem,
the activity-selection problem, for which a greedy algorithm efﬁciently computes
an optimal solution. We shall arrive at the greedy algorithm by ﬁrst considering a dynamic-programming approach and then showing that we can always make
greedy choices to arrive at an optimal solution. Section 16.2 reviews the basic
elements of the greedy approach, giving a direct approach for proving greedy algorithms correct. Section 16.3 presents an important application of greedy techniques: designing data-compression (Huffman) codes. In Section 16.4, we investigate some of the theory underlying combinatorial structures called “matroids,”
for which a greedy algorithm always produces an optimal solution. Finally, Section 16.5 applies matroids to solve a problem of scheduling unit-time tasks with
deadlines and penalties.
The greedy method is quite powerful and works well for a wide range of problems. Later chapters will present many algorithms that we can view as applications of the greedy method, including minimum-spanning-tree algorithms (Chapter 23), Dijkstra’s algorithm for shortest paths from a single source (Chapter 24),
and Chvátal’s greedy set-covering heuristic (Chapter 35). Minimum-spanning-tree
algorithms furnish a classic example of the greedy method. Although you can read

16.1 An activity-selection problem

415

this chapter and Chapter 23 independently of each other, you might ﬁnd it useful
to read them together.

16.1 An activity-selection problem
Our ﬁrst example is the problem of scheduling several competing activities that require exclusive use of a common resource, with a goal of selecting a maximum-size
set of mutually compatible activities. Suppose we have a set S D fa1 ; a2 ; : : : ; an g
of n proposed activities that wish to use a resource, such as a lecture hall, which
can serve only one activity at a time. Each activity ai has a start time si and a ﬁnish
time fi , where 0  si < fi < 1. If selected, activity ai takes place during the
half-open time interval Œsi ; fi /. Activities ai and aj are compatible if the intervals
Œsi ; fi / and Œsj ; fj / do not overlap. That is, ai and aj are compatible if si  fj
or sj  fi . In the activity-selection problem, we wish to select a maximum-size
subset of mutually compatible activities. We assume that the activities are sorted
in monotonically increasing order of ﬁnish time:
f1  f2  f3      fn1  fn :

(16.1)

(We shall see later the advantage that this assumption provides.) For example,
consider the following set S of activities:
i
si
fi

1
1
4

2
3
5

3
0
6

4
5
7

5
3
9

6
5
9

7
6
10

8
8
11

9
8
12

10
2
14

11
12
16

For this example, the subset fa3 ; a9 ; a11 g consists of mutually compatible activities.
It is not a maximum subset, however, since the subset fa1 ; a4 ; a8 ; a11 g is larger. In
fact, fa1 ; a4 ; a8 ; a11 g is a largest subset of mutually compatible activities; another
largest subset is fa2 ; a4 ; a9 ; a11 g.
We shall solve this problem in several steps. We start by thinking about a
dynamic-programming solution, in which we consider several choices when determining which subproblems to use in an optimal solution. We shall then observe that
we need to consider only one choice—the greedy choice—and that when we make
the greedy choice, only one subproblem remains. Based on these observations, we
shall develop a recursive greedy algorithm to solve the activity-scheduling problem. We shall complete the process of developing a greedy solution by converting
the recursive algorithm to an iterative one. Although the steps we shall go through
in this section are slightly more involved than is typical when developing a greedy
algorithm, they illustrate the relationship between greedy algorithms and dynamic
programming.

416

Chapter 16 Greedy Algorithms

The optimal substructure of the activity-selection problem
We can easily verify that the activity-selection problem exhibits optimal substructure. Let us denote by Sij the set of activities that start after activity ai ﬁnishes and
that ﬁnish before activity aj starts. Suppose that we wish to ﬁnd a maximum set of
mutually compatible activities in Sij , and suppose further that such a maximum set
is Aij , which includes some activity ak . By including ak in an optimal solution, we
are left with two subproblems: ﬁnding mutually compatible activities in the set Si k
(activities that start after activity ai ﬁnishes and that ﬁnish before activity ak starts)
and ﬁnding mutually compatible activities in the set Skj (activities that start after
activity ak ﬁnishes and that ﬁnish before activity aj starts). Let Ai k D Aij \ Si k
and Akj D Aij \ Skj , so that Ai k contains the activities in Aij that ﬁnish before ak
starts and Akj contains the activities in Aij that start after ak ﬁnishes. Thus, we
have Aij D Ai k [ fak g [ Akj , and so the maximum-size set Aij of mutually compatible activities in Sij consists of jAij j D jAi k j C jAkj j C 1 activities.
The usual cut-and-paste argument shows that the optimal solution Aij must also
include optimal solutions to the two subproblems for Si k and Skj . If we could
ﬁnd a set A0kj of mutually compatible activities in Skj where jA0kj j > jAkj j, then
we could use A0kj , rather than Akj , in a solution to the subproblem for Sij . We
would have constructed a set of jAi k j C jA0kj j C 1 > jAi k j C jAkj j C 1 D jAij j
mutually compatible activities, which contradicts the assumption that Aij is an
optimal solution. A symmetric argument applies to the activities in Si k .
This way of characterizing optimal substructure suggests that we might solve
the activity-selection problem by dynamic programming. If we denote the size of
an optimal solution for the set Sij by cŒi; j , then we would have the recurrence
cŒi; j  D cŒi; k C cŒk; j  C 1 :
Of course, if we did not know that an optimal solution for the set Sij includes
activity ak , we would have to examine all activities in Sij to ﬁnd which one to
choose, so that
(
0
if Sij D ; ;
cŒi; j  D max fcŒi; k C cŒk; j  C 1g if S ¤ ; :
(16.2)
ij
ak 2Sij

We could then develop a recursive algorithm and memoize it, or we could work
bottom-up and ﬁll in table entries as we go along. But we would be overlooking
another important characteristic of the activity-selection problem that we can use
to great advantage.

16.1 An activity-selection problem

417

Making the greedy choice
What if we could choose an activity to add to our optimal solution without having
to ﬁrst solve all the subproblems? That could save us from having to consider all
the choices inherent in recurrence (16.2). In fact, for the activity-selection problem,
we need consider only one choice: the greedy choice.
What do we mean by the greedy choice for the activity-selection problem? Intuition suggests that we should choose an activity that leaves the resource available
for as many other activities as possible. Now, of the activities we end up choosing, one of them must be the ﬁrst one to ﬁnish. Our intuition tells us, therefore,
to choose the activity in S with the earliest ﬁnish time, since that would leave the
resource available for as many of the activities that follow it as possible. (If more
than one activity in S has the earliest ﬁnish time, then we can choose any such
activity.) In other words, since the activities are sorted in monotonically increasing
order by ﬁnish time, the greedy choice is activity a1 . Choosing the ﬁrst activity
to ﬁnish is not the only way to think of making a greedy choice for this problem;
Exercise 16.1-3 asks you to explore other possibilities.
If we make the greedy choice, we have only one remaining subproblem to solve:
ﬁnding activities that start after a1 ﬁnishes. Why don’t we have to consider activities that ﬁnish before a1 starts? We have that s1 < f1 , and f1 is the earliest
ﬁnish time of any activity, and therefore no activity can have a ﬁnish time less than
or equal to s1 . Thus, all activities that are compatible with activity a1 must start
after a1 ﬁnishes.
Furthermore, we have already established that the activity-selection problem exhibits optimal substructure. Let Sk D fai 2 S W si  fk g be the set of activities that
start after activity ak ﬁnishes. If we make the greedy choice of activity a1 , then S1
remains as the only subproblem to solve.1 Optimal substructure tells us that if a1
is in the optimal solution, then an optimal solution to the original problem consists
of activity a1 and all the activities in an optimal solution to the subproblem S1 .
One big question remains: is our intuition correct? Is the greedy choice—in
which we choose the ﬁrst activity to ﬁnish—always part of some optimal solution?
The following theorem shows that it is.
1 We sometimes refer to the sets S

k as subproblems rather than as just sets of activities. It will always
be clear from the context whether we are referring to Sk as a set of activities or as a subproblem
whose input is that set.

418

Chapter 16 Greedy Algorithms

Theorem 16.1
Consider any nonempty subproblem Sk , and let am be an activity in Sk with the
earliest ﬁnish time. Then am is included in some maximum-size subset of mutually
compatible activities of Sk .
Proof Let Ak be a maximum-size subset of mutually compatible activities in Sk ,
and let aj be the activity in Ak with the earliest ﬁnish time. If aj D am , we are
done, since we have shown that am is in some maximum-size subset of mutually
compatible activities of Sk . If aj ¤ am , let the set A0k D Ak  faj g [ fam g be Ak
but substituting am for aj . The activities in A0k are disjoint, which follows because
the activities in Ak are disjoint, aj is the ﬁrst activity in Ak to ﬁnish, and fm  fj .
Since jA0k j D jAk j, we conclude that A0k is a maximum-size subset of mutually
compatible activities of Sk , and it includes am .
Thus, we see that although we might be able to solve the activity-selection problem with dynamic programming, we don’t need to. (Besides, we have not yet
examined whether the activity-selection problem even has overlapping subproblems.) Instead, we can repeatedly choose the activity that ﬁnishes ﬁrst, keep only
the activities compatible with this activity, and repeat until no activities remain.
Moreover, because we always choose the activity with the earliest ﬁnish time, the
ﬁnish times of the activities we choose must strictly increase. We can consider
each activity just once overall, in monotonically increasing order of ﬁnish times.
An algorithm to solve the activity-selection problem does not need to work
bottom-up, like a table-based dynamic-programming algorithm. Instead, it can
work top-down, choosing an activity to put into the optimal solution and then solving the subproblem of choosing activities from those that are compatible with those
already chosen. Greedy algorithms typically have this top-down design: make a
choice and then solve a subproblem, rather than the bottom-up technique of solving
subproblems before making a choice.
A recursive greedy algorithm
Now that we have seen how to bypass the dynamic-programming approach and instead use a top-down, greedy algorithm, we can write a straightforward, recursive
procedure to solve the activity-selection problem. The procedure R ECURSIVE ACTIVITY-S ELECTOR takes the start and ﬁnish times of the activities, represented
as arrays s and f ,2 the index k that deﬁnes the subproblem Sk it is to solve, and

2 Because

the pseudocode takes s and f as arrays, it indexes into them with square brackets rather
than subscripts.

16.1 An activity-selection problem

419

the size n of the original problem. It returns a maximum-size set of mutually compatible activities in Sk . We assume that the n input activities are already ordered
by monotonically increasing ﬁnish time, according to equation (16.1). If not, we
can sort them into this order in O.n lg n/ time, breaking ties arbitrarily. In order
to start, we add the ﬁctitious activity a0 with f0 D 0, so that subproblem S0 is
the entire set of activities S. The initial call, which solves the entire problem, is
R ECURSIVE -ACTIVITY-S ELECTOR .s; f; 0; n/.
R ECURSIVE -ACTIVITY-S ELECTOR .s; f; k; n/
1 m D kC1
2 while m  n and sŒm < f Œk
// ﬁnd the ﬁrst activity in Sk to ﬁnish
3
m D mC1
4 if m  n
5
return fam g [ R ECURSIVE -ACTIVITY-S ELECTOR .s; f; m; n/
6 else return ;
Figure 16.1 shows the operation of the algorithm. In a given recursive call
R ECURSIVE -ACTIVITY-S ELECTOR .s; f; k; n/, the while loop of lines 2–3 looks
for the ﬁrst activity in Sk to ﬁnish. The loop examines akC1 ; akC2 ; : : : ; an , until it ﬁnds the ﬁrst activity am that is compatible with ak ; such an activity has
sm  fk . If the loop terminates because it ﬁnds such an activity, line 5 returns
the union of fam g and the maximum-size subset of Sm returned by the recursive
call R ECURSIVE -ACTIVITY-S ELECTOR .s; f; m; n/. Alternatively, the loop may
terminate because m > n, in which case we have examined all activities in Sk
without ﬁnding one that is compatible with ak . In this case, Sk D ;, and so the
procedure returns ; in line 6.
Assuming that the activities have already been sorted by ﬁnish times, the running
time of the call R ECURSIVE -ACTIVITY-S ELECTOR .s; f; 0; n/ is ‚.n/, which we
can see as follows. Over all recursive calls, each activity is examined exactly once
in the while loop test of line 2. In particular, activity ai is examined in the last call
made in which k < i.
An iterative greedy algorithm
We easily can convert our recursive procedure to an iterative one. The procedure
R ECURSIVE -ACTIVITY-S ELECTOR is almost “tail recursive” (see Problem 7-4):
it ends with a recursive call to itself followed by a union operation. It is usually a
straightforward task to transform a tail-recursive procedure to an iterative form; in
fact, some compilers for certain programming languages perform this task automatically. As written, R ECURSIVE -ACTIVITY-S ELECTOR works for subproblems Sk ,
i.e., subproblems that consist of the last activities to ﬁnish.

420

Chapter 16 Greedy Algorithms

k

sk

fk

0

–

0

1

1

4

2

3

5

3

0

6

4

5

7

a0
a1
a0

RECURSIVE -ACTIVITY-SELECTOR(s, f, 0, 11)

m=1
a2

RECURSIVE -ACTIVITY-SELECTOR(s, f, 1, 11)

a1
a3
a1
a4
a1

m=4
RECURSIVE -ACTIVITY-SELECTOR(s, f, 4, 11)

5

3

9

6

5

9

7

6

10

8

8

11

9

8

12

10

2

14

11

12

16

a5
a1

a4

a1

a4

a1

a4

a1

a4

a6

a7

a8
m=8
a9

RECURSIVE -ACTIVITY -SELECTOR (s, f, 8, 11)
a1
a4

a8
a10

a1

a4

a8

a1

a4

a8

m = 11

a8

a11

a11

RECURSIVE -ACTIVITY -SELECTOR (s, f, 11, 11)
a1
a4

time
0

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

Figure 16.1 The operation of R ECURSIVE -ACTIVITY-S ELECTOR on the 11 activities given earlier. Activities considered in each recursive call appear between horizontal lines. The ﬁctitious
activity a0 ﬁnishes at time 0, and the initial call R ECURSIVE -ACTIVITY-S ELECTOR.s; f; 0; 11/, selects activity a1 . In each recursive call, the activities that have already been selected are shaded,
and the activity shown in white is being considered. If the starting time of an activity occurs before
the ﬁnish time of the most recently added activity (the arrow between them points left), it is rejected. Otherwise (the arrow points directly up or to the right), it is selected. The last recursive call,
R ECURSIVE -ACTIVITY-S ELECTOR.s; f; 11; 11/, returns ;. The resulting set of selected activities is
fa1 ; a4 ; a8 ; a11 g.

16.1 An activity-selection problem

421

The procedure G REEDY-ACTIVITY-S ELECTOR is an iterative version of the procedure R ECURSIVE -ACTIVITY-S ELECTOR. It also assumes that the input activities are ordered by monotonically increasing ﬁnish time. It collects selected activities into a set A and returns this set when it is done.
G REEDY-ACTIVITY-S ELECTOR .s; f /
1 n D s:length
2 A D fa1 g
3 k D1
4 for m D 2 to n
5
if sŒm  f Œk
6
A D A [ fam g
7
k Dm
8 return A
The procedure works as follows. The variable k indexes the most recent addition
to A, corresponding to the activity ak in the recursive version. Since we consider
the activities in order of monotonically increasing ﬁnish time, fk is always the
maximum ﬁnish time of any activity in A. That is,
fk D max ffi W ai 2 Ag :

(16.3)

Lines 2–3 select activity a1 , initialize A to contain just this activity, and initialize k
to index this activity. The for loop of lines 4–7 ﬁnds the earliest activity in Sk to
ﬁnish. The loop considers each activity am in turn and adds am to A if it is compatible with all previously selected activities; such an activity is the earliest in Sk to
ﬁnish. To see whether activity am is compatible with every activity currently in A,
it sufﬁces by equation (16.3) to check (in line 5) that its start time sm is not earlier
than the ﬁnish time fk of the activity most recently added to A. If activity am is
compatible, then lines 6–7 add activity am to A and set k to m. The set A returned
by the call G REEDY-ACTIVITY-S ELECTOR .s; f / is precisely the set returned by
the call R ECURSIVE -ACTIVITY-S ELECTOR .s; f; 0; n/.
Like the recursive version, G REEDY-ACTIVITY-S ELECTOR schedules a set of n
activities in ‚.n/ time, assuming that the activities were already sorted initially by
their ﬁnish times.
Exercises
16.1-1
Give a dynamic-programming algorithm for the activity-selection problem, based
on recurrence (16.2). Have your algorithm compute the sizes cŒi; j  as deﬁned
above and also produce the maximum-size subset of mutually compatible activities.

422

Chapter 16 Greedy Algorithms

Assume that the inputs have been sorted as in equation (16.1). Compare the running
time of your solution to the running time of G REEDY-ACTIVITY-S ELECTOR.
16.1-2
Suppose that instead of always selecting the ﬁrst activity to ﬁnish, we instead select
the last activity to start that is compatible with all previously selected activities. Describe how this approach is a greedy algorithm, and prove that it yields an optimal
solution.
16.1-3
Not just any greedy approach to the activity-selection problem produces a maximum-size set of mutually compatible activities. Give an example to show that
the approach of selecting the activity of least duration from among those that are
compatible with previously selected activities does not work. Do the same for
the approaches of always selecting the compatible activity that overlaps the fewest
other remaining activities and always selecting the compatible remaining activity
with the earliest start time.
16.1-4
Suppose that we have a set of activities to schedule among a large number of lecture
halls, where any activity can take place in any lecture hall. We wish to schedule
all the activities using as few lecture halls as possible. Give an efﬁcient greedy
algorithm to determine which activity should use which lecture hall.
(This problem is also known as the interval-graph coloring problem. We can
create an interval graph whose vertices are the given activities and whose edges
connect incompatible activities. The smallest number of colors required to color
every vertex so that no two adjacent vertices have the same color corresponds to
ﬁnding the fewest lecture halls needed to schedule all of the given activities.)
16.1-5
Consider a modiﬁcation to the activity-selection problem in which each activity ai
has, in addition to a start and ﬁnish time, a value i . The objective is no longer
to maximize the number of activities scheduled, but instead to maximize the total
value of the activities
P scheduled. That is, we wish to choose a set A of compatible
activities such that ak 2A k is maximized. Give a polynomial-time algorithm for
this problem.

16.2 Elements of the greedy strategy

423

16.2 Elements of the greedy strategy
A greedy algorithm obtains an optimal solution to a problem by making a sequence
of choices. At each decision point, the algorithm makes choice that seems best at
the moment. This heuristic strategy does not always produce an optimal solution,
but as we saw in the activity-selection problem, sometimes it does. This section
discusses some of the general properties of greedy methods.
The process that we followed in Section 16.1 to develop a greedy algorithm was
a bit more involved than is typical. We went through the following steps:
1. Determine the optimal substructure of the problem.
2. Develop a recursive solution. (For the activity-selection problem, we formulated recurrence (16.2), but we bypassed developing a recursive algorithm based
on this recurrence.)
3. Show that if we make the greedy choice, then only one subproblem remains.
4. Prove that it is always safe to make the greedy choice. (Steps 3 and 4 can occur
in either order.)
5. Develop a recursive algorithm that implements the greedy strategy.
6. Convert the recursive algorithm to an iterative algorithm.
In going through these steps, we saw in great detail the dynamic-programming underpinnings of a greedy algorithm. For example, in the activity-selection problem,
we ﬁrst deﬁned the subproblems Sij , where both i and j varied. We then found
that if we always made the greedy choice, we could restrict the subproblems to be
of the form Sk .
Alternatively, we could have fashioned our optimal substructure with a greedy
choice in mind, so that the choice leaves just one subproblem to solve. In the
activity-selection problem, we could have started by dropping the second subscript
and deﬁning subproblems of the form Sk . Then, we could have proven that a greedy
choice (the ﬁrst activity am to ﬁnish in Sk ), combined with an optimal solution to
the remaining set Sm of compatible activities, yields an optimal solution to Sk .
More generally, we design greedy algorithms according to the following sequence
of steps:
1. Cast the optimization problem as one in which we make a choice and are left
with one subproblem to solve.
2. Prove that there is always an optimal solution to the original problem that makes
the greedy choice, so that the greedy choice is always safe.

424

Chapter 16 Greedy Algorithms

3. Demonstrate optimal substructure by showing that, having made the greedy
choice, what remains is a subproblem with the property that if we combine an
optimal solution to the subproblem with the greedy choice we have made, we
arrive at an optimal solution to the original problem.
We shall use this more direct process in later sections of this chapter. Nevertheless, beneath every greedy algorithm, there is almost always a more cumbersome
dynamic-programming solution.
How can we tell whether a greedy algorithm will solve a particular optimization
problem? No way works all the time, but the greedy-choice property and optimal
substructure are the two key ingredients. If we can demonstrate that the problem
has these properties, then we are well on the way to developing a greedy algorithm
for it.
Greedy-choice property
The ﬁrst key ingredient is the greedy-choice property: we can assemble a globally
optimal solution by making locally optimal (greedy) choices. In other words, when
we are considering which choice to make, we make the choice that looks best in
the current problem, without considering results from subproblems.
Here is where greedy algorithms differ from dynamic programming. In dynamic
programming, we make a choice at each step, but the choice usually depends on the
solutions to subproblems. Consequently, we typically solve dynamic-programming
problems in a bottom-up manner, progressing from smaller subproblems to larger
subproblems. (Alternatively, we can solve them top down, but memoizing. Of
course, even though the code works top down, we still must solve the subproblems before making a choice.) In a greedy algorithm, we make whatever choice
seems best at the moment and then solve the subproblem that remains. The choice
made by a greedy algorithm may depend on choices so far, but it cannot depend on
any future choices or on the solutions to subproblems. Thus, unlike dynamic programming, which solves the subproblems before making the ﬁrst choice, a greedy
algorithm makes its ﬁrst choice before solving any subproblems. A dynamicprogramming algorithm proceeds bottom up, whereas a greedy strategy usually
progresses in a top-down fashion, making one greedy choice after another, reducing each given problem instance to a smaller one.
Of course, we must prove that a greedy choice at each step yields a globally
optimal solution. Typically, as in the case of Theorem 16.1, the proof examines
a globally optimal solution to some subproblem. It then shows how to modify
the solution to substitute the greedy choice for some other choice, resulting in one
similar, but smaller, subproblem.
We can usually make the greedy choice more efﬁciently than when we have to
consider a wider set of choices. For example, in the activity-selection problem, as-

16.2 Elements of the greedy strategy

425

suming that we had already sorted the activities in monotonically increasing order
of ﬁnish times, we needed to examine each activity just once. By preprocessing the
input or by using an appropriate data structure (often a priority queue), we often
can make greedy choices quickly, thus yielding an efﬁcient algorithm.
Optimal substructure
A problem exhibits optimal substructure if an optimal solution to the problem
contains within it optimal solutions to subproblems. This property is a key ingredient of assessing the applicability of dynamic programming as well as greedy
algorithms. As an example of optimal substructure, recall how we demonstrated in
Section 16.1 that if an optimal solution to subproblem Sij includes an activity ak ,
then it must also contain optimal solutions to the subproblems Si k and Skj . Given
this optimal substructure, we argued that if we knew which activity to use as ak , we
could construct an optimal solution to Sij by selecting ak along with all activities
in optimal solutions to the subproblems Si k and Skj . Based on this observation of
optimal substructure, we were able to devise the recurrence (16.2) that described
the value of an optimal solution.
We usually use a more direct approach regarding optimal substructure when
applying it to greedy algorithms. As mentioned above, we have the luxury of
assuming that we arrived at a subproblem by having made the greedy choice in
the original problem. All we really need to do is argue that an optimal solution to
the subproblem, combined with the greedy choice already made, yields an optimal
solution to the original problem. This scheme implicitly uses induction on the
subproblems to prove that making the greedy choice at every step produces an
optimal solution.
Greedy versus dynamic programming
Because both the greedy and dynamic-programming strategies exploit optimal substructure, you might be tempted to generate a dynamic-programming solution to a
problem when a greedy solution sufﬁces or, conversely, you might mistakenly think
that a greedy solution works when in fact a dynamic-programming solution is required. To illustrate the subtleties between the two techniques, let us investigate
two variants of a classical optimization problem.
The 0-1 knapsack problem is the following. A thief robbing a store ﬁnds n
items. The ith item is worth i dollars and weighs wi pounds, where i and wi are
integers. The thief wants to take as valuable a load as possible, but he can carry at
most W pounds in his knapsack, for some integer W . Which items should he take?
(We call this the 0-1 knapsack problem because for each item, the thief must either

426

Chapter 16 Greedy Algorithms

take it or leave it behind; he cannot take a fractional amount of an item or take an
item more than once.)
In the fractional knapsack problem, the setup is the same, but the thief can take
fractions of items, rather than having to make a binary (0-1) choice for each item.
You can think of an item in the 0-1 knapsack problem as being like a gold ingot
and an item in the fractional knapsack problem as more like gold dust.
Both knapsack problems exhibit the optimal-substructure property. For the 0-1
problem, consider the most valuable load that weighs at most W pounds. If we
remove item j from this load, the remaining load must be the most valuable load
weighing at most W  wj that the thief can take from the n  1 original items
excluding j . For the comparable fractional problem, consider that if we remove
a weight w of one item j from the optimal load, the remaining load must be the
most valuable load weighing at most W  w that the thief can take from the n  1
original items plus wj  w pounds of item j .
Although the problems are similar, we can solve the fractional knapsack problem
by a greedy strategy, but we cannot solve the 0-1 problem by such a strategy. To
solve the fractional problem, we ﬁrst compute the value per pound i =wi for each
item. Obeying a greedy strategy, the thief begins by taking as much as possible of
the item with the greatest value per pound. If the supply of that item is exhausted
and he can still carry more, he takes as much as possible of the item with the next
greatest value per pound, and so forth, until he reaches his weight limit W . Thus,
by sorting the items by value per pound, the greedy algorithm runs in O.n lg n/
time. We leave the proof that the fractional knapsack problem has the greedychoice property as Exercise 16.2-1.
To see that this greedy strategy does not work for the 0-1 knapsack problem,
consider the problem instance illustrated in Figure 16.2(a). This example has 3
items and a knapsack that can hold 50 pounds. Item 1 weighs 10 pounds and
is worth 60 dollars. Item 2 weighs 20 pounds and is worth 100 dollars. Item 3
weighs 30 pounds and is worth 120 dollars. Thus, the value per pound of item 1 is
6 dollars per pound, which is greater than the value per pound of either item 2 (5
dollars per pound) or item 3 (4 dollars per pound). The greedy strategy, therefore,
would take item 1 ﬁrst. As you can see from the case analysis in Figure 16.2(b),
however, the optimal solution takes items 2 and 3, leaving item 1 behind. The two
possible solutions that take item 1 are both suboptimal.
For the comparable fractional problem, however, the greedy strategy, which
takes item 1 ﬁrst, does yield an optimal solution, as shown in Figure 16.2(c). Taking item 1 doesn’t work in the 0-1 problem because the thief is unable to ﬁll his
knapsack to capacity, and the empty space lowers the effective value per pound of
his load. In the 0-1 problem, when we consider whether to include an item in the
knapsack, we must compare the solution to the subproblem that includes the item
with the solution to the subproblem that excludes the item before we can make the

16.2 Elements of the greedy strategy

item 1

+

30
20

20 $100

30 $120
20 $100
+
10

$100

$120 knapsack
(a)

$80
+

50

10
$60

20
30

30 $120

item 3
item 2

427

= $220

$60

= $160
(b)

10

+

20 $100
+

$60

10

= $180

$60

= $240
(c)

Figure 16.2 An example showing that the greedy strategy does not work for the 0-1 knapsack
problem. (a) The thief must select a subset of the three items shown whose weight must not exceed
50 pounds. (b) The optimal subset includes items 2 and 3. Any solution with item 1 is suboptimal,
even though item 1 has the greatest value per pound. (c) For the fractional knapsack problem, taking
the items in order of greatest value per pound yields an optimal solution.

choice. The problem formulated in this way gives rise to many overlapping subproblems—a hallmark of dynamic programming, and indeed, as Exercise 16.2-2
asks you to show, we can use dynamic programming to solve the 0-1 problem.
Exercises
16.2-1
Prove that the fractional knapsack problem has the greedy-choice property.
16.2-2
Give a dynamic-programming solution to the 0-1 knapsack problem that runs in
O.n W / time, where n is the number of items and W is the maximum weight of
items that the thief can put in his knapsack.
16.2-3
Suppose that in a 0-1 knapsack problem, the order of the items when sorted by
increasing weight is the same as their order when sorted by decreasing value. Give
an efﬁcient algorithm to ﬁnd an optimal solution to this variant of the knapsack
problem, and argue that your algorithm is correct.
16.2-4
Professor Gekko has always dreamed of inline skating across North Dakota. He
plans to cross the state on highway U.S. 2, which runs from Grand Forks, on the
eastern border with Minnesota, to Williston, near the western border with Montana.

428

Chapter 16 Greedy Algorithms

The professor can carry two liters of water, and he can skate m miles before running
out of water. (Because North Dakota is relatively ﬂat, the professor does not have
to worry about drinking water at a greater rate on uphill sections than on ﬂat or
downhill sections.) The professor will start in Grand Forks with two full liters of
water. His ofﬁcial North Dakota state map shows all the places along U.S. 2 at
which he can reﬁll his water and the distances between these locations.
The professor’s goal is to minimize the number of water stops along his route
across the state. Give an efﬁcient method by which he can determine which water
stops he should make. Prove that your strategy yields an optimal solution, and give
its running time.
16.2-5
Describe an efﬁcient algorithm that, given a set fx1 ; x2 ; : : : ; xn g of points on the
real line, determines the smallest set of unit-length closed intervals that contains
all of the given points. Argue that your algorithm is correct.
16.2-6 ?
Show how to solve the fractional knapsack problem in O.n/ time.
16.2-7
Suppose you are given two sets A and B, each containing n positive integers. You
can choose to reorder each set however you like. After reordering, let ai be the ith
element
Qn of set A, and let bi be the ith element of set B. You then receive a payoff
of i D1 ai bi . Give an algorithm that will maximize your payoff. Prove that your
algorithm maximizes the payoff, and state its running time.

16.3 Huffman codes
Huffman codes compress data very effectively: savings of 20% to 90% are typical,
depending on the characteristics of the data being compressed. We consider the
data to be a sequence of characters. Huffman’s greedy algorithm uses a table giving
how often each character occurs (i.e., its frequency) to build up an optimal way of
representing each character as a binary string.
Suppose we have a 100,000-character data ﬁle that we wish to store compactly.
We observe that the characters in the ﬁle occur with the frequencies given by Figure 16.3. That is, only 6 different characters appear, and the character a occurs
45,000 times.
We have many options for how to represent such a ﬁle of information. Here,
we consider the problem of designing a binary character code (or code for short)

16.3 Huffman codes

Frequency (in thousands)
Fixed-length codeword
Variable-length codeword

429

a
45
000
0

b
13
001
101

c
12
010
100

d
16
011
111

e
9
100
1101

f
5
101
1100

Figure 16.3 A character-coding problem. A data ﬁle of 100,000 characters contains only the characters a–f, with the frequencies indicated. If we assign each character a 3-bit codeword, we can
encode the ﬁle in 300,000 bits. Using the variable-length code shown, we can encode the ﬁle in only
224,000 bits.

in which each character is represented by a unique binary string, which we call a
codeword. If we use a ﬁxed-length code, we need 3 bits to represent 6 characters:
a = 000, b = 001, . . . , f = 101. This method requires 300,000 bits to code the
entire ﬁle. Can we do better?
A variable-length code can do considerably better than a ﬁxed-length code, by
giving frequent characters short codewords and infrequent characters long codewords. Figure 16.3 shows such a code; here the 1-bit string 0 represents a, and the
4-bit string 1100 represents f. This code requires
.45  1 C 13  3 C 12  3 C 16  3 C 9  4 C 5  4/  1,000 D 224,000 bits
to represent the ﬁle, a savings of approximately 25%. In fact, this is an optimal
character code for this ﬁle, as we shall see.
Preﬁx codes
We consider here only codes in which no codeword is also a preﬁx of some other
codeword. Such codes are called preﬁx codes.3 Although we won’t prove it here, a
preﬁx code can always achieve the optimal data compression among any character
code, and so we suffer no loss of generality by restricting our attention to preﬁx
codes.
Encoding is always simple for any binary character code; we just concatenate the
codewords representing each character of the ﬁle. For example, with the variablelength preﬁx code of Figure 16.3, we code the 3-character ﬁle abc as 0101100 D
0101100, where “” denotes concatenation.
Preﬁx codes are desirable because they simplify decoding. Since no codeword
is a preﬁx of any other, the codeword that begins an encoded ﬁle is unambiguous.
We can simply identify the initial codeword, translate it back to the original char-

3 Perhaps

literature.

“preﬁx-free codes” would be a better name, but the term “preﬁx codes” is standard in the

430

Chapter 16 Greedy Algorithms

100

100

0

1

0

86
0

14
1

58
0
a:45

0
c:12

55

0
28

1
b:13

1

a:45
0

14
1
d:16

0
e:9

1

25
1
f:5

0
c:12

30
1
b:13
0
f:5

(a)

0
14

1
d:16
1
e:9

(b)

Figure 16.4 Trees corresponding to the coding schemes in Figure 16.3. Each leaf is labeled with
a character and its frequency of occurrence. Each internal node is labeled with the sum of the frequencies of the leaves in its subtree. (a) The tree corresponding to the ﬁxed-length code a = 000, . . . ,
f = 101. (b) The tree corresponding to the optimal preﬁx code a = 0, b = 101, . . . , f = 1100.

acter, and repeat the decoding process on the remainder of the encoded ﬁle. In our
example, the string 001011101 parses uniquely as 0  0  101  1101, which decodes
to aabe.
The decoding process needs a convenient representation for the preﬁx code so
that we can easily pick off the initial codeword. A binary tree whose leaves are
the given characters provides one such representation. We interpret the binary
codeword for a character as the simple path from the root to that character, where 0
means “go to the left child” and 1 means “go to the right child.” Figure 16.4 shows
the trees for the two codes of our example. Note that these are not binary search
trees, since the leaves need not appear in sorted order and internal nodes do not
contain character keys.
An optimal code for a ﬁle is always represented by a full binary tree, in which
every nonleaf node has two children (see Exercise 16.3-2). The ﬁxed-length code
in our example is not optimal since its tree, shown in Figure 16.4(a), is not a full binary tree: it contains codewords beginning 10. . . , but none beginning 11. . . . Since
we can now restrict our attention to full binary trees, we can say that if C is the
alphabet from which the characters are drawn and all character frequencies are positive, then the tree for an optimal preﬁx code has exactly jC j leaves, one for each
letter of the alphabet, and exactly jC j  1 internal nodes (see Exercise B.5-3).
Given a tree T corresponding to a preﬁx code, we can easily compute the number
of bits required to encode a ﬁle. For each character c in the alphabet C , let the
attribute c:freq denote the frequency of c in the ﬁle and let dT .c/ denote the depth

16.3 Huffman codes

431

of c’s leaf in the tree. Note that dT .c/ is also the length of the codeword for
character c. The number of bits required to encode a ﬁle is thus
X
c:freq  dT .c/ ;
(16.4)
B.T / D
c2C

which we deﬁne as the cost of the tree T .
Constructing a Huffman code
Huffman invented a greedy algorithm that constructs an optimal preﬁx code called
a Huffman code. In line with our observations in Section 16.2, its proof of correctness relies on the greedy-choice property and optimal substructure. Rather
than demonstrating that these properties hold and then developing pseudocode, we
present the pseudocode ﬁrst. Doing so will help clarify how the algorithm makes
greedy choices.
In the pseudocode that follows, we assume that C is a set of n characters and
that each character c 2 C is an object with an attribute c:freq giving its frequency.
The algorithm builds the tree T corresponding to the optimal code in a bottom-up
manner. It begins with a set of jC j leaves and performs a sequence of jC j  1
“merging” operations to create the ﬁnal tree. The algorithm uses a min-priority
queue Q, keyed on the freq attribute, to identify the two least-frequent objects to
merge together. When we merge two objects, the result is a new object whose
frequency is the sum of the frequencies of the two objects that were merged.
H UFFMAN .C /
1 n D jC j
2 QDC
3 for i D 1 to n  1
4
allocate a new node ´
5
´:left D x D E XTRACT-M IN .Q/
6
´:right D y D E XTRACT-M IN .Q/
7
´:freq D x:freq C y:freq
8
I NSERT .Q; ´/
// return the root of the tree
9 return E XTRACT-M IN .Q/
For our example, Huffman’s algorithm proceeds as shown in Figure 16.5. Since
the alphabet contains 6 letters, the initial queue size is n D 6, and 5 merge steps
build the tree. The ﬁnal tree represents the optimal preﬁx code. The codeword for
a letter is the sequence of edge labels on the simple path from the root to the letter.
Line 2 initializes the min-priority queue Q with the characters in C . The for
loop in lines 3–8 repeatedly extracts the two nodes x and y of lowest frequency

432

(a)

Chapter 16 Greedy Algorithms

f:5

e:9

c:12

b:13

d:16

a:45

(b)

c:12

14

b:13

d:16

0
f:5

14

(c)
0
f:5

25

d:16
1
e:9

0
c:12

a:45

25

(d)

1
b:13

0
c:12

30
1
b:13

0
14
0
f:5

(e)

55

a:45
0
25
0
c:12

0
30

1
b:13
0
f:5

0
14

1
e:9

1
55

a:45
0

1
d:16
1
e:9

a:45
1
d:16

100

(f)
1

a:45

1
e:9

1

25
0
c:12

30
1
b:13
0
f:5

0
14

1
d:16
1
e:9

Figure 16.5 The steps of Huffman’s algorithm for the frequencies given in Figure 16.3. Each part
shows the contents of the queue sorted into increasing order by frequency. At each step, the two
trees with lowest frequencies are merged. Leaves are shown as rectangles containing a character
and its frequency. Internal nodes are shown as circles containing the sum of the frequencies of their
children. An edge connecting an internal node with its children is labeled 0 if it is an edge to a left
child and 1 if it is an edge to a right child. The codeword for a letter is the sequence of labels on the
edges connecting the root to the leaf for that letter. (a) The initial set of n D 6 nodes, one for each
letter. (b)–(e) Intermediate stages. (f) The ﬁnal tree.

from the queue, replacing them in the queue with a new node ´ representing their
merger. The frequency of ´ is computed as the sum of the frequencies of x and y
in line 7. The node ´ has x as its left child and y as its right child. (This order is
arbitrary; switching the left and right child of any node yields a different code of
the same cost.) After n  1 mergers, line 9 returns the one node left in the queue,
which is the root of the code tree.
Although the algorithm would produce the same result if we were to excise the
variables x and y—assigning directly to ´:left and ´:right in lines 5 and 6, and
changing line 7 to ´:freq D ´:left:freq C ´:right:freq—we shall use the node

16.3 Huffman codes

433

names x and y in the proof of correctness. Therefore, we ﬁnd it convenient to
leave them in.
To analyze the running time of Huffman’s algorithm, we assume that Q is implemented as a binary min-heap (see Chapter 6). For a set C of n characters, we
can initialize Q in line 2 in O.n/ time using the B UILD -M IN -H EAP procedure discussed in Section 6.3. The for loop in lines 3–8 executes exactly n  1 times, and
since each heap operation requires time O.lg n/, the loop contributes O.n lg n/ to
the running time. Thus, the total running time of H UFFMAN on a set of n characters is O.n lg n/. We can reduce the running time to O.n lg lg n/ by replacing the
binary min-heap with a van Emde Boas tree (see Chapter 20).
Correctness of Huffman’s algorithm
To prove that the greedy algorithm H UFFMAN is correct, we show that the problem of determining an optimal preﬁx code exhibits the greedy-choice and optimalsubstructure properties. The next lemma shows that the greedy-choice property
holds.
Lemma 16.2
Let C be an alphabet in which each character c 2 C has frequency c:freq. Let
x and y be two characters in C having the lowest frequencies. Then there exists
an optimal preﬁx code for C in which the codewords for x and y have the same
length and differ only in the last bit.
Proof The idea of the proof is to take the tree T representing an arbitrary optimal
preﬁx code and modify it to make a tree representing another optimal preﬁx code
such that the characters x and y appear as sibling leaves of maximum depth in the
new tree. If we can construct such a tree, then the codewords for x and y will have
the same length and differ only in the last bit.
Let a and b be two characters that are sibling leaves of maximum depth in T .
Without loss of generality, we assume that a:freq  b:freq and x:freq  y:freq.
Since x:freq and y:freq are the two lowest leaf frequencies, in order, and a:freq
and b:freq are two arbitrary frequencies, in order, we have x:freq  a:freq and
y:freq  b:freq.
In the remainder of the proof, it is possible that we could have x:freq D a:freq
or y:freq D b:freq. However, if we had x:freq D b:freq, then we would also have
a:freq D b:freq D x:freq D y:freq (see Exercise 16.3-1), and the lemma would
be trivially true. Thus, we will assume that x:freq ¤ b:freq, which means that
x ¤ b.
As Figure 16.6 shows, we exchange the positions in T of a and x to produce a
tree T 0 , and then we exchange the positions in T 0 of b and y to produce a tree T 00

434

Chapter 16 Greedy Algorithms

T′

T

T′′

x
y

a
y

a

b

a
b

x

b

x

y

Figure 16.6 An illustration of the key step in the proof of Lemma 16.2. In the optimal tree T ,
leaves a and b are two siblings of maximum depth. Leaves x and y are the two characters with the
lowest frequencies; they appear in arbitrary positions in T . Assuming that x ¤ b, swapping leaves a
and x produces tree T 0 , and then swapping leaves b and y produces tree T 00 . Since each swap does
not increase the cost, the resulting tree T 00 is also an optimal tree.

in which x and y are sibling leaves of maximum depth. (Note that if x D b but
y ¤ a, then tree T 00 does not have x and y as sibling leaves of maximum depth.
Because we assume that x ¤ b, this situation cannot occur.) By equation (16.4),
the difference in cost between T and T 0 is
B.T /  B.T 0 /
X
X
c:freq  dT .c/ 
c:freq  dT 0 .c/
D
c2C

D
D
D


c2C

x:freq  dT .x/ C a:freq  dT .a/  x:freq  dT 0 .x/  a:freq  dT 0 .a/
x:freq  dT .x/ C a:freq  dT .a/  x:freq  dT .a/  a:freq  dT .x/
.a:freq  x:freq/.dT .a/  dT .x//
0;

because both a:freq  x:freq and dT .a/  dT .x/ are nonnegative. More speciﬁcally, a:freq  x:freq is nonnegative because x is a minimum-frequency leaf, and
dT .a/dT .x/ is nonnegative because a is a leaf of maximum depth in T . Similarly,
exchanging y and b does not increase the cost, and so B.T 0 /  B.T 00 / is nonnegative. Therefore, B.T 00 /  B.T /, and since T is optimal, we have B.T /  B.T 00 /,
which implies B.T 00 / D B.T /. Thus, T 00 is an optimal tree in which x and y
appear as sibling leaves of maximum depth, from which the lemma follows.
Lemma 16.2 implies that the process of building up an optimal tree by mergers
can, without loss of generality, begin with the greedy choice of merging together
those two characters of lowest frequency. Why is this a greedy choice? We can
view the cost of a single merger as being the sum of the frequencies of the two items
being merged. Exercise 16.3-4 shows that the total cost of the tree constructed
equals the sum of the costs of its mergers. Of all possible mergers at each step,
H UFFMAN chooses the one that incurs the least cost.

16.3 Huffman codes

435

The next lemma shows that the problem of constructing optimal preﬁx codes has
the optimal-substructure property.
Lemma 16.3
Let C be a given alphabet with frequency c:freq deﬁned for each character c 2 C .
Let x and y be two characters in C with minimum frequency. Let C 0 be the
alphabet C with the characters x and y removed and a new character ´ added,
so that C 0 D C  fx; yg [ f´g. Deﬁne f for C 0 as for C , except that
´:freq D x:freq C y:freq. Let T 0 be any tree representing an optimal preﬁx code
for the alphabet C 0 . Then the tree T , obtained from T 0 by replacing the leaf node
for ´ with an internal node having x and y as children, represents an optimal preﬁx
code for the alphabet C .
Proof We ﬁrst show how to express the cost B.T / of tree T in terms of the
cost B.T 0 / of tree T 0 , by considering the component costs in equation (16.4).
For each character c 2 C  fx; yg, we have that dT .c/ D dT 0 .c/, and hence
c:freq  dT .c/ D c:freq  dT 0 .c/. Since dT .x/ D dT .y/ D dT 0 .´/ C 1, we have
x:freq  dT .x/ C y:freq  dT .y/ D .x:freq C y:freq/.dT 0 .´/ C 1/
D ´:freq  dT 0 .´/ C .x:freq C y:freq/ ;
from which we conclude that
B.T / D B.T 0 / C x:freq C y:freq
or, equivalently,
B.T 0 / D B.T /  x:freq  y:freq :
We now prove the lemma by contradiction. Suppose that T does not represent an optimal preﬁx code for C . Then there exists an optimal tree T 00 such that
B.T 00 / < B.T /. Without loss of generality (by Lemma 16.2), T 00 has x and y as
siblings. Let T 000 be the tree T 00 with the common parent of x and y replaced by a
leaf ´ with frequency ´:freq D x:freq C y:freq. Then
B.T 000 / D B.T 00 /  x:freq  y:freq
< B.T /  x:freq  y:freq
D B.T 0 / ;
yielding a contradiction to the assumption that T 0 represents an optimal preﬁx code
for C 0 . Thus, T must represent an optimal preﬁx code for the alphabet C .
Theorem 16.4
Procedure H UFFMAN produces an optimal preﬁx code.
Proof

Immediate from Lemmas 16.2 and 16.3.

436

Chapter 16 Greedy Algorithms

Exercises
16.3-1
Explain why, in the proof of Lemma 16.2, if x:freq D b:freq, then we must have
a:freq D b:freq D x:freq D y:freq.
16.3-2
Prove that a binary tree that is not full cannot correspond to an optimal preﬁx code.
16.3-3
What is an optimal Huffman code for the following set of frequencies, based on
the ﬁrst 8 Fibonacci numbers?
a:1 b:1 c:2 d:3 e:5 f:8 g:13 h:21
Can you generalize your answer to ﬁnd the optimal code when the frequencies are
the ﬁrst n Fibonacci numbers?
16.3-4
Prove that we can also express the total cost of a tree for a code as the sum, over
all internal nodes, of the combined frequencies of the two children of the node.
16.3-5
Prove that if we order the characters in an alphabet so that their frequencies
are monotonically decreasing, then there exists an optimal code whose codeword
lengths are monotonically increasing.
16.3-6
Suppose we have an optimal preﬁx code on a set C D f0; 1; : : : ; n  1g of characters and we wish to transmit this code using as few bits as possible. Show how to
represent any optimal preﬁx code on C using only 2n  1 C n dlg ne bits. (Hint:
Use 2n  1 bits to specify the structure of the tree, as discovered by a walk of the
tree.)
16.3-7
Generalize Huffman’s algorithm to ternary codewords (i.e., codewords using the
symbols 0, 1, and 2), and prove that it yields optimal ternary codes.
16.3-8
Suppose that a data ﬁle contains a sequence of 8-bit characters such that all 256
characters are about equally common: the maximum character frequency is less
than twice the minimum character frequency. Prove that Huffman coding in this
case is no more efﬁcient than using an ordinary 8-bit ﬁxed-length code.

16.4 Matroids and greedy methods

437

16.3-9
Show that no compression scheme can expect to compress a ﬁle of randomly chosen 8-bit characters by even a single bit. (Hint: Compare the number of possible
ﬁles with the number of possible encoded ﬁles.)

? 16.4 Matroids and greedy methods
In this section, we sketch a beautiful theory about greedy algorithms. This theory
describes many situations in which the greedy method yields optimal solutions. It
involves combinatorial structures known as “matroids.” Although this theory does
not cover all cases for which a greedy method applies (for example, it does not
cover the activity-selection problem of Section 16.1 or the Huffman-coding problem of Section 16.3), it does cover many cases of practical interest. Furthermore,
this theory has been extended to cover many applications; see the notes at the end
of this chapter for references.
Matroids
A matroid is an ordered pair M D .S;  / satisfying the following conditions.
1. S is a ﬁnite set.
2.  is a nonempty family of subsets of S, called the independent subsets of S,
such that if B 2  and A  B, then A 2  . We say that  is hereditary if it
satisﬁes this property. Note that the empty set ; is necessarily a member of  .
3. If A 2  , B 2  , and jAj < jBj, then there exists some element x 2 B  A
such that A [ fxg 2  . We say that M satisﬁes the exchange property.
The word “matroid” is due to Hassler Whitney. He was studying matric matroids, in which the elements of S are the rows of a given matrix and a set of rows is
independent if they are linearly independent in the usual sense. As Exercise 16.4-2
asks you to show, this structure deﬁnes a matroid.
As another example of matroids, consider the graphic matroid MG D .SG ;  G /
deﬁned in terms of a given undirected graph G D .V; E/ as follows:



The set SG is deﬁned to be E, the set of edges of G.
If A is a subset of E, then A 2  G if and only if A is acyclic. That is, a set of
edges A is independent if and only if the subgraph GA D .V; A/ forms a forest.

The graphic matroid MG is closely related to the minimum-spanning-tree problem,
which Chapter 23 covers in detail.

438

Chapter 16 Greedy Algorithms

Theorem 16.5
If G D .V; E/ is an undirected graph, then MG D .SG ;  G / is a matroid.
Proof Clearly, SG D E is a ﬁnite set. Furthermore,  G is hereditary, since a
subset of a forest is a forest. Putting it another way, removing edges from an
acyclic set of edges cannot create cycles.
Thus, it remains to show that MG satisﬁes the exchange property. Suppose that
GA D .V; A/ and GB D .V; B/ are forests of G and that jBj > jAj. That is, A
and B are acyclic sets of edges, and B contains more edges than A does.
We claim that a forest F D .VF ; EF / contains exactly jVF j  jEF j trees. To
see why, suppose that F consists of t trees, where the ith tree contains i vertices
and ei edges. Then, we have
jEF j D

t
X

ei

i D1

D

t
X
.i  1/ (by Theorem B.2)
i D1

D

t
X

i  t

i D1

D jVF j  t ;
which implies that t D jVF j  jEF j. Thus, forest GA contains jV j  jAj trees, and
forest GB contains jV j  jBj trees.
Since forest GB has fewer trees than forest GA does, forest GB must contain
some tree T whose vertices are in two different trees in forest GA . Moreover,
since T is connected, it must contain an edge .u; / such that vertices u and 
are in different trees in forest GA . Since the edge .u; / connects vertices in two
different trees in forest GA , we can add the edge .u; / to forest GA without creating
a cycle. Therefore, MG satisﬁes the exchange property, completing the proof that
MG is a matroid.
Given a matroid M D .S;  /, we call an element x … A an extension of A 2 
if we can add x to A while preserving independence; that is, x is an extension
of A if A [ fxg 2  . As an example, consider a graphic matroid MG . If A is an
independent set of edges, then edge e is an extension of A if and only if e is not
in A and the addition of e to A does not create a cycle.
If A is an independent subset in a matroid M , we say that A is maximal if it has
no extensions. That is, A is maximal if it is not contained in any larger independent
subset of M . The following property is often useful.

16.4 Matroids and greedy methods

439

Theorem 16.6
All maximal independent subsets in a matroid have the same size.
Proof Suppose to the contrary that A is a maximal independent subset of M
and there exists another larger maximal independent subset B of M . Then, the
exchange property implies that for some x 2 B  A, we can extend A to a larger
independent set A [ fxg, contradicting the assumption that A is maximal.
As an illustration of this theorem, consider a graphic matroid MG for a connected, undirected graph G. Every maximal independent subset of MG must be a
free tree with exactly jV j  1 edges that connects all the vertices of G. Such a tree
is called a spanning tree of G.
We say that a matroid M D .S;  / is weighted if it is associated with a weight
function w that assigns a strictly positive weight w.x/ to each element x 2 S. The
weight function w extends to subsets of S by summation:
X
w.x/
w.A/ D
x2A

for any A  S. For example, if we let w.e/ denote the weight of an edge e in a
graphic matroid MG , then w.A/ is the total weight of the edges in edge set A.
Greedy algorithms on a weighted matroid
Many problems for which a greedy approach provides optimal solutions can be formulated in terms of ﬁnding a maximum-weight independent subset in a weighted
matroid. That is, we are given a weighted matroid M D .S;  /, and we wish to
ﬁnd an independent set A 2  such that w.A/ is maximized. We call such a subset that is independent and has maximum possible weight an optimal subset of the
matroid. Because the weight w.x/ of any element x 2 S is positive, an optimal
subset is always a maximal independent subset—it always helps to make A as large
as possible.
For example, in the minimum-spanning-tree problem, we are given a connected
undirected graph G D .V; E/ and a length function w such that w.e/ is the (positive) length of edge e. (We use the term “length” here to refer to the original edge
weights for the graph, reserving the term “weight” to refer to the weights in the
associated matroid.) We wish to ﬁnd a subset of the edges that connects all of
the vertices together and has minimum total length. To view this as a problem of
ﬁnding an optimal subset of a matroid, consider the weighted matroid MG with
weight function w 0 , where w 0 .e/ D w0  w.e/ and w0 is larger than the maximum
length of any edge. In this weighted matroid, all weights are positive and an optimal subset is a spanning tree of minimum total length in the original graph. More
speciﬁcally, each maximal independent subset A corresponds to a spanning tree

440

Chapter 16 Greedy Algorithms

with jV j  1 edges, and since
X
w 0 .e/
w 0 .A/ D
e2A

X
.w0  w.e//
D
e2A

D .jV j  1/w0 

X

w.e/

e2A

D .jV j  1/w0  w.A/
for any maximal independent subset A, an independent subset that maximizes the
quantity w 0 .A/ must minimize w.A/. Thus, any algorithm that can ﬁnd an optimal
subset A in an arbitrary matroid can solve the minimum-spanning-tree problem.
Chapter 23 gives algorithms for the minimum-spanning-tree problem, but here
we give a greedy algorithm that works for any weighted matroid. The algorithm
takes as input a weighted matroid M D .S;  / with an associated positive weight
function w, and it returns an optimal subset A. In our pseudocode, we denote the
components of M by M:S and M: and the weight function by w. The algorithm
is greedy because it considers in turn each element x 2 S, in order of monotonically decreasing weight, and immediately adds it to the set A being accumulated if
A [ fxg is independent.
G REEDY .M; w/
1 AD;
2 sort M:S into monotonically decreasing order by weight w
3 for each x 2 M:S, taken in monotonically decreasing order by weight w.x/
4
if A [ fxg 2 M:
5
A D A [ fxg
6 return A
Line 4 checks whether adding each element x to A would maintain A as an independent set. If A would remain independent, then line 5 adds x to A. Otherwise, x
is discarded. Since the empty set is independent, and since each iteration of the for
loop maintains A’s independence, the subset A is always independent, by induction. Therefore, G REEDY always returns an independent subset A. We shall see in
a moment that A is a subset of maximum possible weight, so that A is an optimal
subset.
The running time of G REEDY is easy to analyze. Let n denote jSj. The sorting
phase of G REEDY takes time O.n lg n/. Line 4 executes exactly n times, once for
each element of S. Each execution of line 4 requires a check on whether or not
the set A [ fxg is independent. If each such check takes time O.f .n//, the entire
algorithm runs in time O.n lg n C nf .n//.

16.4 Matroids and greedy methods

441

We now prove that G REEDY returns an optimal subset.
Lemma 16.7 (Matroids exhibit the greedy-choice property)
Suppose that M D .S;  / is a weighted matroid with weight function w and that S
is sorted into monotonically decreasing order by weight. Let x be the ﬁrst element
of S such that fxg is independent, if any such x exists. If x exists, then there exists
an optimal subset A of S that contains x.
Proof If no such x exists, then the only independent subset is the empty set and
the lemma is vacuously true. Otherwise, let B be any nonempty optimal subset.
Assume that x … B; otherwise, letting A D B gives an optimal subset of S that
contains x.
No element of B has weight greater than w.x/. To see why, observe that y 2 B
implies that fyg is independent, since B 2  and  is hereditary. Our choice of x
therefore ensures that w.x/  w.y/ for any y 2 B.
Construct the set A as follows. Begin with A D fxg. By the choice of x, set A is
independent. Using the exchange property, repeatedly ﬁnd a new element of B that
we can add to A until jAj D jBj, while preserving the independence of A. At that
point, A and B are the same except that A has x and B has some other element y.
That is, A D B  fyg [ fxg for some y 2 B, and so
w.A/ D w.B/  w.y/ C w.x/
 w.B/ :
Because set B is optimal, set A, which contains x, must also be optimal.
We next show that if an element is not an option initially, then it cannot be an
option later.
Lemma 16.8
Let M D .S;  / be any matroid. If x is an element of S that is an extension of
some independent subset A of S, then x is also an extension of ;.
Proof Since x is an extension of A, we have that A [ fxg is independent. Since 
is hereditary, fxg must be independent. Thus, x is an extension of ;.
Corollary 16.9
Let M D .S;  / be any matroid. If x is an element of S such that x is not an
extension of ;, then x is not an extension of any independent subset A of S.
Proof

This corollary is simply the contrapositive of Lemma 16.8.

442

Chapter 16 Greedy Algorithms

Corollary 16.9 says that any element that cannot be used immediately can never
be used. Therefore, G REEDY cannot make an error by passing over any initial
elements in S that are not an extension of ;, since they can never be used.
Lemma 16.10 (Matroids exhibit the optimal-substructure property)
Let x be the ﬁrst element of S chosen by G REEDY for the weighted matroid
M D .S;  /. The remaining problem of ﬁnding a maximum-weight independent subset containing x reduces to ﬁnding a maximum-weight independent subset
of the weighted matroid M 0 D .S 0 ;  0 /, where
S 0 D fy 2 S W fx; yg 2  g ;
 0 D fB  S  fxg W B [ fxg 2  g ;
and the weight function for M 0 is the weight function for M , restricted to S 0 . (We
call M 0 the contraction of M by the element x.)
Proof If A is any maximum-weight independent subset of M containing x, then
A0 D A  fxg is an independent subset of M 0 . Conversely, any independent subset A0 of M 0 yields an independent subset A D A0 [ fxg of M . Since we have in
both cases that w.A/ D w.A0 / C w.x/, a maximum-weight solution in M containing x yields a maximum-weight solution in M 0 , and vice versa.
Theorem 16.11 (Correctness of the greedy algorithm on matroids)
If M D .S;  / is a weighted matroid with weight function w, then G REEDY .M; w/
returns an optimal subset.
Proof By Corollary 16.9, any elements that G REEDY passes over initially because they are not extensions of ; can be forgotten about, since they can never
be useful. Once G REEDY selects the ﬁrst element x, Lemma 16.7 implies that
the algorithm does not err by adding x to A, since there exists an optimal subset
containing x. Finally, Lemma 16.10 implies that the remaining problem is one of
ﬁnding an optimal subset in the matroid M 0 that is the contraction of M by x.
After the procedure G REEDY sets A to fxg, we can interpret all of its remaining
steps as acting in the matroid M 0 D .S 0 ;  0 /, because B is independent in M 0 if
and only if B [ fxg is independent in M , for all sets B 2  0 . Thus, the subsequent
operation of G REEDY will ﬁnd a maximum-weight independent subset for M 0 , and
the overall operation of G REEDY will ﬁnd a maximum-weight independent subset
for M .

16.5 A task-scheduling problem as a matroid

443

Exercises
16.4-1
Show that .S;  k / is a matroid, where S is any ﬁnite set and  k is the set of all
subsets of S of size at most k, where k  jSj.
16.4-2 ?
Given an m n matrix T over some ﬁeld (such as the reals), show that .S;  / is a
matroid, where S is the set of columns of T and A 2  if and only if the columns
in A are linearly independent.
16.4-3 ?
Show that if .S;  / is a matroid, then .S;  0 / is a matroid, where
 0 D fA0 W S  A0 contains some maximal A 2  g :
That is, the maximal independent sets of .S;  0 / are just the complements of the
maximal independent sets of .S;  /.
16.4-4 ?
Let S be a ﬁnite set and let S1 ; S2 ; : : : ; Sk be a partition of S into nonempty disjoint
subsets. Deﬁne the structure .S;  / by the condition that  D fA W jA \ Si j  1
for i D 1; 2; : : : ; kg. Show that .S;  / is a matroid. That is, the set of all sets A
that contain at most one member of each subset in the partition determines the
independent sets of a matroid.
16.4-5
Show how to transform the weight function of a weighted matroid problem, where
the desired optimal solution is a minimum-weight maximal independent subset, to
make it a standard weighted-matroid problem. Argue carefully that your transformation is correct.

? 16.5 A task-scheduling problem as a matroid
An interesting problem that we can solve using matroids is the problem of optimally scheduling unit-time tasks on a single processor, where each task has a
deadline, along with a penalty paid if the task misses its deadline. The problem
looks complicated, but we can solve it in a surprisingly simple manner by casting
it as a matroid and using a greedy algorithm.
A unit-time task is a job, such as a program to be run on a computer, that requires
exactly one unit of time to complete. Given a ﬁnite set S of unit-time tasks, a

444

Chapter 16 Greedy Algorithms

schedule for S is a permutation of S specifying the order in which to perform
these tasks. The ﬁrst task in the schedule begins at time 0 and ﬁnishes at time 1,
the second task begins at time 1 and ﬁnishes at time 2, and so on.
The problem of scheduling unit-time tasks with deadlines and penalties for a
single processor has the following inputs:


a set S D fa1 ; a2 ; : : : ; an g of n unit-time tasks;



a set of n integer deadlines d1 ; d2 ; : : : ; dn , such that each di satisﬁes 1  di  n
and task ai is supposed to ﬁnish by time di ; and



a set of n nonnegative weights or penalties w1 ; w2 ; : : : ; wn , such that we incur
a penalty of wi if task ai is not ﬁnished by time di , and we incur no penalty if
a task ﬁnishes by its deadline.

We wish to ﬁnd a schedule for S that minimizes the total penalty incurred for
missed deadlines.
Consider a given schedule. We say that a task is late in this schedule if it ﬁnishes
after its deadline. Otherwise, the task is early in the schedule. We can always transform an arbitrary schedule into early-ﬁrst form, in which the early tasks precede
the late tasks. To see why, note that if some early task ai follows some late task aj ,
then we can switch the positions of ai and aj , and ai will still be early and aj will
still be late.
Furthermore, we claim that we can always transform an arbitrary schedule into
canonical form, in which the early tasks precede the late tasks and we schedule
the early tasks in order of monotonically increasing deadlines. To do so, we put
the schedule into early-ﬁrst form. Then, as long as there exist two early tasks ai
and aj ﬁnishing at respective times k and k C 1 in the schedule such that dj < di ,
we swap the positions of ai and aj . Since aj is early before the swap, k C 1  dj .
Therefore, k C 1 < di , and so ai is still early after the swap. Because task aj is
moved earlier in the schedule, it remains early after the swap.
The search for an optimal schedule thus reduces to ﬁnding a set A of tasks that
we assign to be early in the optimal schedule. Having determined A, we can create
the actual schedule by listing the elements of A in order of monotonically increasing deadlines, then listing the late tasks (i.e., S  A) in any order, producing a
canonical ordering of the optimal schedule.
We say that a set A of tasks is independent if there exists a schedule for these
tasks such that no tasks are late. Clearly, the set of early tasks for a schedule forms
an independent set of tasks. Let  denote the set of all independent sets of tasks.
Consider the problem of determining whether a given set A of tasks is independent. For t D 0; 1; 2; : : : ; n, let N t .A/ denote the number of tasks in A whose
deadline is t or earlier. Note that N0 .A/ D 0 for any set A.

16.5 A task-scheduling problem as a matroid

445

Lemma 16.12
For any set of tasks A, the following statements are equivalent.
1. The set A is independent.
2. For t D 0; 1; 2; : : : ; n, we have N t .A/  t.
3. If the tasks in A are scheduled in order of monotonically increasing deadlines,
then no task is late.
Proof To show that (1) implies (2), we prove the contrapositive: if N t .A/ > t for
some t, then there is no way to make a schedule with no late tasks for set A, because
more than t tasks must ﬁnish before time t. Therefore, (1) implies (2). If (2) holds,
then (3) must follow: there is no way to “get stuck” when scheduling the tasks in
order of monotonically increasing deadlines, since (2) implies that the ith largest
deadline is at least i. Finally, (3) trivially implies (1).
Using property 2 of Lemma 16.12, we can easily compute whether or not a given
set of tasks is independent (see Exercise 16.5-2).
The problem of minimizing the sum of the penalties of the late tasks is the same
as the problem of maximizing the sum of the penalties of the early tasks. The
following theorem thus ensures that we can use the greedy algorithm to ﬁnd an
independent set A of tasks with the maximum total penalty.
Theorem 16.13
If S is a set of unit-time tasks with deadlines, and  is the set of all independent
sets of tasks, then the corresponding system .S;  / is a matroid.
Proof Every subset of an independent set of tasks is certainly independent. To
prove the exchange property, suppose that B and A are independent sets of tasks
and that jBj > jAj. Let k be the largest t such that N t .B/  N t .A/. (Such a value
of t exists, since N0 .A/ D N0 .B/ D 0.) Since Nn .B/ D jBj and Nn .A/ D jAj,
but jBj > jAj, we must have that k < n and that Nj .B/ > Nj .A/ for all j in
the range k C 1  j  n. Therefore, B contains more tasks with deadline k C 1
than A does. Let ai be a task in B  A with deadline k C 1. Let A0 D A [ fai g.
We now show that A0 must be independent by using property 2 of Lemma 16.12.
For 0  t  k, we have N t .A0 / D N t .A/  t, since A is independent. For
k < t  n, we have N t .A0 /  N t .B/  t, since B is independent. Therefore, A0
is independent, completing our proof that .S;  / is a matroid.
By Theorem 16.11, we can use a greedy algorithm to ﬁnd a maximum-weight
independent set of tasks A. We can then create an optimal schedule having the
tasks in A as its early tasks. This method is an efﬁcient algorithm for scheduling

446

Chapter 16 Greedy Algorithms

ai

1

2

3

Task
4

5

6

7

di
wi

4
70

2
60

4
50

3
40

1
30

4
20

6
10

Figure 16.7 An instance of the problem of scheduling unit-time tasks with deadlines and penalties
for a single processor.

unit-time tasks with deadlines and penalties for a single processor. The running
time is O.n2 / using G REEDY, since each of the O.n/ independence checks made
by that algorithm takes time O.n/ (see Exercise 16.5-2). Problem 16-4 gives a
faster implementation.
Figure 16.7 demonstrates an example of the problem of scheduling unit-time
tasks with deadlines and penalties for a single processor. In this example, the
greedy algorithm selects, in order, tasks a1 , a2 , a3 , and a4 , then rejects a5 (because
N4 .fa1 ; a2 ; a3 ; a4 ; a5 g/ D 5) and a6 (because N4 .fa1 ; a2 ; a3 ; a4 ; a6 g/ D 5), and
ﬁnally accepts a7 . The ﬁnal optimal schedule is
ha2 ; a4 ; a1 ; a3 ; a7 ; a5 ; a6 i ;
which has a total penalty incurred of w5 C w6 D 50.
Exercises
16.5-1
Solve the instance of the scheduling problem given in Figure 16.7, but with each
penalty wi replaced by 80  wi .
16.5-2
Show how to use property 2 of Lemma 16.12 to determine in time O.jAj/ whether
or not a given set A of tasks is independent.

Problems
16-1 Coin changing
Consider the problem of making change for n cents using the fewest number of
coins. Assume that each coin’s value is an integer.
a. Describe a greedy algorithm to make change consisting of quarters, dimes,
nickels, and pennies. Prove that your algorithm yields an optimal solution.

Problems for Chapter 16

447

b. Suppose that the available coins are in the denominations that are powers of c,
i.e., the denominations are c 0 ; c 1 ; : : : ; c k for some integers c > 1 and k  1.
Show that the greedy algorithm always yields an optimal solution.
c. Give a set of coin denominations for which the greedy algorithm does not yield
an optimal solution. Your set should include a penny so that there is a solution
for every value of n.
d. Give an O.nk/-time algorithm that makes change for any set of k different coin
denominations, assuming that one of the coins is a penny.
16-2 Scheduling to minimize average completion time
Suppose you are given a set S D fa1 ; a2 ; : : : ; an g of tasks, where task ai requires pi units of processing time to complete, once it has started. You have one
computer on which to run these tasks, and the computer can run only one task at a
time. Let ci be the completion time of task ai , that is, the time at which task ai completes processing. P
Your goal is to minimize the average completion time, that is,
n
to minimize .1=n/ i D1 ci . For example, suppose there are two tasks, a1 and a2 ,
with p1 D 3 and p2 D 5, and consider the schedule in which a2 runs ﬁrst, followed
by a1 . Then c2 D 5, c1 D 8, and the average completion time is .5 C 8/=2 D 6:5.
If task a1 runs ﬁrst, however, then c1 D 3, c2 D 8, and the average completion
time is .3 C 8/=2 D 5:5.
a. Give an algorithm that schedules the tasks so as to minimize the average completion time. Each task must run non-preemptively, that is, once task ai starts, it
must run continuously for pi units of time. Prove that your algorithm minimizes
the average completion time, and state the running time of your algorithm.
b. Suppose now that the tasks are not all available at once. That is, each task
cannot start until its release time ri . Suppose also that we allow preemption, so
that a task can be suspended and restarted at a later time. For example, a task ai
with processing time pi D 6 and release time ri D 1 might start running at
time 1 and be preempted at time 4. It might then resume at time 10 but be
preempted at time 11, and it might ﬁnally resume at time 13 and complete at
time 15. Task ai has run for a total of 6 time units, but its running time has been
divided into three pieces. In this scenario, ai ’s completion time is 15. Give
an algorithm that schedules the tasks so as to minimize the average completion
time in this new scenario. Prove that your algorithm minimizes the average
completion time, and state the running time of your algorithm.

448

Chapter 16 Greedy Algorithms

16-3 Acyclic subgraphs
a. The incidence matrix for an undirected graph G D .V; E/ is a jV j jEj matrix M such that Me D 1 if edge e is incident on vertex , and Me D 0 otherwise. Argue that a set of columns of M is linearly independent over the ﬁeld
of integers modulo 2 if and only if the corresponding set of edges is acyclic.
Then, use the result of Exercise 16.4-2 to provide an alternate proof that .E;  /
of part (a) is a matroid.
b. Suppose that we associate a nonnegative weight w.e/ with each edge in an
undirected graph G D .V; E/. Give an efﬁcient algorithm to ﬁnd an acyclic
subset of E of maximum total weight.
c. Let G.V; E/ be an arbitrary directed graph, and let .E;  / be deﬁned so that
A 2  if and only if A does not contain any directed cycles. Give an example
of a directed graph G such that the associated system .E;  / is not a matroid.
Specify which deﬁning condition for a matroid fails to hold.
d. The incidence matrix for a directed graph G D .V; E/ with no self-loops is a
jV j jEj matrix M such that Me D 1 if edge e leaves vertex , Me D 1 if
edge e enters vertex , and Me D 0 otherwise. Argue that if a set of columns
of M is linearly independent, then the corresponding set of edges does not
contain a directed cycle.
e. Exercise 16.4-2 tells us that the set of linearly independent sets of columns of
any matrix M forms a matroid. Explain carefully why the results of parts (d)
and (e) are not contradictory. How can there fail to be a perfect correspondence between the notion of a set of edges being acyclic and the notion of the
associated set of columns of the incidence matrix being linearly independent?
16-4 Scheduling variations
Consider the following algorithm for the problem from Section 16.5 of scheduling
unit-time tasks with deadlines and penalties. Let all n time slots be initially empty,
where time slot i is the unit-length slot of time that ﬁnishes at time i. We consider
the tasks in order of monotonically decreasing penalty. When considering task aj ,
if there exists a time slot at or before aj ’s deadline dj that is still empty, assign aj
to the latest such slot, ﬁlling it. If there is no such slot, assign task aj to the latest
of the as yet unﬁlled slots.
a. Argue that this algorithm always gives an optimal answer.
b. Use the fast disjoint-set forest presented in Section 21.3 to implement the algorithm efﬁciently. Assume that the set of input tasks has already been sorted into

Problems for Chapter 16

449

monotonically decreasing order by penalty. Analyze the running time of your
implementation.
16-5 Off-line caching
Modern computers use a cache to store a small amount of data in a fast memory.
Even though a program may access large amounts of data, by storing a small subset
of the main memory in the cache—a small but faster memory—overall access time
can greatly decrease. When a computer program executes, it makes a sequence
hr1 ; r2 ; : : : ; rn i of n memory requests, where each request is for a particular data
element. For example, a program that accesses 4 distinct elements fa; b; c; d g
might make the sequence of requests hd; b; d; b; d; a; c; d; b; a; c; bi. Let k be the
size of the cache. When the cache contains k elements and the program requests the
.k C 1/st element, the system must decide, for this and each subsequent request,
which k elements to keep in the cache. More precisely, for each request ri , the
cache-management algorithm checks whether element ri is already in the cache. If
it is, then we have a cache hit; otherwise, we have a cache miss. Upon a cache
miss, the system retrieves ri from the main memory, and the cache-management
algorithm must decide whether to keep ri in the cache. If it decides to keep ri and
the cache already holds k elements, then it must evict one element to make room
for ri . The cache-management algorithm evicts data with the goal of minimizing
the number of cache misses over the entire sequence of requests.
Typically, caching is an on-line problem. That is, we have to make decisions
about which data to keep in the cache without knowing the future requests. Here,
however, we consider the off-line version of this problem, in which we are given
in advance the entire sequence of n requests and the cache size k, and we wish to
minimize the total number of cache misses.
We can solve this off-line problem by a greedy strategy called furthest-in-future,
which chooses to evict the item in the cache whose next access in the request
sequence comes furthest in the future.
a. Write pseudocode for a cache manager that uses the furthest-in-future strategy.
The input should be a sequence hr1 ; r2 ; : : : ; rn i of requests and a cache size k,
and the output should be a sequence of decisions about which data element (if
any) to evict upon each request. What is the running time of your algorithm?
b. Show that the off-line caching problem exhibits optimal substructure.
c. Prove that furthest-in-future produces the minimum possible number of cache
misses.

450

Chapter 16 Greedy Algorithms

Chapter notes
Much more material on greedy algorithms and matroids can be found in Lawler
[224] and Papadimitriou and Steiglitz [271].
The greedy algorithm ﬁrst appeared in the combinatorial optimization literature
in a 1971 article by Edmonds [101], though the theory of matroids dates back to
a 1935 article by Whitney [355].
Our proof of the correctness of the greedy algorithm for the activity-selection
problem is based on that of Gavril [131]. The task-scheduling problem is studied
in Lawler [224]; Horowitz, Sahni, and Rajasekaran [181]; and Brassard and Bratley
[54].
Huffman codes were invented in 1952 [185]; Lelewer and Hirschberg [231] surveys data-compression techniques known as of 1987.
An extension of matroid theory to greedoid theory was pioneered by Korte and
Lovász [216, 217, 218, 219], who greatly generalize the theory presented here.

17

Amortized Analysis

In an amortized analysis, we average the time required to perform a sequence of
data-structure operations over all the operations performed. With amortized analysis, we can show that the average cost of an operation is small, if we average over a
sequence of operations, even though a single operation within the sequence might
be expensive. Amortized analysis differs from average-case analysis in that probability is not involved; an amortized analysis guarantees the average performance
of each operation in the worst case.
The ﬁrst three sections of this chapter cover the three most common techniques
used in amortized analysis. Section 17.1 starts with aggregate analysis, in which
we determine an upper bound T .n/ on the total cost of a sequence of n operations.
The average cost per operation is then T .n/=n. We take the average cost as the
amortized cost of each operation, so that all operations have the same amortized
cost.
Section 17.2 covers the accounting method, in which we determine an amortized
cost of each operation. When there is more than one type of operation, each type of
operation may have a different amortized cost. The accounting method overcharges
some operations early in the sequence, storing the overcharge as “prepaid credit”
on speciﬁc objects in the data structure. Later in the sequence, the credit pays for
operations that are charged less than they actually cost.
Section 17.3 discusses the potential method, which is like the accounting method
in that we determine the amortized cost of each operation and may overcharge operations early on to compensate for undercharges later. The potential method maintains the credit as the “potential energy” of the data structure as a whole instead of
associating the credit with individual objects within the data structure.
We shall use two examples to examine these three methods. One is a stack
with the additional operation M ULTIPOP, which pops several objects at once. The
other is a binary counter that counts up from 0 by means of the single operation
I NCREMENT.

452

Chapter 17 Amortized Analysis

While reading this chapter, bear in mind that the charges assigned during an
amortized analysis are for analysis purposes only. They need not—and should
not—appear in the code. If, for example, we assign a credit to an object x when
using the accounting method, we have no need to assign an appropriate amount to
some attribute, such as x:credit, in the code.
When we perform an amortized analysis, we often gain insight into a particular
data structure, and this insight can help us optimize the design. In Section 17.4,
for example, we shall use the potential method to analyze a dynamically expanding
and contracting table.

17.1 Aggregate analysis
In aggregate analysis, we show that for all n, a sequence of n operations takes
worst-case time T .n/ in total. In the worst case, the average cost, or amortized
cost, per operation is therefore T .n/=n. Note that this amortized cost applies to
each operation, even when there are several types of operations in the sequence.
The other two methods we shall study in this chapter, the accounting method and
the potential method, may assign different amortized costs to different types of
operations.
Stack operations
In our ﬁrst example of aggregate analysis, we analyze stacks that have been augmented with a new operation. Section 10.1 presented the two fundamental stack
operations, each of which takes O.1/ time:
P USH .S; x/ pushes object x onto stack S.
P OP.S/ pops the top of stack S and returns the popped object. Calling P OP on an
empty stack generates an error.
Since each of these operations runs in O.1/ time, let us consider the cost of each
to be 1. The total cost of a sequence of n P USH and P OP operations is therefore n,
and the actual running time for n operations is therefore ‚.n/.
Now we add the stack operation M ULTIPOP .S; k/, which removes the k top objects of stack S, popping the entire stack if the stack contains fewer than k objects.
Of course, we assume that k is positive; otherwise the M ULTIPOP operation leaves
the stack unchanged. In the following pseudocode, the operation S TACK -E MPTY
returns TRUE if there are no objects currently on the stack, and FALSE otherwise.

17.1 Aggregate analysis

top

23
17
6
39
10
47
(a)

top

453

10
47
(b)

(c)

Figure 17.1 The action of M ULTIPOP on a stack S, shown initially in (a). The top 4 objects are
popped by M ULTIPOP.S; 4/, whose result is shown in (b). The next operation is M ULTIPOP.S; 7/,
which empties the stack—shown in (c)—since there were fewer than 7 objects remaining.

M ULTIPOP .S; k/
1 while not S TACK -E MPTY .S/ and k > 0
2
P OP.S/
3
k D k1
Figure 17.1 shows an example of M ULTIPOP.
What is the running time of M ULTIPOP .S; k/ on a stack of s objects? The
actual running time is linear in the number of P OP operations actually executed,
and thus we can analyze M ULTIPOP in terms of the abstract costs of 1 each for
P USH and P OP. The number of iterations of the while loop is the number min.s; k/
of objects popped off the stack. Each iteration of the loop makes one call to P OP in
line 2. Thus, the total cost of M ULTIPOP is min.s; k/, and the actual running time
is a linear function of this cost.
Let us analyze a sequence of n P USH, P OP, and M ULTIPOP operations on an initially empty stack. The worst-case cost of a M ULTIPOP operation in the sequence
is O.n/, since the stack size is at most n. The worst-case time of any stack operation is therefore O.n/, and hence a sequence of n operations costs O.n2 /, since we
may have O.n/ M ULTIPOP operations costing O.n/ each. Although this analysis
is correct, the O.n2 / result, which we obtained by considering the worst-case cost
of each operation individually, is not tight.
Using aggregate analysis, we can obtain a better upper bound that considers the
entire sequence of n operations. In fact, although a single M ULTIPOP operation
can be expensive, any sequence of n P USH, P OP, and M ULTIPOP operations on an
initially empty stack can cost at most O.n/. Why? We can pop each object from the
stack at most once for each time we have pushed it onto the stack. Therefore, the
number of times that P OP can be called on a nonempty stack, including calls within
M ULTIPOP, is at most the number of P USH operations, which is at most n. For any
value of n, any sequence of n P USH, P OP, and M ULTIPOP operations takes a total
of O.n/ time. The average cost of an operation is O.n/=n D O.1/. In aggregate

454

Chapter 17 Amortized Analysis

analysis, we assign the amortized cost of each operation to be the average cost. In
this example, therefore, all three stack operations have an amortized cost of O.1/.
We emphasize again that although we have just shown that the average cost, and
hence the running time, of a stack operation is O.1/, we did not use probabilistic
reasoning. We actually showed a worst-case bound of O.n/ on a sequence of n
operations. Dividing this total cost by n yielded the average cost per operation, or
the amortized cost.
Incrementing a binary counter
As another example of aggregate analysis, consider the problem of implementing
a k-bit binary counter that counts upward from 0. We use an array AŒ0 : : k  1 of
bits, where A:length D k, as the counter. A binary number x that is stored in the
counter has its lowest-order bit in AŒ0 and its highest-order bit in AŒk  1, so that
Pk1
x D i D0 AŒi  2i . Initially, x D 0, and thus AŒi D 0 for i D 0; 1; : : : ; k  1. To
add 1 (modulo 2k ) to the value in the counter, we use the following procedure.
I NCREMENT .A/
1 i D0
2 while i < A:length and AŒi == 1
3
AŒi D 0
4
i D i C1
5 if i < A:length
6
AŒi D 1
Figure 17.2 shows what happens to a binary counter as we increment it 16 times,
starting with the initial value 0 and ending with the value 16. At the start of
each iteration of the while loop in lines 2–4, we wish to add a 1 into position i.
If AŒi D 1, then adding 1 ﬂips the bit to 0 in position i and yields a carry of 1,
to be added into position i C 1 on the next iteration of the loop. Otherwise, the
loop ends, and then, if i < k, we know that AŒi D 0, so that line 6 adds a 1 into
position i, ﬂipping the 0 to a 1. The cost of each I NCREMENT operation is linear
in the number of bits ﬂipped.
As with the stack example, a cursory analysis yields a bound that is correct but
not tight. A single execution of I NCREMENT takes time ‚.k/ in the worst case, in
which array A contains all 1s. Thus, a sequence of n I NCREMENT operations on
an initially zero counter takes time O.nk/ in the worst case.
We can tighten our analysis to yield a worst-case cost of O.n/ for a sequence of n
I NCREMENT operations by observing that not all bits ﬂip each time I NCREMENT
is called. As Figure 17.2 shows, AŒ0 does ﬂip each time I NCREMENT is called.
The next bit up, AŒ1, ﬂips only every other time: a sequence of n I NCREMENT

Counter
value
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

455

A[
7
A[ ]
6
A[ ]
5
A[ ]
4
A[ ]
3]
A[
2
A[ ]
1]
A[
0]

17.1 Aggregate analysis

0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1

0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
0

0
0
0
0
1
1
1
1
0
0
0
0
1
1
1
1
0

0
0
1
1
0
0
1
1
0
0
1
1
0
0
1
1
0

0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0

Total
cost
0
1
3
4
7
8
10
11
15
16
18
19
22
23
25
26
31

Figure 17.2 An 8-bit binary counter as its value goes from 0 to 16 by a sequence of 16 I NCREMENT
operations. Bits that ﬂip to achieve the next value are shaded. The running cost for ﬂipping bits is
shown at the right. Notice that the total cost is always less than twice the total number of I NCREMENT
operations.

operations on an initially zero counter causes AŒ1 to ﬂip bn=2c times. Similarly,
bit AŒ2 ﬂips only every fourth time, or bn=4c times in a sequence of n I NCREMENT
operations. In general, for i D 0; 1; : : : ; k  1, bit AŒi ﬂips bn=2i c times in a
sequence of n I NCREMENT operations on an initially zero counter. For i  k,
bit AŒi does not exist, and so it cannot ﬂip. The total number of ﬂips in the
sequence is thus
k1 j
X
nk
i D0

2i

< n

1
X
1
2i
i D0

D 2n ;
by equation (A.6). The worst-case time for a sequence of n I NCREMENT operations
on an initially zero counter is therefore O.n/. The average cost of each operation,
and therefore the amortized cost per operation, is O.n/=n D O.1/.

456

Chapter 17 Amortized Analysis

Exercises
17.1-1
If the set of stack operations included a M ULTIPUSH operation, which pushes k
items onto the stack, would the O.1/ bound on the amortized cost of stack operations continue to hold?
17.1-2
Show that if a D ECREMENT operation were included in the k-bit counter example,
n operations could cost as much as ‚.nk/ time.
17.1-3
Suppose we perform a sequence of n operations on a data structure in which the ith
operation costs i if i is an exact power of 2, and 1 otherwise. Use aggregate analysis
to determine the amortized cost per operation.

17.2 The accounting method
In the accounting method of amortized analysis, we assign differing charges to
different operations, with some operations charged more or less than they actually cost. We call the amount we charge an operation its amortized cost. When
an operation’s amortized cost exceeds its actual cost, we assign the difference to
speciﬁc objects in the data structure as credit. Credit can help pay for later operations whose amortized cost is less than their actual cost. Thus, we can view the
amortized cost of an operation as being split between its actual cost and credit that
is either deposited or used up. Different operations may have different amortized
costs. This method differs from aggregate analysis, in which all operations have
the same amortized cost.
We must choose the amortized costs of operations carefully. If we want to show
that in the worst case the average cost per operation is small by analyzing with
amortized costs, we must ensure that the total amortized cost of a sequence of operations provides an upper bound on the total actual cost of the sequence. Moreover,
as in aggregate analysis, this relationship must hold for all sequences of operations. If we denote the actual cost of the ith operation by ci and the amortized cost
of the ith operation by cyi , we require
n
n
X
X
cyi 
ci
(17.1)
i D1

i D1

for all sequences of n operations. The total credit stored in the data structure
is the difference between the total amortized cost and the total actual cost, or

17.2 The accounting method

457

Pn
cyi  i D1 ci . By inequality (17.1), the total credit associated with the data
structure must be nonnegative at all times. If we ever were to allow the total credit
to become negative (the result of undercharging early operations with the promise
of repaying the account later on), then the total amortized costs incurred at that
time would be below the total actual costs incurred; for the sequence of operations
up to that time, the total amortized cost would not be an upper bound on the total
actual cost. Thus, we must take care that the total credit in the data structure never
becomes negative.
Pn

i D1

Stack operations
To illustrate the accounting method of amortized analysis, let us return to the stack
example. Recall that the actual costs of the operations were
P USH
P OP
M ULTIPOP

1,
1,
min.k; s/ ,

where k is the argument supplied to M ULTIPOP and s is the stack size when it is
called. Let us assign the following amortized costs:
P USH
P OP
M ULTIPOP

2,
0,
0.

Note that the amortized cost of M ULTIPOP is a constant (0), whereas the actual cost
is variable. Here, all three amortized costs are constant. In general, the amortized
costs of the operations under consideration may differ from each other, and they
may even differ asymptotically.
We shall now show that we can pay for any sequence of stack operations by
charging the amortized costs. Suppose we use a dollar bill to represent each unit
of cost. We start with an empty stack. Recall the analogy of Section 10.1 between
the stack data structure and a stack of plates in a cafeteria. When we push a plate
on the stack, we use 1 dollar to pay the actual cost of the push and are left with a
credit of 1 dollar (out of the 2 dollars charged), which we leave on top of the plate.
At any point in time, every plate on the stack has a dollar of credit on it.
The dollar stored on the plate serves as prepayment for the cost of popping it
from the stack. When we execute a P OP operation, we charge the operation nothing
and pay its actual cost using the credit stored in the stack. To pop a plate, we take
the dollar of credit off the plate and use it to pay the actual cost of the operation.
Thus, by charging the P USH operation a little bit more, we can charge the P OP
operation nothing.

458

Chapter 17 Amortized Analysis

Moreover, we can also charge M ULTIPOP operations nothing. To pop the ﬁrst
plate, we take the dollar of credit off the plate and use it to pay the actual cost of a
P OP operation. To pop a second plate, we again have a dollar of credit on the plate
to pay for the P OP operation, and so on. Thus, we have always charged enough
up front to pay for M ULTIPOP operations. In other words, since each plate on the
stack has 1 dollar of credit on it, and the stack always has a nonnegative number of
plates, we have ensured that the amount of credit is always nonnegative. Thus, for
any sequence of n P USH, P OP, and M ULTIPOP operations, the total amortized cost
is an upper bound on the total actual cost. Since the total amortized cost is O.n/,
so is the total actual cost.
Incrementing a binary counter
As another illustration of the accounting method, we analyze the I NCREMENT operation on a binary counter that starts at zero. As we observed earlier, the running
time of this operation is proportional to the number of bits ﬂipped, which we shall
use as our cost for this example. Let us once again use a dollar bill to represent
each unit of cost (the ﬂipping of a bit in this example).
For the amortized analysis, let us charge an amortized cost of 2 dollars to set a
bit to 1. When a bit is set, we use 1 dollar (out of the 2 dollars charged) to pay
for the actual setting of the bit, and we place the other dollar on the bit as credit to
be used later when we ﬂip the bit back to 0. At any point in time, every 1 in the
counter has a dollar of credit on it, and thus we can charge nothing to reset a bit
to 0; we just pay for the reset with the dollar bill on the bit.
Now we can determine the amortized cost of I NCREMENT. The cost of resetting
the bits within the while loop is paid for by the dollars on the bits that are reset. The
I NCREMENT procedure sets at most one bit, in line 6, and therefore the amortized
cost of an I NCREMENT operation is at most 2 dollars. The number of 1s in the
counter never becomes negative, and thus the amount of credit stays nonnegative
at all times. Thus, for n I NCREMENT operations, the total amortized cost is O.n/,
which bounds the total actual cost.
Exercises
17.2-1
Suppose we perform a sequence of stack operations on a stack whose size never
exceeds k. After every k operations, we make a copy of the entire stack for backup
purposes. Show that the cost of n stack operations, including copying the stack,
is O.n/ by assigning suitable amortized costs to the various stack operations.

17.3 The potential method

459

17.2-2
Redo Exercise 17.1-3 using an accounting method of analysis.
17.2-3
Suppose we wish not only to increment a counter but also to reset it to zero (i.e.,
make all bits in it 0). Counting the time to examine or modify a bit as ‚.1/,
show how to implement a counter as an array of bits so that any sequence of n
I NCREMENT and R ESET operations takes time O.n/ on an initially zero counter.
(Hint: Keep a pointer to the high-order 1.)

17.3 The potential method
Instead of representing prepaid work as credit stored with speciﬁc objects in the
data structure, the potential method of amortized analysis represents the prepaid
work as “potential energy,” or just “potential,” which can be released to pay for
future operations. We associate the potential with the data structure as a whole
rather than with speciﬁc objects within the data structure.
The potential method works as follows. We will perform n operations, starting
with an initial data structure D0 . For each i D 1; 2; : : : ; n, we let ci be the actual
cost of the ith operation and Di be the data structure that results after applying
the ith operation to data structure Di 1 . A potential function ˆ maps each data
structure Di to a real number ˆ.Di /, which is the potential associated with data
structure Di . The amortized cost cyi of the ith operation with respect to potential
function ˆ is deﬁned by
cyi D ci C ˆ.Di /  ˆ.Di 1 / :

(17.2)

The amortized cost of each operation is therefore its actual cost plus the change in
potential due to the operation. By equation (17.2), the total amortized cost of the n
operations is
n
X

cyi

n
X
D
.ci C ˆ.Di /  ˆ.Di 1 //

i D1

i D1

D

n
X

ci C ˆ.Dn /  ˆ.D0 / :

(17.3)

i D1

The second equality follows from equation (A.9) because the ˆ.Di / terms telescope.
the total
If we can deﬁne
Pna potential function ˆ so that ˆ.Dn /  ˆ.D0 /, then P
n
amortized cost i D1 cyi gives an upper bound on the total actual cost i D1 ci .

460

Chapter 17 Amortized Analysis

In practice, we do not always know how many operations might be performed.
Therefore, if we require that ˆ.Di /  ˆ.D0 / for all i, then we guarantee, as in
the accounting method, that we pay in advance. We usually just deﬁne ˆ.D0 / to
be 0 and then show that ˆ.Di /  0 for all i. (See Exercise 17.3-1 for an easy way
to handle cases in which ˆ.D0 / ¤ 0.)
Intuitively, if the potential difference ˆ.Di /  ˆ.Di 1 / of the ith operation is
positive, then the amortized cost cyi represents an overcharge to the ith operation,
and the potential of the data structure increases. If the potential difference is negative, then the amortized cost represents an undercharge to the ith operation, and
the decrease in the potential pays for the actual cost of the operation.
The amortized costs deﬁned by equations (17.2) and (17.3) depend on the choice
of the potential function ˆ. Different potential functions may yield different amortized costs yet still be upper bounds on the actual costs. We often ﬁnd trade-offs
that we can make in choosing a potential function; the best potential function to
use depends on the desired time bounds.
Stack operations
To illustrate the potential method, we return once again to the example of the stack
operations P USH, P OP, and M ULTIPOP. We deﬁne the potential function ˆ on a
stack to be the number of objects in the stack. For the empty stack D0 with which
we start, we have ˆ.D0 / D 0. Since the number of objects in the stack is never
negative, the stack Di that results after the ith operation has nonnegative potential,
and thus
ˆ.Di /  0
D ˆ.D0 / :
The total amortized cost of n operations with respect to ˆ therefore represents an
upper bound on the actual cost.
Let us now compute the amortized costs of the various stack operations. If the ith
operation on a stack containing s objects is a P USH operation, then the potential
difference is
ˆ.Di /  ˆ.Di 1 / D .s C 1/  s
D 1:
By equation (17.2), the amortized cost of this P USH operation is
cyi

D ci C ˆ.Di /  ˆ.Di 1 /
D 1C1
D 2:

17.3 The potential method

461

Suppose that the ith operation on the stack is M ULTIPOP .S; k/, which causes
k 0 D min.k; s/ objects to be popped off the stack. The actual cost of the operation is k 0 , and the potential difference is
ˆ.Di /  ˆ.Di 1 / D k 0 :
Thus, the amortized cost of the M ULTIPOP operation is
cyi

D ci C ˆ.Di /  ˆ.Di 1 /
D k0  k0
D 0:

Similarly, the amortized cost of an ordinary P OP operation is 0.
The amortized cost of each of the three operations is O.1/, and thus the total
amortized cost of a sequence of n operations is O.n/. Since we have already argued
that ˆ.Di /  ˆ.D0 /, the total amortized cost of n operations is an upper bound
on the total actual cost. The worst-case cost of n operations is therefore O.n/.
Incrementing a binary counter
As another example of the potential method, we again look at incrementing a binary
counter. This time, we deﬁne the potential of the counter after the ith I NCREMENT
operation to be bi , the number of 1s in the counter after the ith operation.
Let us compute the amortized cost of an I NCREMENT operation. Suppose that
the ith I NCREMENT operation resets ti bits. The actual cost of the operation is
therefore at most ti C 1, since in addition to resetting ti bits, it sets at most one
bit to 1. If bi D 0, then the ith operation resets all k bits, and so bi 1 D ti D k.
If bi > 0, then bi D bi 1  ti C 1. In either case, bi  bi 1  ti C 1, and the
potential difference is
ˆ.Di /  ˆ.Di 1 /  .bi 1  ti C 1/  bi 1
D 1  ti :
The amortized cost is therefore
cyi

D ci C ˆ.Di /  ˆ.Di 1 /
 .ti C 1/ C .1  ti /
D 2:

If the counter starts at zero, then ˆ.D0 / D 0. Since ˆ.Di /  0 for all i, the total
amortized cost of a sequence of n I NCREMENT operations is an upper bound on the
total actual cost, and so the worst-case cost of n I NCREMENT operations is O.n/.
The potential method gives us an easy way to analyze the counter even when
it does not start at zero. The counter starts with b0 1s, and after n I NCREMENT

462

Chapter 17 Amortized Analysis

operations it has bn 1s, where 0  b0 ; bn  k. (Recall that k is the number of bits
in the counter.) We can rewrite equation (17.3) as
n
X

ci D

i D1

n
X

cyi  ˆ.Dn / C ˆ.D0 / :

(17.4)

i D1

We have cyi  2 for all 1  i  n. Since ˆ.D0 / D b0 and ˆ.Dn / D bn , the total
actual cost of n I NCREMENT operations is
n
X

ci



i D1

n
X

2  bn C b0

i D1

D 2n  bn C b0 :
Note in particular that since b0  k, as long as k D O.n/, the total actual cost
is O.n/. In other words, if we execute at least n D .k/ I NCREMENT operations,
the total actual cost is O.n/, no matter what initial value the counter contains.
Exercises
17.3-1
Suppose we have a potential function ˆ such that ˆ.Di /  ˆ.D0 / for all i, but
ˆ.D0 / ¤ 0. Show that there exists a potential function ˆ0 such that ˆ0 .D0 / D 0,
ˆ0 .Di /  0 for all i  1, and the amortized costs using ˆ0 are the same as the
amortized costs using ˆ.
17.3-2
Redo Exercise 17.1-3 using a potential method of analysis.
17.3-3
Consider an ordinary binary min-heap data structure with n elements supporting
the instructions I NSERT and E XTRACT-M IN in O.lg n/ worst-case time. Give a
potential function ˆ such that the amortized cost of I NSERT is O.lg n/ and the
amortized cost of E XTRACT-M IN is O.1/, and show that it works.
17.3-4
What is the total cost of executing n of the stack operations P USH, P OP, and
M ULTIPOP , assuming that the stack begins with s0 objects and ﬁnishes with sn
objects?
17.3-5
Suppose that a counter begins at a number with b 1s in its binary representation, rather than at 0. Show that the cost of performing n I NCREMENT operations
is O.n/ if n D .b/. (Do not assume that b is constant.)

17.4 Dynamic tables

463

17.3-6
Show how to implement a queue with two ordinary stacks (Exercise 10.1-6) so that
the amortized cost of each E NQUEUE and each D EQUEUE operation is O.1/.
17.3-7
Design a data structure to support the following two operations for a dynamic
multiset S of integers, which allows duplicate values:
I NSERT .S; x/ inserts x into S.
D ELETE -L ARGER -H ALF .S/ deletes the largest djSj =2e elements from S.
Explain how to implement this data structure so that any sequence of m I NSERT
and D ELETE -L ARGER -H ALF operations runs in O.m/ time. Your implementation
should also include a way to output the elements of S in O.jSj/ time.

17.4 Dynamic tables
We do not always know in advance how many objects some applications will store
in a table. We might allocate space for a table, only to ﬁnd out later that it is not
enough. We must then reallocate the table with a larger size and copy all objects
stored in the original table over into the new, larger table. Similarly, if many objects
have been deleted from the table, it may be worthwhile to reallocate the table with
a smaller size. In this section, we study this problem of dynamically expanding and
contracting a table. Using amortized analysis, we shall show that the amortized cost
of insertion and deletion is only O.1/, even though the actual cost of an operation
is large when it triggers an expansion or a contraction. Moreover, we shall see how
to guarantee that the unused space in a dynamic table never exceeds a constant
fraction of the total space.
We assume that the dynamic table supports the operations TABLE -I NSERT and
TABLE -D ELETE. TABLE -I NSERT inserts into the table an item that occupies a single slot, that is, a space for one item. Likewise, TABLE -D ELETE removes an item
from the table, thereby freeing a slot. The details of the data-structuring method
used to organize the table are unimportant; we might use a stack (Section 10.1),
a heap (Chapter 6), or a hash table (Chapter 11). We might also use an array or
collection of arrays to implement object storage, as we did in Section 10.3.
We shall ﬁnd it convenient to use a concept introduced in our analysis of hashing
(Chapter 11). We deﬁne the load factor ˛.T / of a nonempty table T to be the
number of items stored in the table divided by the size (number of slots) of the
table. We assign an empty table (one with no items) size 0, and we deﬁne its load
factor to be 1. If the load factor of a dynamic table is bounded below by a constant,

464

Chapter 17 Amortized Analysis

the unused space in the table is never more than a constant fraction of the total
amount of space.
We start by analyzing a dynamic table in which we only insert items. We then
consider the more general case in which we both insert and delete items.
17.4.1

Table expansion

Let us assume that storage for a table is allocated as an array of slots. A table ﬁlls
up when all slots have been used or, equivalently, when its load factor is 1.1 In some
software environments, upon attempting to insert an item into a full table, the only
alternative is to abort with an error. We shall assume, however, that our software
environment, like many modern ones, provides a memory-management system that
can allocate and free blocks of storage on request. Thus, upon inserting an item
into a full table, we can expand the table by allocating a new table with more slots
than the old table had. Because we always need the table to reside in contiguous
memory, we must allocate a new array for the larger table and then copy items from
the old table into the new table.
A common heuristic allocates a new table with twice as many slots as the old
one. If the only table operations are insertions, then the load factor of the table is
always at least 1=2, and thus the amount of wasted space never exceeds half the
total space in the table.
In the following pseudocode, we assume that T is an object representing the
table. The attribute T:table contains a pointer to the block of storage representing
the table, T:num contains the number of items in the table, and T:size gives the total
number of slots in the table. Initially, the table is empty: T:num D T:size D 0.
TABLE -I NSERT .T; x/
1 if T:size == 0
2
allocate T:table with 1 slot
3
T:size D 1
4 if T:num == T:size
5
allocate new-table with 2  T:size slots
6
insert all items in T:table into new-table
7
free T:table
8
T:table D new-table
9
T:size D 2  T:size
10 insert x into T:table
11 T:num D T:num C 1

1 In

some situations, such as an open-address hash table, we may wish to consider a table to be full if
its load factor equals some constant strictly less than 1. (See Exercise 17.4-1.)

17.4 Dynamic tables

465

Notice that we have two “insertion” procedures here: the TABLE -I NSERT procedure itself and the elementary insertion into a table in lines 6 and 10. We can
analyze the running time of TABLE -I NSERT in terms of the number of elementary
insertions by assigning a cost of 1 to each elementary insertion. We assume that
the actual running time of TABLE -I NSERT is linear in the time to insert individual
items, so that the overhead for allocating an initial table in line 2 is constant and
the overhead for allocating and freeing storage in lines 5 and 7 is dominated by
the cost of transferring items in line 6. We call the event in which lines 5–9 are
executed an expansion.
Let us analyze a sequence of n TABLE -I NSERT operations on an initially empty
table. What is the cost ci of the ith operation? If the current table has room for the
new item (or if this is the ﬁrst operation), then ci D 1, since we need only perform
the one elementary insertion in line 10. If the current table is full, however, and an
expansion occurs, then ci D i: the cost is 1 for the elementary insertion in line 10
plus i  1 for the items that we must copy from the old table to the new table in
line 6. If we perform n operations, the worst-case cost of an operation is O.n/,
which leads to an upper bound of O.n2 / on the total running time for n operations.
This bound is not tight, because we rarely expand the table in the course of n
TABLE -I NSERT operations. Speciﬁcally, the ith operation causes an expansion
only when i  1 is an exact power of 2. The amortized cost of an operation is in
fact O.1/, as we can show using aggregate analysis. The cost of the ith operation
is
(
i if i  1 is an exact power of 2 ;
ci D
1 otherwise :
The total cost of n TABLE -I NSERT operations is therefore
n
X
i D1

X

blg nc

ci

 nC

2j

j D0

< n C 2n
D 3n ;
because at most n operations cost 1 and the costs of the remaining operations form
a geometric series. Since the total cost of n TABLE -I NSERT operations is bounded
by 3n, the amortized cost of a single operation is at most 3.
By using the accounting method, we can gain some feeling for why the amortized cost of a TABLE -I NSERT operation should be 3. Intuitively, each item pays
for 3 elementary insertions: inserting itself into the current table, moving itself
when the table expands, and moving another item that has already been moved
once when the table expands. For example, suppose that the size of the table is m
immediately after an expansion. Then the table holds m=2 items, and it contains

466

Chapter 17 Amortized Analysis

no credit. We charge 3 dollars for each insertion. The elementary insertion that
occurs immediately costs 1 dollar. We place another dollar as credit on the item
inserted. We place the third dollar as credit on one of the m=2 items already in the
table. The table will not ﬁll again until we have inserted another m=2  1 items,
and thus, by the time the table contains m items and is full, we will have placed a
dollar on each item to pay to reinsert it during the expansion.
We can use the potential method to analyze a sequence of n TABLE -I NSERT
operations, and we shall use it in Section 17.4.2 to design a TABLE -D ELETE operation that has an O.1/ amortized cost as well. We start by deﬁning a potential
function ˆ that is 0 immediately after an expansion but builds to the table size by
the time the table is full, so that we can pay for the next expansion by the potential.
The function
ˆ.T / D 2  T:num  T:size

(17.5)

is one possibility. Immediately after an expansion, we have T:num D T:size=2,
and thus ˆ.T / D 0, as desired. Immediately before an expansion, we have
T:num D T:size, and thus ˆ.T / D T:num, as desired. The initial value of the
potential is 0, and since the table is always at least half full, T:num  T:size=2,
which implies that ˆ.T / is always nonnegative. Thus, the sum of the amortized
costs of n TABLE -I NSERT operations gives an upper bound on the sum of the actual
costs.
To analyze the amortized cost of the ith TABLE -I NSERT operation, we let numi
denote the number of items stored in the table after the ith operation, sizei denote
the total size of the table after the ith operation, and ˆi denote the potential after
the ith operation. Initially, we have num0 D 0, size0 D 0, and ˆ0 D 0.
If the ith TABLE -I NSERT operation does not trigger an expansion, then we have
sizei D sizei 1 and the amortized cost of the operation is
cyi

D
D
D
D

ci C ˆi  ˆi 1
1 C .2  numi  sizei /  .2  numi 1  sizei 1 /
1 C .2  numi  sizei /  .2.numi  1/  sizei /
3:

If the ith operation does trigger an expansion, then we have sizei D 2  sizei 1 and
sizei 1 D numi 1 D numi  1, which implies that sizei D 2  .numi  1/. Thus,
the amortized cost of the operation is
cyi

D
D
D
D
D

ci C ˆi  ˆi 1
numi C .2  numi  sizei /  .2  numi 1  sizei 1 /
numi C .2  numi  2  .numi  1//  .2.numi  1/  .numi  1//
numi C 2  .numi  1/
3:

17.4 Dynamic tables

467

32

sizei

24

16

numi

Φi

8

i

0
0

8

16

24

32

Figure 17.3 The effect of a sequence of n TABLE -I NSERT operations on the number numi of items
in the table, the number sizei of slots in the table, and the potential ˆi D 2  numi  sizei , each
being measured after the ith operation. The thin line shows numi , the dashed line shows sizei , and
the thick line shows ˆi . Notice that immediately before an expansion, the potential has built up to
the number of items in the table, and therefore it can pay for moving all the items to the new table.
Afterwards, the potential drops to 0, but it is immediately increased by 2 upon inserting the item that
caused the expansion.

Figure 17.3 plots the values of numi , sizei , and ˆi against i. Notice how the
potential builds to pay for expanding the table.
17.4.2

Table expansion and contraction

To implement a TABLE -D ELETE operation, it is simple enough to remove the speciﬁed item from the table. In order to limit the amount of wasted space, however,
we might wish to contract the table when the load factor becomes too small. Table
contraction is analogous to table expansion: when the number of items in the table
drops too low, we allocate a new, smaller table and then copy the items from the
old table into the new one. We can then free the storage for the old table by returning it to the memory-management system. Ideally, we would like to preserve two
properties:


the load factor of the dynamic table is bounded below by a positive constant,
and



the amortized cost of a table operation is bounded above by a constant.

468

Chapter 17 Amortized Analysis

We assume that we measure the cost in terms of elementary insertions and deletions.
You might think that we should double the table size upon inserting an item into
a full table and halve the size when a deleting an item would cause the table to
become less than half full. This strategy would guarantee that the load factor of
the table never drops below 1=2, but unfortunately, it can cause the amortized cost
of an operation to be quite large. Consider the following scenario. We perform n
operations on a table T , where n is an exact power of 2. The ﬁrst n=2 operations are
insertions, which by our previous analysis cost a total of ‚.n/. At the end of this
sequence of insertions, T:num D T:size D n=2. For the second n=2 operations,
we perform the following sequence:
insert, delete, delete, insert, insert, delete, delete, insert, insert, . . . .
The ﬁrst insertion causes the table to expand to size n. The two following deletions
cause the table to contract back to size n=2. Two further insertions cause another
expansion, and so forth. The cost of each expansion and contraction is ‚.n/, and
there are ‚.n/ of them. Thus, the total cost of the n operations is ‚.n2 /, making
the amortized cost of an operation ‚.n/.
The downside of this strategy is obvious: after expanding the table, we do not
delete enough items to pay for a contraction. Likewise, after contracting the table,
we do not insert enough items to pay for an expansion.
We can improve upon this strategy by allowing the load factor of the table to
drop below 1=2. Speciﬁcally, we continue to double the table size upon inserting
an item into a full table, but we halve the table size when deleting an item causes
the table to become less than 1=4 full, rather than 1=2 full as before. The load
factor of the table is therefore bounded below by the constant 1=4.
Intuitively, we would consider a load factor of 1=2 to be ideal, and the table’s
potential would then be 0. As the load factor deviates from 1=2, the potential
increases so that by the time we expand or contract the table, the table has garnered
sufﬁcient potential to pay for copying all the items into the newly allocated table.
Thus, we will need a potential function that has grown to T:num by the time that
the load factor has either increased to 1 or decreased to 1=4. After either expanding
or contracting the table, the load factor goes back to 1=2 and the table’s potential
reduces back to 0.
We omit the code for TABLE -D ELETE, since it is analogous to TABLE -I NSERT.
For our analysis, we shall assume that whenever the number of items in the table
drops to 0, we free the storage for the table. That is, if T:num D 0, then T:size D 0.
We can now use the potential method to analyze the cost of a sequence of n
TABLE -I NSERT and TABLE -D ELETE operations. We start by deﬁning a potential function ˆ that is 0 immediately after an expansion or contraction and builds
as the load factor increases to 1 or decreases to 1=4. Let us denote the load fac-

17.4 Dynamic tables

469

32

24

sizei

16

numi

8
Φi
0

0

8

16

24

32

40

48

i

Figure 17.4 The effect of a sequence of n TABLE -I NSERT and TABLE -D ELETE operations on the
number numi of items in the table, the number sizei of slots in the table, and the potential



ˆi D

2  numi  sizei
sizei =2  numi

if ˛i  1=2 ;
if ˛i < 1=2 ;

each measured after the ith operation. The thin line shows numi , the dashed line shows sizei , and
the thick line shows ˆi . Notice that immediately before an expansion, the potential has built up to
the number of items in the table, and therefore it can pay for moving all the items to the new table.
Likewise, immediately before a contraction, the potential has built up to the number of items in the
table.

tor of a nonempty table T by ˛.T / D T:num=T:size. Since for an empty table,
T:num D T:size D 0 and ˛.T / D 1, we always have T:num D ˛.T /  T:size,
whether the table is empty or not. We shall use as our potential function
(
2  T:num  T:size if ˛.T /  1=2 ;
ˆ.T / D
(17.6)
T:size=2  T:num if ˛.T / < 1=2 :
Observe that the potential of an empty table is 0 and that the potential is never
negative. Thus, the total amortized cost of a sequence of operations with respect
to ˆ provides an upper bound on the actual cost of the sequence.
Before proceeding with a precise analysis, we pause to observe some properties
of the potential function, as illustrated in Figure 17.4. Notice that when the load
factor is 1=2, the potential is 0. When the load factor is 1, we have T:size D T:num,
which implies ˆ.T / D T:num, and thus the potential can pay for an expansion if
an item is inserted. When the load factor is 1=4, we have T:size D 4T:num, which

470

Chapter 17 Amortized Analysis

implies ˆ.T / D T:num, and thus the potential can pay for a contraction if an item
is deleted.
To analyze a sequence of n TABLE -I NSERT and TABLE -D ELETE operations,
we let ci denote the actual cost of the ith operation, cyi denote its amortized cost
with respect to ˆ, numi denote the number of items stored in the table after the ith
operation, sizei denote the total size of the table after the ith operation, ˛i denote
the load factor of the table after the ith operation, and ˆi denote the potential after
the ith operation. Initially, num0 D 0, size0 D 0, ˛0 D 1, and ˆ0 D 0.
We start with the case in which the ith operation is TABLE -I NSERT. The analysis is identical to that for table expansion in Section 17.4.1 if ˛i 1  1=2. Whether
the table expands or not, the amortized cost cyi of the operation is at most 3.
If ˛i 1 < 1=2, the table cannot expand as a result of the operation, since the table expands only when ˛i 1 D 1. If ˛i < 1=2 as well, then the amortized cost of
the ith operation is
cyi

D
D
D
D

ci C ˆi  ˆi 1
1 C .sizei =2  numi /  .sizei 1 =2  numi 1 /
1 C .sizei =2  numi /  .sizei =2  .numi  1//
0:

If ˛i 1 < 1=2 but ˛i  1=2, then
cyi

D ci C ˆi  ˆi 1
D 1 C .2  numi  sizei /  .sizei 1 =2  numi 1 /
D 1 C .2.numi 1 C 1/  sizei 1 /  .sizei 1 =2  numi 1 /
3
D 3  numi 1  sizei 1 C 3
2
3
D 3˛i 1 sizei 1  sizei 1 C 3
2
3
3
sizei 1  sizei 1 C 3
<
2
2
D 3:

Thus, the amortized cost of a TABLE -I NSERT operation is at most 3.
We now turn to the case in which the ith operation is TABLE -D ELETE. In this
case, numi D numi 1  1. If ˛i 1 < 1=2, then we must consider whether the
operation causes the table to contract. If it does not, then sizei D sizei 1 and the
amortized cost of the operation is
cyi

D
D
D
D

ci C ˆi  ˆi 1
1 C .sizei =2  numi /  .sizei 1 =2  numi 1 /
1 C .sizei =2  numi /  .sizei =2  .numi C 1//
2:

17.4 Dynamic tables

471

If ˛i 1 < 1=2 and the ith operation does trigger a contraction, then the actual cost
of the operation is ci D numi C 1, since we delete one item and move numi items.
We have sizei =2 D sizei 1 =4 D numi 1 D numi C 1, and the amortized cost of
the operation is
cyi

D
D
D
D

ci C ˆi  ˆi 1
.numi C 1/ C .sizei =2  numi /  .sizei 1 =2  numi 1 /
.numi C 1/ C ..numi C 1/  numi /  ..2  numi C 2/  .numi C 1//
1:

When the ith operation is a TABLE -D ELETE and ˛i 1  1=2, the amortized cost
is also bounded above by a constant. We leave the analysis as Exercise 17.4-2.
In summary, since the amortized cost of each operation is bounded above by
a constant, the actual time for any sequence of n operations on a dynamic table
is O.n/.
Exercises
17.4-1
Suppose that we wish to implement a dynamic, open-address hash table. Why
might we consider the table to be full when its load factor reaches some value ˛
that is strictly less than 1? Describe brieﬂy how to make insertion into a dynamic,
open-address hash table run in such a way that the expected value of the amortized
cost per insertion is O.1/. Why is the expected value of the actual cost per insertion
not necessarily O.1/ for all insertions?
17.4-2
Show that if ˛i 1  1=2 and the ith operation on a dynamic table is TABLE D ELETE, then the amortized cost of the operation with respect to the potential
function (17.6) is bounded above by a constant.
17.4-3
Suppose that instead of contracting a table by halving its size when its load factor
drops below 1=4, we contract it by multiplying its size by 2=3 when its load factor
drops below 1=3. Using the potential function
ˆ.T / D j2  T:num  T:sizej ;
show that the amortized cost of a TABLE -D ELETE that uses this strategy is bounded
above by a constant.

472

Chapter 17 Amortized Analysis

Problems
17-1 Bit-reversed binary counter
Chapter 30 examines an important algorithm called the fast Fourier transform,
or FFT. The ﬁrst step of the FFT algorithm performs a bit-reversal permutation on
an input array AŒ0 : : n  1 whose length is n D 2k for some nonnegative integer k.
This permutation swaps elements whose indices have binary representations that
are the reverse of each other.
We can express each index a as a k-bit sequence hak1 ; ak2 ; : : : ; a0 i, where
Pk1
a D i D0 ai 2i . We deﬁne
revk .hak1 ; ak2 ; : : : ; a0 i/ D ha0 ; a1 ; : : : ; ak1 i I
thus,
revk .a/ D

k1
X

aki 1 2i :

i D0

For example, if n D 16 (or, equivalently, k D 4), then revk .3/ D 12, since
the 4-bit representation of 3 is 0011, which when reversed gives 1100, the 4-bit
representation of 12.
a. Given a function revk that runs in ‚.k/ time, write an algorithm to perform the
bit-reversal permutation on an array of length n D 2k in O.nk/ time.
We can use an algorithm based on an amortized analysis to improve the running
time of the bit-reversal permutation. We maintain a “bit-reversed counter” and a
procedure B IT-R EVERSED -I NCREMENT that, when given a bit-reversed-counter
value a, produces revk .revk .a/ C 1/. If k D 4, for example, and the bit-reversed
counter starts at 0, then successive calls to B IT-R EVERSED -I NCREMENT produce
the sequence
0000; 1000; 0100; 1100; 0010; 1010; : : : D 0; 8; 4; 12; 2; 10; : : : :
b. Assume that the words in your computer store k-bit values and that in unit time,
your computer can manipulate the binary values with operations such as shifting
left or right by arbitrary amounts, bitwise-AND, bitwise-OR, etc. Describe
an implementation of the B IT-R EVERSED -I NCREMENT procedure that allows
the bit-reversal permutation on an n-element array to be performed in a total
of O.n/ time.
c. Suppose that you can shift a word left or right by only one bit in unit time. Is it
still possible to implement an O.n/-time bit-reversal permutation?

Problems for Chapter 17

473

17-2 Making binary search dynamic
Binary search of a sorted array takes logarithmic search time, but the time to insert
a new element is linear in the size of the array. We can improve the time for
insertion by keeping several sorted arrays.
Speciﬁcally, suppose that we wish to support S EARCH and I NSERT on a set
of n elements. Let k D dlg.n C 1/e, and let the binary representation of n
be hnk1 ; nk2 ; : : : ; n0 i. We have k sorted arrays A0 ; A1 ; : : : ; Ak1 , where for
i D 0; 1; : : : ; k  1, the length of array Ai is 2i . Each array is either full or empty,
depending on whether ni D 1 or ni D 0, respectively. The total number of elePk1
ments held in all k arrays is therefore i D0 ni 2i D n. Although each individual
array is sorted, elements in different arrays bear no particular relationship to each
other.
a. Describe how to perform the S EARCH operation for this data structure. Analyze
its worst-case running time.
b. Describe how to perform the I NSERT operation. Analyze its worst-case and
amortized running times.
c. Discuss how to implement D ELETE.
17-3 Amortized weight-balanced trees
Consider an ordinary binary search tree augmented by adding to each node x the
attribute x:size giving the number of keys stored in the subtree rooted at x. Let ˛
be a constant in the range 1=2  ˛ < 1. We say that a given node x is ˛-balanced
if x:left:size  ˛  x:size and x:right:size  ˛  x:size. The tree as a whole
is ˛-balanced if every node in the tree is ˛-balanced. The following amortized
approach to maintaining weight-balanced trees was suggested by G. Varghese.
a. A 1=2-balanced tree is, in a sense, as balanced as it can be. Given a node x
in an arbitrary binary search tree, show how to rebuild the subtree rooted at x
so that it becomes 1=2-balanced. Your algorithm should run in time ‚.x:size/,
and it can use O.x:size/ auxiliary storage.
b. Show that performing a search in an n-node ˛-balanced binary search tree
takes O.lg n/ worst-case time.
For the remainder of this problem, assume that the constant ˛ is strictly greater
than 1=2. Suppose that we implement I NSERT and D ELETE as usual for an n-node
binary search tree, except that after every such operation, if any node in the tree
is no longer ˛-balanced, then we “rebuild” the subtree rooted at the highest such
node in the tree so that it becomes 1=2-balanced.

474

Chapter 17 Amortized Analysis

We shall analyze this rebuilding scheme using the potential method. For a node x
in a binary search tree T , we deﬁne
.x/ D jx:left:size  x:right:sizej ;
and we deﬁne the potential of T as
X
.x/ ;
ˆ.T / D c
x2T W.x/2

where c is a sufﬁciently large constant that depends on ˛.
c. Argue that any binary search tree has nonnegative potential and that a 1=2balanced tree has potential 0.
d. Suppose that m units of potential can pay for rebuilding an m-node subtree.
How large must c be in terms of ˛ in order for it to take O.1/ amortized time
to rebuild a subtree that is not ˛-balanced?
e. Show that inserting a node into or deleting a node from an n-node ˛-balanced
tree costs O.lg n/ amortized time.
17-4 The cost of restructuring red-black trees
There are four basic operations on red-black trees that perform structural modiﬁcations: node insertions, node deletions, rotations, and color changes. We have
seen that RB-I NSERT and RB-D ELETE use only O.1/ rotations, node insertions,
and node deletions to maintain the red-black properties, but they may make many
more color changes.
a. Describe a legal red-black tree with n nodes such that calling RB-I NSERT to
add the .n C 1/st node causes .lg n/ color changes. Then describe a legal
red-black tree with n nodes for which calling RB-D ELETE on a particular node
causes .lg n/ color changes.
Although the worst-case number of color changes per operation can be logarithmic,
we shall prove that any sequence of m RB-I NSERT and RB-D ELETE operations on
an initially empty red-black tree causes O.m/ structural modiﬁcations in the worst
case. Note that we count each color change as a structural modiﬁcation.
b. Some of the cases handled by the main loop of the code of both RB-I NSERTF IXUP and RB-D ELETE -F IXUP are terminating: once encountered, they cause
the loop to terminate after a constant number of additional operations. For each
of the cases of RB-I NSERT-F IXUP and RB-D ELETE -F IXUP, specify which are
terminating and which are not. (Hint: Look at Figures 13.5, 13.6, and 13.7.)

Problems for Chapter 17

475

We shall ﬁrst analyze the structural modiﬁcations when only insertions are performed. Let T be a red-black tree, and deﬁne ˆ.T / to be the number of red nodes
in T . Assume that 1 unit of potential can pay for the structural modiﬁcations performed by any of the three cases of RB-I NSERT-F IXUP.
c. Let T 0 be the result of applying Case 1 of RB-I NSERT-F IXUP to T . Argue that
ˆ.T 0 / D ˆ.T /  1.
d. When we insert a node into a red-black tree using RB-I NSERT, we can break
the operation into three parts. List the structural modiﬁcations and potential
changes resulting from lines 1–16 of RB-I NSERT, from nonterminating cases
of RB-I NSERT-F IXUP, and from terminating cases of RB-I NSERT-F IXUP.
e. Using part (d), argue that the amortized number of structural modiﬁcations performed by any call of RB-I NSERT is O.1/.
We now wish to prove that there are O.m/ structural modiﬁcations when there are
both insertions and deletions. Let us deﬁne, for each node x,

„0

w.x/ D

if x is red ;
1 if x is black and has no red children ;
0 if x is black and has one red child ;
2 if x is black and has two red children :

Now we redeﬁne the potential of a red-black tree T as
X
w.x/ ;
ˆ.T / D
x2T

and let T 0 be the tree that results from applying any nonterminating case of RBI NSERT-F IXUP or RB-D ELETE -F IXUP to T .
f. Show that ˆ.T 0 /  ˆ.T /  1 for all nonterminating cases of RB-I NSERTF IXUP. Argue that the amortized number of structural modiﬁcations performed
by any call of RB-I NSERT-F IXUP is O.1/.
g. Show that ˆ.T 0 /  ˆ.T /  1 for all nonterminating cases of RB-D ELETE F IXUP. Argue that the amortized number of structural modiﬁcations performed
by any call of RB-D ELETE -F IXUP is O.1/.
h. Complete the proof that in the worst case, any sequence of m RB-I NSERT and
RB-D ELETE operations performs O.m/ structural modiﬁcations.

476

Chapter 17 Amortized Analysis

17-5 Competitive analysis of self-organizing lists with move-to-front
A self-organizing list is a linked list of n elements, in which each element has a
unique key. When we search for an element in the list, we are given a key, and we
want to ﬁnd an element with that key.
A self-organizing list has two important properties:
1. To ﬁnd an element in the list, given its key, we must traverse the list from the
beginning until we encounter the element with the given key. If that element is
the kth element from the start of the list, then the cost to ﬁnd the element is k.
2. We may reorder the list elements after any operation, according to a given rule
with a given cost. We may choose any heuristic we like to decide how to reorder
the list.
Assume that we start with a given list of n elements, and we are given an access
sequence D h 1 ; 2 ; : : : ; m i of keys to ﬁnd, in order. The cost of the sequence
is the sum of the costs of the individual accesses in the sequence.
Out of the various possible ways to reorder the list after an operation, this problem focuses on transposing adjacent list elements—switching their positions in the
list—with a unit cost for each transpose operation. You will show, by means of a
potential function, that a particular heuristic for reordering the list, move-to-front,
entails a total cost no worse than 4 times that of any other heuristic for maintaining
the list order—even if the other heuristic knows the access sequence in advance!
We call this type of analysis a competitive analysis.
For a heuristic H and a given initial ordering of the list, denote the access cost of
sequence by CH . /. Let m be the number of accesses in .
a. Argue that if heuristic H does not know the access sequence in advance, then
the worst-case cost for H on an access sequence is CH . / D .mn/.
With the move-to-front heuristic, immediately after searching for an element x,
we move x to the ﬁrst position on the list (i.e., the front of the list).
Let rankL .x/ denote the rank of element x in list L, that is, the position of x in
list L. For example, if x is the fourth element in L, then rankL .x/ D 4. Let ci
denote the cost of access i using the move-to-front heuristic, which includes the
cost of ﬁnding the element in the list and the cost of moving it to the front of the
list by a series of transpositions of adjacent list elements.
b. Show that if i accesses element x in list L using the move-to-front heuristic,
then ci D 2  rankL .x/  1.
Now we compare move-to-front with any other heuristic H that processes an
access sequence according to the two properties above. Heuristic H may transpose

Problems for Chapter 17

477

elements in the list in any way it wants, and it might even know the entire access
sequence in advance.
Let Li be the list after access i using move-to-front, and let Li be the list after
access i using heuristic H. We denote the cost of access i by ci for move-tofront and by ci for heuristic H. Suppose that heuristic H performs ti transpositions
during access i .
c. In part (b), you showed that ci D 2  rankLi 1 .x/  1. Now show that ci D
rankLi 1 .x/ C ti .
We deﬁne an inversion in list Li as a pair of elements y and ´ such that y
precedes ´ in Li and ´ precedes y in list Li . Suppose that list Li has qi inversions
after processing the access sequence h 1 ; 2 ; : : : ; i i. Then, we deﬁne a potential
function ˆ that maps Li to a real number by ˆ.Li / D 2qi . For example, if Li has
the elements he; c; a; d; bi and Li has the elements hc; a; b; d; ei, then Li has 5
inversions (.e; c/; .e; a/; .e; d /; .e; b/; .d; b/), and so ˆ.Li / D 10. Observe that
ˆ.Li /  0 for all i and that, if move-to-front and heuristic H start with the same
list L0 , then ˆ.L0 / D 0.
d. Argue that a transposition either increases the potential by 2 or decreases the
potential by 2.
Suppose that access i ﬁnds the element x. To understand how the potential
changes due to i , let us partition the elements other than x into four sets, depending on where they are in the lists just before the ith access:


Set A consists of elements that precede x in both Li 1 and Li 1 .



Set B consists of elements that precede x in Li 1 and follow x in Li 1 .



Set C consists of elements that follow x in Li 1 and precede x in Li 1 .



Set D consists of elements that follow x in both Li 1 and Li 1 .

e. Argue that rankLi 1 .x/ D jAj C jBj C 1 and rankLi 1 .x/ D jAj C jC j C 1.
f. Show that access

i

causes a change in potential of

ˆ.Li /  ˆ.Li 1 /  2.jAj  jBj C ti / ;
where, as before, heuristic H performs ti transpositions during access
Deﬁne the amortized cost cyi of access

i

i.

by cyi D ci C ˆ.Li /  ˆ.Li 1 /.

g. Show that the amortized cost cyi of access

i

is bounded from above by 4ci .

h. Conclude that the cost CMTF . / of access sequence with move-to-front is at
most 4 times the cost CH . / of with any other heuristic H, assuming that
both heuristics start with the same list.

478

Chapter 17 Amortized Analysis

Chapter notes
Aho, Hopcroft, and Ullman [5] used aggregate analysis to determine the running
time of operations on a disjoint-set forest; we shall analyze this data structure using the potential method in Chapter 21. Tarjan [331] surveys the accounting and
potential methods of amortized analysis and presents several applications. He attributes the accounting method to several authors, including M. R. Brown, R. E.
Tarjan, S. Huddleston, and K. Mehlhorn. He attributes the potential method to
D. D. Sleator. The term “amortized” is due to D. D. Sleator and R. E. Tarjan.
Potential functions are also useful for proving lower bounds for certain types of
problems. For each conﬁguration of the problem, we deﬁne a potential function
that maps the conﬁguration to a real number. Then we determine the potential ˆinit
of the initial conﬁguration, the potential ˆﬁnal of the ﬁnal conﬁguration, and the
maximum change in potential ˆmax due to any step. The number of steps must
therefore be at least jˆﬁnal  ˆinit j = j ˆmax j. Examples of potential functions to
prove lower bounds in I/O complexity appear in works by Cormen, Sundquist, and
Wisniewski [79]; Floyd [107]; and Aggarwal and Vitter [3]. Krumme, Cybenko,
and Venkataraman [221] applied potential functions to prove lower bounds on gossiping: communicating a unique item from each vertex in a graph to every other
vertex.
The move-to-front heuristic from Problem 17-5 works quite well in practice.
Moreover, if we recognize that when we ﬁnd an element, we can splice it out of its
position in the list and relocate it to the front of the list in constant time, we can
show that the cost of move-to-front is at most twice the cost of any other heuristic
including, again, one that knows the entire access sequence in advance.

